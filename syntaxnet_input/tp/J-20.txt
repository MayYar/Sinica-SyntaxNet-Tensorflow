Clearing Algorithms for Barter Exchange Markets: 
content:
1 ABSTRACT :
1-1:In barter exchange markets, agents seek to swap their items with one another, in order to improve their own utilities .
1-2:These swaps consist of cycles of agents, with each agent receiving the item of the next agent in the cycle .
1-3:We focus mainly on the upcoming national kidney exchange market, where patients with kidney disease can obtain compatible donors by swapping their own willing but incompatible donors .
1-4:With over 70,000 patients already waiting for a cadaver kidney in the US, this market is seen as the only ethical way to significantly reduce the 4,000 deaths per year attributed to kidney disease .
1-5:The clearing problem involves finding a social welfare maximizing exchange when the maximum length of a cycle is fixed .
1-6:Long cycles are forbidden, since, for incentive reasons, all transplants in a cycle must be performed simultaneously .
1-7:Also, in barter exchanges generally, more agents are affected if one drops out of a longer cycle .
1-8:We prove that the clearing problem with this cycle length constraint is NP hard .
1-9:Solving it exactly is one of the main challenges in establishing a national kidney exchange .
1-10:We present the first algorithm capable of clearing these markets on a nationwide scale .
1-11:The key is incremental problem formulation .
1-12:We adapt two paradigms for the task: constraint generation and column generation .
1-13:For each, we develop techniques that dramatically improve both runtime and memory usage .
1-14:We conclude that column generation scales drastically better than constraint generation .
1-15:Our algorithm also supports several generalizations, as demanded by real world kidney exchanges .
1-16:Our algorithm replaced CPLEX as the clearing algorithm of the Alliance for Paired Donation, one of the leading kidney exchanges .
1-17:The match runs are conducted every two weeks and transplants based on our optimizations have already been conducted .
1-18:J.4 [Computer Applications]: Social and Behavioral .
2 INTRODUCTION :
2-1:The role of kidneys is to filter waste from blood .
2-2:Kidney failure results in accumulation of this waste, which leads to death in months .
2-3:One treatment option is dialysis, in which the patient goes to a hospital to have his her blood filtered by an external machine .
2-4:Several visits are required per week, and each takes several hours .
2-5:The quality of life on dialysis can be extremely low, and in fact many patients opt to withdraw from dialysis, leading to a natural death .
2-6:Only 12% of dialysis patients survive 10 years [23] .
2-7:Instead, the preferred treatment is a kidney transplant .
2-8:Kidney transplants are by far the most common transplant .
2-9:Unfortunately, the demand for kidneys far outstrips supply .
2-10:In the United States in 2005, 4,052 people died waiting for a life saving kidney transplant .
2-11:During this time, almost 30,000 people were added to the national waiting list, while only 9,913 people left the list after receiving a deceaseddonor kidney .
2-12:The waiting list currently has over 70,000 people, and the median waiting time ranges from 2 to 5 years, depending on blood type.1 For many patients with kidney disease, the best option is to find a living donor, that is, a healthy person willing to donate one of his her two kidneys .
2-13:Although there are marketplaces for buying and selling living donor kidneys, the commercialization of human organs is almost universally regarded as unethical, and the practice is often explicitly illegal, such as in the US .
2-14:However, in most countries, live donation is legal, provided it occurs as a gift with no financial compensation .
2-15:In 2005, there were 6,563 live donations in the US .
2-16:The number of live donations would have been much higher if it were not for the fact that, frequently, a potential donor 1 Data from the United Network for Organ Sharing [21] .
2-17:295 and his intended recipient are blood type or tissue type incompatible .
2-18:In the past, the incompatible donor was sent home, leaving the patient to wait for a deceased donor kidney .
2-19:However, there are now a few regional kidney exchanges in the United States, in which patients can swap their incompatible donors with each other, in order to each obtain a compatible donor .
2-20:These markets are examples of barter exchanges .
2-21:In a barter exchange market, agents (patients) seek to swap their items (incompatible donors) with each other .
2-22:These swaps consist of cycles of agents, with each agent receiving the item of the next agent in the cycle .
2-23:Barter exchanges are ubiquitous: examples include Peerflix (DVDs) [11], Read It Swap It (books) [12], and Intervac (holiday houses) [9] .
2-24:For many years, there has even been a large shoe exchange in the United States [10] .
2-25:People with different sized feet use this to avoid having to buy two pairs of shoes .
2-26:Leg amputees have a separate exchange to share the cost of buying a single pair of shoes .
2-27:We can encode a barter exchange market as a directed graph G = (V, E) in the following way .
2-28:Construct one vertex for each agent .
2-29:Add a weighted edge e from one agent vi to another vj, if vi wants the item of vj .
2-30:The weight we of e represents the utility to vi of obtaining vj"s item .
2-31:A cycle c in this graph represents a possible swap, with each agent in the cycle obtaining the item of the next agent .
2-32:The weight wc of a cycle c is the sum of its edge weights .
2-33:An exchange is a collection of disjoint cycles .
2-34:The weight of an exchange is the sum of its cycle weights .
2-35:A social welfare maximizing exchange is one with maximum weight .
2-36:Figure 1 illustrates an example market with 5 agents, {v1, v2, .
2-37:.
2-38:.
2-39:, v5}, in which all edges have weight 1 .
2-40:The market has 4 cycles, c1 = v1, v2 , c2 = v2, v3 , c3 = v3, v4 and c4 = v1, v2, v3, v4, v5 , and two (inclusion) maximal exchanges, namely M1 = {c4} and M2 = {c1, c3} .
2-41:Exchange M1 has both maximum weight and maximum cardinality (i.e., it includes the most edges vertices) .
2-42:v1 v2 v3 v4 v5 e1 e3 e5 c1 c2 c3 e8 e7 e6e4e2 c4 Figure 1: Example barter exchange market .
2-43:The clearing problem is to find a maximum weight exchange consisting of cycles with length at most some small constant L .
2-44:This cycle length constraint arises naturally for several reasons .
2-45:For example, in a kidney exchange, all operations in a cycle have to be performed simultaneously; otherwise a donor might back out after his incompatible partner has received a kidney .
2-46:(One cannot write a binding contract to donate an organ.) This gives rise to a logistical constraint on cycle size: even if all the donors are operated on first and the same personnel and facilities are used to then operate on the donees, a k cycle requires between 3k and 6k doctors, around 4k nurses, and almost 2k operating rooms .
2-47:Due to such resource constraints, the upcoming national kidney exchange market will likely allow only cycles of length 2 and 3 .
2-48:Another motivation for short cycles is that if the cycle fails to exchange, fewer agents are affected .
2-49:For example, last minute testing in a kidney exchange often reveals new incompatibilities that were not detected in the initial testing (based on which the compatibility graph was constructed) .
2-50:More generally, an agent may drop out of a cycle if his preferences have changed, or he she simply fails to fulfill his obligations (such as sending a book to another agent in the cycle) due to forgetfulness .
2-51:In Section 3, we show that (the decision version of) the clearing problem is NP complete for L ≥ 3 .
2-52:One approach then might be to look for a good heuristic or approximation algorithm .
2-53:However, for two reasons, we aim for an exact algorithm based on an integer linear program formulation, which we solve using specialized tree search .
2-54:• First, any loss of optimality could lead to unnecessary patient deaths .
2-55:• Second, an attractive feature of using an ILP formulation is that it allows one to easily model a number of variations on the objective, and to add additional constraints to the problem .
2-56:For example, if 3 cycles are believed to be more likely to fail than 2 cycles, then one can simply give them a weight that is appropriately lower than 3 2 the weight of a 2 cycle .
2-57:Or, if for various (e.g., ethical) reasons one requires a maximum cardinality exchange, one can at least in a second pass find the solution (out of all maximum cardinality solutions) that has the fewest 3 cycles .
2-58:Other variations one can solve for include finding various forms of fault tolerant (non disjoint) collections of cycles in the event that certain pairs that were thought to be compatible turn out to be incompatible after all .
2-59:In this paper, we present the first algorithm capable of clearing these markets on a nationwide scale .
2-60:Straight forward ILP encodings are too large to even construct on current hardware not to talk about solving them .
2-61:The key then is incremental problem formulation .
2-62:We adapt two paradigms for the task: constraint generation and column generation .
2-63:For each, we develop a host of (mainly problemspecific) techniques that dramatically improve both runtime and memory usage .
2-64:1.1 Prior Work Several recent papers have used simulations and marketclearing algorithms to explore the impact of a national kidney exchange [13, 20, 6, 14, 15, 17] .
2-65:For example, using Edmond"s maximum matching algorithm [4], [20] shows that a national pairwise exchange market (using length 2 cycles only) would result in more transplants, reduced waiting time, and savings of $750 million in heath care costs over 5 years .
2-66:Those results are conservative in two ways .
2-67:Firstly, the simulated market contained only 4,000 initial patients, with 250 patients added every 3 months .
2-68:It has been reported to us that the market could be almost double this size .
2-69:Secondly, the exchanges were restricted to length 2 cycles (because that is all that can be modeled as maximum matching, and solved using Edmonds"s algorithm) .
2-70:Allowing length 3 cycles leads to additional significant gains .
2-71:This has been demonstrated on kidney exchange markets with 100 patients by using CPLEX to solve an integer program encoding of the clearing problem [15] .
2-72:In this paper, we 296 present an alternative algorithm for this integer program that can clear markets with over 10,000 patients (and that same number of willing donors) .
2-73:Allowing cycles of length more than 3 often leads to no improvement in the size of the exchange [15] .
2-74:(Furthermore, in a simplified theoretical model, any kidney exchange can be converted into one with cycles of length at most 4 [15].) Whilst this does not hold for general barter exchanges, or even for all kidney exchange markets, in Section 5.2.3 we make use of the observation that short cycles suffice to dramatically increase the speed of our algorithm .
2-75:At a high level, the clearing problem for barter exchanges is similar to the clearing problem (aka winner determination problem) in combinatorial auctions .
2-76:In both settings, the idea is to gather all the pertinent information about the agents into a central clearing point and to run a centralized clearing algorithm to determine the allocation .
2-77:Both problems are NP hard .
2-78:Both are best solved using tree search techniques .
2-79:Since 1999, significant work has been done in computer science and operations research on faster optimal tree search algorithms for clearing combinatorial auctions .
2-80:(For a recent review, see [18].) However, the kidney exchange clearing problem (with a limit of 3 or more on cycle size) is different from the combinatorial auction clearing problem in significant ways .
2-81:The most important difference is that the natural formulations of the combinatorial auction problem tend to easily fit in memory, so time is the bottleneck in practice .
2-82:In contrast, the natural formulations of the kidney exchange problem (with L = 3) take at least cubic space in the number of patients to even model, and therefore memory becomes a bottleneck much before time does when using standard tree search, such as branch andcut in CPLEX, to tackle the problem .
2-83:(On a 1GB computer and a realistic standard instance generator, discussed later, CPLEX 10.010 runs out of memory on five of the ten 900patient instances and ten of the ten 1,000 patient instances that we generated.) Therefore, the approaches that have been developed for combinatorial auctions cannot handle the kidney exchange problem .
2-84:1.2 Paper Outline The rest of the paper is organized as follows .
2-85:Section 2 discusses the process by which we generate realistic kidney exchange market data, in order to benchmark the clearing algorithms .
2-86:Section 3 contains a proof that the market clearing decision problem is NP complete .
2-87:Sections 4 and 5 each contain an ILP formulation of the clearing problem .
2-88:We also detail in those sections our techniques used to solve those programs on large instances .
2-89:Section 6 presents experiments on the various techniques .
2-90:Section 7 discusses recent fielding of our algorithm .
2-91:Finally, we present our conclusions in Section 8, and suggest future research directions. .
3 MARKET CHARACTERISTICS AND INSTANCE GENERATOR :
3-1:INSTANCE GENERATOR We test the algorithms on simulated kidney exchange markets, which are generated by a process described in Saidman et al .
3-2:[17] .
3-3:This process is based on the extensive nationwide data maintained by the United Network for Organ Sharing [21], so it generates a realistic instance distribution .
3-4:Several papers have used variations of this process to demonstrate the effectiveness of a national kidney exchange (extrapolating from small instances or restricting the clearing to 2 cycles) [6, 20, 14, 13, 15, 17] .
3-5:Briefly, the process involves generating patients with a random blood type, sex, and probability of being tissue type incompatible with a randomly chosen donor .
3-6:These probabilities are based on actual real world population data .
3-7:Each patient is assigned a potential donor with a random blood type and relation to the patient .
3-8:If the patient and potential donor are incompatible, the two are entered into the market .
3-9:Blood type and tissue type information is then used to decide on which patients and donors are compatible .
3-10:One complication, handled by the generator, is that if the patient is female, and she has had a child with her potential donor, then the probability that the two are incompatible increases .
3-11:(This is because the mother develops antibodies to her partner during pregnancy.) Finally, although our algorithms can handle more general weight functions, patients have a utility of 1 for compatible donors, since their survival probability is not affected by the choice of donor [3] .
3-12:This means that the maximum weight exchange has maximum cardinality .
3-13:Table 1 gives lower and upper bounds on the size of a maximum cardinality exchange in the kidney exchange market .
3-14:The lower bounds were found by clearing the market with length 2 cycles only, while the upper bounds had no restriction on cycle length .
3-15:For each market size, the bounds were computed over 10 randomly generated markets .
3-16:Note that there can be a large amount of variability in the markets in one 5000 patient market, less than 1000 patients were in the maximum cardinality exchange .
3-17:Maximum exchange size Length 2 cycles only Arbitrary cycles Patients Mean Max Mean Max 100 4.00e+1 4.60e+1 5.30e+1 6.10e+1 500 2.58e+2 2.80e+2 2.79e+2 2.97e+2 1000 5.35e+2 6.22e+2 5.61e+2 6.30e+2 2000 1.05e+3 1.13e+3 1.09e+3 1.16e+3 3000 1.63e+3 1.70e+3 1.68e+3 1.73e+3 4000 2.15e+3 2.22e+3 2.20e+3 2.27e+3 5000 2.53e+3 2.87e+3 2.59e+3 2.92e+3 6000 3.26e+3 3.32e+3 3.35e+3 3.39e+3 7000 3.80e+3 3.86e+3 3.89e+3 3.97e+3 8000 4.35e+3 4.45e+3 4.46e+3 4.55e+3 9000 4.90e+3 4.96e+3 5.01e+3 5.07e+3 10000 5.47e+3 5.61e+3 5.59e+3 5.73e+3 Table 1: Upper and lower bounds on exchange size .
3-18:Table 2 gives additional characteristics of the kidney exchange market .
3-19:Note that a market with 5000 patients can already have more than 450 million cycles of length 2 and 3 .
3-20:Edges Length 2 & 3 cycles Patients Mean Max Mean Max 100 2.38e+3 2.79e+3 2.76e+3 5.90e+3 500 6.19e+4 6.68e+4 3.96e+5 5.27e+5 1000 2.44e+5 2.68e+5 3.31e+6 4.57e+6 2000 9.60e+5 1.02e+6 2.50e+7 3.26e+7 3000 2.19e+6 2.28e+6 8.70e+7 9.64e+7 4000 3.86e+6 3.97e+6 1.94e+8 2.14e+8 5000 5.67e+6 6.33e+6 3.60e+8 4.59e+8 6000 8.80e+6 8.95e+6 7000 1.19e+7 1.21e+7 8000 1.56e+7 1.59e+7 9000 1.98e+7 2.02e+7 10000 2.44e+7 2.51e+7 Table 2: Market characteristics .
3-21:297 .
4 PROBLEM COMPLEXITY :
4-1:In this section, we prove that (the decision version of) the market clearing problem with short cycles is NP complete .
4-2:Theorem 1 .
4-3:Given a graph G = (V, E) and an integer L ≥ 3, the problem of deciding if G admits a perfect cycle cover containing cycles of length at most L is NP complete .
4-4:Proof .
4-5:It is clear that this problem is in NP .
4-6:For NPhardness, we reduce from 3D Matching, which is the problem of, given disjoint sets X, Y and Z of size q, and a set of triples T ⊆ X × Y × Z, deciding if there is a disjoint subset M of T with size q .
4-7:One straightforward idea is to construct a tripartite graph with vertex sets X ∪ Y ∪ Z and directed edges (xa, yb), (yb, zc), and (zc, xa) for each triple ti = {xa, yb, zc} ∈ T .
4-8:However, it is not too hard to see that this encoding fails because a perfect cycle cover may include a cycle with no corresponding triple .
4-9:Instead then, we use the following reduction .
4-10:Given an instance of 3D Matching, construct one vertex for each element in X, Y and Z .
4-11:For each triple, ti = {xa, yb, zc} construct the gadget in Figure 2, which is a similar to one in Garey and Johnson [5, pp 68 69] .
4-12:Note that the gadgets intersect only on vertices in X ∪ Y ∪ Z .
4-13:It is clear that this construction can be done in polynomial time .
4-14:1 .. .
4-15:2 3 y_b .. .
4-16:2 3 z_c y_b^i z_c^i L−1 L−1 L−1 x_a^i x_a .. .
4-17:2 31 1 Figure 2: NP completeness gadget for triple ti and maximum cycle length L .
4-18:Let M be a perfect 3D Matching .
4-19:We will show the construction admits a perfect cycle cover by short cycles .
4-20:If ti = {xa, yb, zc} ∈ M, add from ti"s gadget the three lengthL cycles containing xa, yb and zc respectively .
4-21:Also add the cycle ª xi a, yi b, zi c « .
4-22:Otherwise, if ti ∈ M, add the three lengthL cycles containing xi a, yi b and zi c respectively .
4-23:It is clear that all vertices are covered, since M partitions X × Y × Z .
4-24:Conversely, suppose we have a perfect cover by short cycles .
4-25:Note that the construction only has short cycles of lengths 3 and L, and no short cycle involves distinct vertices from two different gadgets .
4-26:It is easy to see then that in a perfect cover, each gadget ti contributes cycles according to the cases above: ti ∈ M, or ti ∈ M .
4-27:Hence, there exists a perfect 3D Matching in the original instance. .
5 SOLUTION APPROACHES BASED ON AN EDGE FORMULATION :
5-1:AN EDGE FORMULATION In this section, we consider a formulation of the clearing problem as an ILP with one variable for each edge .
5-2:This encoding is based on the following classical algorithm for solving the directed cycle cover problem with no cycle length constraints .
5-3:Given a market G = (V, E), construct a bipartite graph with one vertex for each agent, and one vertex for each item .
5-4:Add an edge ev with weight 0 between each agent v and its own item .
5-5:At this point, the encoding is a perfect matching .
5-6:Now, for each edge e = (vi, vj) in the original market, add an edge e with weight we between agent vi and the item of vj .
5-7:Perfect matchings in this encoding correspond exactly with cycle covers, since whenever an agent"s item is taken, it must receive some other agent"s item .
5-8:It follows that the unrestricted clearing problem can be solved in polynomial time by finding a maximum weight perfect matching .
5-9:Figure 3 contains the bipartite graph encoding of the example market from Figure 1 .
5-10:The weight 0 edges are encoded by dashed lines, while the market edges are in bold .
5-11:Items Agents v1 v2 v3 v4 v5 e1 e3 e8 e2 v1 v2 v3 v4 v5 e7e6 e5 e4 Figure 3: Perfect matching encoding of the market in Figure 1 .
5-12:Alternatively, we can solve the problem by encoding it as an ILP with one variable for each edge in the original market graph G .
5-13:This ILP, given below, has the advantage that it can be extended naturally to deal with cycle length constraints .
5-14:Therefore, for the rest of this section, this is the approach we will pursue .
5-15:max e∈E wee such that for all vi ∈ V , the conservation constraint eout=(vi,vj ) eout − ein=(vj ,vi) ein = 0 and capacity constraint eout=(vi,vj ) eout ≤ 1 are satisfied .
5-16:If cycles are allowed to have length at most L, it is easy to see that we only need to make the following changes to the ILP .
5-17:For each length L path (throughout the paper, we do not include cycles in the definition of path) p = ep1 , ep2 , .
5-18:.
5-19:.
5-20:, epL , add a constraint ep1 + ep2 + .
5-21:.
5-22:.
5-23:+ epL ≤ L − 1, which precludes path p from being in any feasible solution .
5-24:Unfortunately, in a market with only 1000 patients, the number of length 3 paths is in excess of 400 million, and so we cannot even construct this ILP without running out of memory .
5-25:Therefore, we use a tree search with an incremental formulation approach .
5-26:Specifically, we use CPLEX, though 298 we add constraints as cutting planes during the tree search process .
5-27:We begin with only a small subset of the constraints in the ILP .
5-28:Since this ILP is small, CPLEX can solve its LP relaxation .
5-29:We then check whether any of the missing constraints are violated by the fractional solution .
5-30:If so, we generate a set of these constraints, add them to the ILP, and repeat .
5-31:Even once all constraints are satisfied, there may be no integral solution matching the fractional upper bound, and even if there were, the LP solver might not find it .
5-32:In these cases, CPLEX branches on a variable (we used CPLEX"s default branching strategy), and generates one new search node corresponding to each of the children .
5-33:At each node of the search tree that is visited, this process of solving the LP and adding constraints is repeated .
5-34:Clearly, this approach yields an optimal solution once the tree search finishes .
5-35:We still need to explain the details of the constraint seeder (i.e., selecting which constraints to begin with) and the constraint generation (i.e., selecting which violated constraints to include) .
5-36:We describe these briefly in the next two subsections, respectively .
5-37:4.1 Constraint Seeder The main constraint seeder we developed forbids any path of length L − 1 that does not have an edge closing the cycle from its head to its tail .
5-38:While it is computationally expensive to find these constraints, their addition focuses the search away from paths that cannot be in the final solution .
5-39:We also tried seeding the LP with a random collection of constraints from the ILP .
5-40:4.2 Constraint Generation We experimented with several constraint generators .
5-41:In each, given a fractional solution, we construct the subgraph of edges with positive value .
5-42:This graph is much smaller than the original graph, so we can perform the following computations efficiently .
5-43:In our first constraint generator, we simply search for length L paths with value sum more than L − 1 .
5-44:For any such path, we restrict its sum to be at most L − 1 .
5-45:Note that if there is a cycle c with length |c| > L, it could contain as many as |c| violating paths .
5-46:In our second constraint generator, we only add one constraint for such cycles: the sum of edges in the cycle can be at most |c|(L − 1) L .
5-47:This generator made the algorithm slower, so we went in the other direction in developing our final generator .
5-48:It adds one constraint per violating path p, and furthermore, it adds a constraint for each path with the same interior vertices (not counting the endpoints) as p .
5-49:This improved the overall speed .
5-50:4.3 Experimental performance It turned out that even with these improvements, the edge formulation approach cannot clear a kidney exchange with 100 vertices in the time the cycle formulation (described later in Section 5) can clear one with 10,000 vertices .
5-51:In other words, column generation based approaches turned out to be drastically better than constraint generation based approaches .
5-52:Therefore, in the rest of the paper, we will focus on the cycle formulation and the column generation based approaches. .
6 SOLUTION APPROACHES BASED ON A CYCLE FORMULATION :
6-1:CYCLE FORMULATION In this section, we consider a formulation of the clearing problem as an ILP with one variable for each cycle .
6-2:This encoding is based on the following classical algorithm for solving the directed cycle cover problem when cycles have length 2 .
6-3:Given a market G = (V, E), construct a new graph on V with a weight wc edge for each cycle c of length 2 .
6-4:It is easy to see that matchings in this new graph correspond to cycle covers by length 2 cycles in the original market graph .
6-5:Hence, the market clearing problem with L = 2 can be solved in polynomial time by finding a maximum weight matching .
6-6:c_1 v 1 v 2 v 3 v 4 c_3c_2 Figure 4: Maximum weight matching encoding of the market in Figure 1 .
6-7:We can generalize this encoding for arbitrary L .
6-8:Let C(L) be the set of all cycles of G with length at most L .
6-9:Then the following ILP finds the maximum weight cycle cover by C(L) cycles: max c∈C(L) wcc subject to c:vi∈c c ≤ 1 ∀vi ∈ V with c ∈ {0, 1} ∀c ∈ C(L) 5.1 Edge vs Cycle Formulation In this section, we consider the merits of the edge formulation and cycle formulation .
6-10:The edge formulation can be solved in polynomial time when there are no constraints on the cycle size .
6-11:The cycle formulation can be solved in polynomial time when the cycle size is at most 2 .
6-12:We now consider the case of short cycles of length at most L, where L ≥ 3 .
6-13:Our tree search algorithms use the LP relaxation of these formulations to provide upper bounds on the optimal solution .
6-14:These bounds help prune subtrees and guide the search in the usual ways .
6-15:Theorem 2 .
6-16:The LP relaxation of the cycle formulation weakly dominates the LP relaxation of the edge formulation .
6-17:Proof .
6-18:Consider an optimal solution to the LP relaxation of the cycle formulation .
6-19:We show how to construct an equivalent solution in the edge formulation .
6-20:For each edge in the graph, set its value as the sum of values of all the cycles of which it is a member .
6-21:Also, define the value of a vertex in the same manner .
6-22:Because of the cycle constraints, the conservation and capacity constraints of the edge encoding are clearly satisfied .
6-23:It remains to show that none of the path constraints are violated .
6-24:Let p be any length L path in the graph .
6-25:Since p has L−1 interior vertices (not counting the endpoints), the value sum of these interior vertices is at most L−1 .
6-26:Now, for any cycle c of length at most L, the number of edges it has in p, which we denote by ec(p), is at most the number of interior vertices it has in p, which we denote by vc(p) .
6-27:Hence, È e∈p e = È c∈C(L) c∗ec(p) ≤ È c∈C(L) c∗vc(p) = È v∈p v = L−1 .
6-28:299 The converse of this theorem is not true .
6-29:Consider a graph which is simply a cycle with n edges .
6-30:Clearly, the LP relaxation of the cycle formulation has optimal value 0, since there are no cycles of size at most L .
6-31:However, the edge formulation has a solution of size n 2, with each edge having value 1 2 .
6-32:Hence, the cycle formulation is tighter than the edge formulation .
6-33:Additionally, for a graph with m edges, the edge formulation requires O(m3 ) constraints, while the cycle formulation requires only O(m2 ) .
6-34:5.2 Column Generation for the LP Table 2 shows how the number of cycles of length at most 3 grows with the size of the market .
6-35:With one variable per cycle in the cycle formulation, CPLEX cannot even clear markets with 1,000 patients without running out of memory (see Figure 6) .
6-36:To address this problem, we used an incremental formulation approach .
6-37:The first step in LP guided tree search is to solve the LP relaxation .
6-38:Since the cycle formulation does not fit in memory, this LP stage would fail immediately without an incremental formulation approach .
6-39:However, motivated by the observation that an exchange solution can include only a tiny fraction of the cycles, we explored the approach of using column (i.e., cycle) generation .
6-40:The idea of column generation is to start with a restricted LP containing only a small number of columns (variables, i.e., cycles), and then to repeatedly add columns until an optimal solution to this partially formulated LP is an optimal solution to the original (aka master) LP .
6-41:We explain this further by way of an example .
6-42:Consider the market in Figure 1 with L = 2 .
6-43:Figure 5 gives the corresponding master LP, P, and its dual, D .
6-44:Primal P max 2c1 +2c2 +2c3 s.t .
6-45:c1 ≤ 1 (v1) c1 +c2 ≤ 1 (v2) +c2 +c3 ≤ 1 (v3) +c3 ≤ 1 (v4) with c1, c2, c3 ≥ 0 Dual D min v1 +v2 +v3 +v4 s.t v1 +v2 ≥ 2 (c1) +v2 +v3 ≥ 2 (c2) +v3 +v4 ≥ 2 (c3) with v1, v2, v3, v4 ≥ 0 Figure 5: Cycle formulation .
6-46:Let P be the restriction of P containing columns c1 and c3 only .
6-47:Let D be the dual of P , that is, D is just D without the constraint c2 .
6-48:Because P and D are small, we can solve them to obtain OPT(P ) = OPT(D ) = 4, with cOP T (P ) = c1 = c3 = 1 and vOP T (D ) = v1 = v2 = v3 = v4 = 1 .
6-49:While cOP T (P ) must be a feasible solution of P, it turns out (fortunately) that vOP T (D ) is feasible for D, so that OPT(D ) ≥ OPT(D) .
6-50:We can verify this by checking that vOP T (D ) satisfies the constraints of D not already in Di.e .
6-51:constraint c2 .
6-52:It follows that OPT(P ) = OPT(D ) ≥ OPT(D) = OPT(P), and so vOP T (P ) is provably an optimal solution for P, even though P is contains a only strict subset of the columns of P .
6-53:Of course, it may turn out (unfortunately) that vOP T (D ) is not feasible for D .
6-54:This can happen above if vOP T (D ) = v1 = 2, v2 = 0, v3 = 0, v4 = 2 .
6-55:Although we can still see that OPT(D ) = OPT(D), in general we cannot prove this because D and P are too large to solve .
6-56:Instead, because constraint c2 is violated, we add column c2 to P , update D , and repeat .
6-57:The problem of finding a violated constraint is called the pricing problem .
6-58:Here, the price of a column (cycle in our setting) is the difference between its weight, and the dual value sum of the cycle"s vertices .
6-59:If any column of P has a positive price, its corresponding constraint is violated and we have not yet proven optimality .
6-60:In this case, we must continue generating columns to add to P .
6-61:5.2.1 Pricing Problem For smaller instances, we can maintain an explicit collection of all feasible cycles .
6-62:This makes the pricing problem easy and efficient to solve: we simply traverse the collection of cycles, and look for cycles with positive price .
6-63:We can even find cycles with the most positive price, which are the ones most likely to improve the objective value of restricted LP [1] .
6-64:This approach does not scale however .
6-65:A market with 5000 patients can have as many as 400 million cycles of length at most 3 (see Table 2) .
6-66:This is too many cycles to keep in memory .
6-67:Hence, for larger instances, we have to generate feasible cycles while looking for one with a positive price .
6-68:We do this using a depth first search algorithm on the market graph (see Figure 1) .
6-69:In order to make this search faster, we explore vertices in non decreasing value order, as these vertices are more likely to belong to cycles with positive weight .
6-70:We also use several pruning rules to determine if the current search path can lead to a positive weight cycle .
6-71:For example, at a given vertex in the search, we can prune based on the fact that every vertex we visit from this point onwards will have value at least as great the current vertex .
6-72:Even with these pruning rules, column generation is a bottleneck .
6-73:Hence, we also implemented the following optimizations .
6-74:Whenever the search exhaustively proves that a vertex belongs to no positive price cycle, we mark the vertex and do not use it as the root of a depth first search until its dual value decreases .
6-75:In this way, we avoid unnecessarily repeating our computational efforts from a previous column generation iteration .
6-76:Finally, it can sometimes be beneficial for column generation to include several positive price columns in one iteration, since it may be faster to generate a second column, once the first one is found .
6-77:However, we avoid this for the following reason .
6-78:If we attempt to find more positive price columns than there are to be found, or if the columns are far apart in the search space, we end up having to generate and check a large part of the collection of feasible cycles .
6-79:In our experiments, we have seen this occur in markets with hundreds of millions of cycles, resulting in prohibitively expensive computation costs .
6-80:5.2.2 Column Seeding Even if there is only a small gap to the master LP relaxation, column generation requires many iterations to improve the objective value of the restricted LP .
6-81:Each of these 300 iterations is expensive, as we must solve the pricing problem, and re solve the restricted LP .
6-82:Hence, although we could begin with no columns in the restricted LP, it is much faster to seed the LP with enough columns that the optimal objective value is not too far from the master LP .
6-83:Of course, we cannot include so many columns that we run out of memory .
6-84:We experimented with several column seeders .
6-85:In one class of seeder, we use a heuristic to find an exchange, and then add the cycles of that exchange to the initial restricted LP .
6-86:We implemented two heuristics .
6-87:The first is a greedy algorithm: for each vertex in a random order, if it is uncovered, we attempt to include a cycle containing it and other uncovered vertices .
6-88:The other heuristic uses specialized maximum weight matching code [16] to find an optimal cover by length 2 cycles .
6-89:These heuristics perform extremely well, especially taking into account the fact that they only add a small number of columns .
6-90:For example, Table 1 shows that an optimal cover by length 2 cycles has almost as much weight as the exchange with unrestricted cycle size .
6-91:However, we have enough memory to include hundreds of thousands of additional columns and thereby get closer still to the upper bound .
6-92:Our best column seeder constructs a random collection of feasible cycles .
6-93:Since a market with 5000 patients can have as many as 400 million feasible cycles, it takes too long to generate and traverse all feasible cycles, and so we do not include a uniformly random collection .
6-94:Instead, we perform a random walk on the market graph (see, for example, Figure 1), in which, after each step of the walk, we test whether there is an edge back onto our path that forms a feasible cycle .
6-95:If we find a cycle, it is included in the restricted LP, and we start a new walk from a random vertex .
6-96:In our experiments (see Section 6), we use this algorithm to seed the LP with 400,000 cycles .
6-97:This last approach outperforms the heuristic seeders described above .
6-98:However, in our algorithm, we use a combination that takes the union of all columns from all three seeders .
6-99:In Figure 6, we compare the performance of the combination seeder against the combination without the random collection seeder .
6-100:We do not plot the performance of the algorithm without any seeder at all, because it can take hours to clear markets we can otherwise clear in a few minutes .
6-101:5.2.3 Proving Optimality Recall that our aim is to find an optimal solution to the master LP relaxation .
6-102:Using column generation, we can prove that a restricted primal solution is optimal once all columns have non positive prices .
6-103:Unfortunately though, our clearing problem has the so called tailing off effect [1, Section 6.3], in which, even though the restricted primal is optimal in hindsight, a large number of additional iterations are required in order to prove optimality (i.e., eliminate all positive price columns) .
6-104:There is no good general solution to the tailing off effect .
6-105:However, to mitigate this effect, we take advantage of the following problem specific observation .
6-106:Recall from Section 1.1 that, almost always, a maximum weight exchange with cycles of length at most 3 has the same weight as an unrestricted maximum weight exchange .
6-107:(This does not mean that the solver for the unrestricted case will find a solution with short cycles, however.) Furthermore, the unrestricted clearing problem can be solved in polynomial time (recall Section 4) .
6-108:Hence, we can efficiently compute an upper bound on the master LP relaxation, and, whenever the restricted primal achieves this upper bound, we have proven optimality without necessarily having to eliminate all positive price columns! In order for this to improve the running time of the overall algorithm, we need to be able to clear the unrestricted market in less time than it takes column generation to eliminate all the positive price cycles .
6-109:Even though the first problem is polynomial time solvable, this is not trivial for large instances .
6-110:For example, for a market with 10,000 patients and 25 million edges, specialized maximum weight matching code [16] was too slow, and CPLEX ran out of memory on the edge formulation encoding from Section 4 .
6-111:To make this idea work then, we used column generation to solve the edge formulation .
6-112:This involves starting with a small random subset of the edges, and then adding positive price edges one by one until none remain .
6-113:We conduct this secondary column generation not in the original market graph G, but in the perfect matching bipartite graph of Figure 3 .
6-114:We do this so that we only need to solve the LP, not the ILP, since the integrality gap in the perfect matching bipartite graph is 1 i.e .
6-115:there always exists an integral solution that achieves the fractional upper bound .
6-116:The resulting speedup to the overall algorithm is dramatic, as can be seen in Figure 6 .
6-117:5.2.4 Column Management If the optimal value of the initial restricted LP P is far from the the master LP P, then a large number of columns are generated before the gap is closed .
6-118:This leads to memory problems on markets with as few as 4,000 patients .
6-119:Also, even before memory becomes an issue, the column generation iterations become slow because of the additional overhead of solving a larger LP .
6-120:To address these issues, we implemented a column management scheme to limit the size of the restricted LP .
6-121:Whenever we add columns to the LP, we check to see if it contains more than a threshold number of columns .
6-122:If this is the case, we selectively remove columns until it is again below the threshold2 .
6-123:As we discussed earlier, only a tiny fraction of all the cycles will end up in the final solution .
6-124:It is unlikely that we delete such a cycle, and even if we do, it can always be generated again .
6-125:Of course, we must not be too aggressive with the threshold, because doing so may offset the per iteration performance gains by significantly increasing the number of iterations required to get a suitable column set in the LP at the same time .
6-126:There are some columns we never delete, for example those we have branched on (see Section 5.3.2), or those with a non zero LP value .
6-127:Amongst the rest, we delete those with the lowest price, since those correspond to the dual constraints that are most satisfied .
6-128:This column management scheme works well and has enabled us to clear markets with 10,000 patients, as seen in Figure 6 .
6-129:5.3 Branch and Price Search for the ILP Given a large market clearing problem, we can successfully solve its LP relaxation to optimality by using the column generation enhancements described above .
6-130:However, the solutions we find are usually fractional .
6-131:Thus the next 2 Based on memory size, we set the threshold at 400,000 .
6-132:301 step involves performing a branch and price tree search [1] to find an optimal integral solution .
6-133:Briefly, this is the idea of branch and price .
6-134:Whenever we set a fractional variable to 0 or 1 (branch), both the master LP, and the restriction we are working with, are changed (constrained) .
6-135:By default then, we need to perform column generation (go through the effort of pricing) at each node of the search tree to prove that the constrained restriction is optimal for constrained master LP .
6-136:(However, as discussed in Section 5.2.3, we compute the integral upper bound for the root node based on relaxing the cycle length constraint completely, and whenever any node"s LP in the tree achieves that value, we do not need to continue pricing columns at that node.) For the clearing problem with cycles of length at most 3, we have found that there is rarely a gap between the optimal integral and fractional solutions .
6-137:This means we can largely avoid the expensive per node pricing step: whenever the constrained restricted LP has the same optimal value as its parent in the tree search, we can prove LP optimality, as in Section 5.2.3, without having to include any additional columns in the restricted LP .
6-138:Although CPLEX can solve ILPs, it does not support branch and price (for example, because there can be problemspecific complications involving the interaction between the branching rule and the pricing problem) .
6-139:Hence, we implemented our own branch and price algorithm, which explores the search tree in depth first order .
6-140:We also experimented with the A* node selection order [7, 2] .
6-141:However, this search strategy requires significantly more memory, which we found was better employed in making the column generation phase faster (see Section 5.2.2) .
6-142:The remaining major components of the algorithm are described in the next two subsections .
6-143:5.3.1 Primal Heuristics Before branching on a fractional variable, we use primal heuristics to construct a feasible integral solution .
6-144:These solutions are lower bounds on the final optimal integral solutions .
6-145:Hence, whenever a restricted fractional solution is no better than the best integral solution found so far, we prune the current subtree .
6-146:A primal heuristic is effective if it is efficient and constructs tight lower bounds .
6-147:We experimented with two primal heuristics .
6-148:The first is a simple rounding algorithm [8]: include all cycles with fractional value at least 0.5, and then, ensuring feasibility, greedily add the remaining cycles .
6-149:Whilst this heuristic is efficient, we found that the lower bounds it constructs rarely enable much pruning .
6-150:We also tried using CPLEX as a primal heuristic .
6-151:At any given node of the search tree, we can convert the restricted LP relaxation back to an ILP by reintroducing the integrality constraints .
6-152:CPLEX has several built in primal heuristics, which we can apply to this ILP .
6-153:Moreover, we can use CPLEX"s own tree search to find an optimal integral solution .
6-154:In general, this tree search is much faster than our own .
6-155:If CPLEX finds an integral solution that matches the fractional upper bound at the root node, we are done .
6-156:Otherwise, no such integral solution exists, or we don"t yet have the right combination of cycles in the restricted LP .
6-157:For kidney exchange markets, it is usually the second reason that applies (see Sections 5.2.2 and 5.2.4) .
6-158:Hence, at some point in the tree search, once more columns have been generated as a result of branching, the CPLEX heuristic will find an optimal integral solution .
6-159:Although CPLEX tree search is faster than our own, it is not so fast that we can apply it to every node in our search tree .
6-160:Hence, we make the following optimizations .
6-161:Firstly, we add a constraint that requires the objective value of the ILP to be as large as the fractional target .
6-162:If this is not the case, we want to abort and proceed to generate more columns with our branch and price search .
6-163:Secondly, we limit the number of nodes in CPLEX"s search tree .
6-164:This is because we have observed that no integral solution exists, CPLEX can take a very long time to prove that .
6-165:Finally, we only apply the CPLEX heuristic at a node if it has a sufficiently different set of cycles from its parent .
6-166:Using CPLEX as a primal heuristic has a large impact because it makes the search tree smaller, so all the computationally expensive pricing work is avoided at nodes that are not generated in this smaller tree .
6-167:5.3.2 Cycle Brancher We experimented with two branching strategies, both of which select one variable per node .
6-168:The first strategy, branching by certainty, randomly selects a variable from those whose LP value is closest to 1 .
6-169:The second strategy, branching by uncertainty, randomly selects a variable whose LP value is closest to 0.5 .
6-170:In either case, two children of the node are generated corresponding to two subtrees, one in which the variable is set to 0, the other in which it is set to 1 .
6-171:Our depth first search always chooses to explore first the subtree in which the value of the variable is closest to its fractional value .
6-172:For our clearing problem with cycles of length at most 3, we found branching by uncertainty to be superior, rarely requiring any backtracking. .
7 EXPERIMENTAL RESULTS :
7-1:All our experiments were performed in Linux (Red Hat 9.0), using a Dell PC with a 3GHz Intel Pentium 4 processor, and 1GB of RAM .
7-2:Wherever we used CPLEX (e.g., in solving the LP and as a primal heuristic, as discussed in the previous sections), we used CPLEX 10.010 .
7-3:Figure 6 shows the runtime performance of four clearing algorithms .
7-4:For each market size listed, we randomly generated 10 markets, and attempted to clear them using each of the algorithms .
7-5:The first algorithm is CPLEX on the full cycle formulation .
7-6:This algorithm fails to clear any markets with 1000 patients or more .
7-7:Also, its running time on markets smaller than this is significantly worse than the other algorithms .
7-8:The other algorithms are variations of the incremental column generation approach described in Section 5 .
7-9:We begin with the following settings (all optimizations are switched on): Category Setting Column Seeder Combination of greedy exchange and maximum weight matching heuristics, and random walk seeder (400,000 cycles) .
7-10:Column Generation One column at a time .
7-11:Column Management On, with 400,000 column limit .
7-12:Optimality Prover On .
7-13:Primal Heuristic Rounding & CPLEX tree search .
7-14:Branching Rule Uncertainty .
7-15:302 The combination of these optimizations allows us to easily clear markets with over 10,000 patients .
7-16:In each of the next two algorithms, we turn one of these optimizations off to highlight its effectiveness .
7-17:First, we restrict the seeder so that it only begins with 10,000 cycles .
7-18:This setting is faster for smaller instances, since the LP relaxations are smaller, and faster to solve .
7-19:However, at 5000 vertices, this effect starts to be offset by the additional column generation that must be performed .
7-20:For larger instance, this restricted seeder is clearly worse .
7-21:Finally, we restore the seeder to its optimized setting, but this time, remove the optimality prover described in Section 5.2.3 .
7-22:As in many column generation problems, the tailing off effect is substantial .
7-23:By taking advantage of the properties of our problem, we manage to clear a market with 10,000 patients in about the same time it would otherwise have taken to clear a 6000 patient market. .
8 FIELDING THE TECHNOLOGY :
8-1:Our algorithm and implementation replaced CPLEX as the clearing algorithm of the Alliance for Paired Donation, one of the leading kidney exchanges, in December 2006 .
8-2:We conduct a match run every two weeks, and the first transplants based on our solutions have already been conducted .
8-3:While there are (for political inter personal reasons) at least four kidney exchanges in the US currently, everyone understands that a unified unfragmented national exchange would save more lives .
8-4:We are in discussions with additional kidney exchanges that are interested in adopting our technology .
8-5:This way our technology (and the processes around it) will hopefully serve as a substrate that will eventually help in unifying the exchanges .
8-6:At least computational scalability is no longer an obstacle. .
9 ABSTRACT :
9-1:In this work we have developed the most scalable exact algorithms for barter exchanges to date, with special focus on the upcoming national kidney exchange market in which patients with kidney disease will be matched with compatible donors by swapping their own willing but incompatible donors
9-2:With over 70,000 patients already waiting for a cadaver kidney in the US, this market is seen as the only ethical way to significantly reduce the 4,000 deaths per year attributed to kidney disease
9-3:Our work presents the first algorithm capable of clearing these markets on a nationwide scale
9-4:It optimally solves the kidney exchange clearing problem with 10,000 donordonee pairs
9-5:Thus there is no need to resort to approximate solutions
9-6:The best prior technology (vanilla CPLEX) cannot handle instances beyond about 900 donor donee pairs because it runs out of memory
9-7:The key to our improvement is incremental problem formulation
9-8:We adapted two paradigms for the task: constraint generation and column generation
9-9:For each, we developed a host of techniques that substantially improve both runtime and memory usage
9-10:Some of the techniques use domain specific observations while others are domain independent
9-11:We conclude that column generation scales dramatically better than constraint generation
9-12:For column generation in the LP, our enhancements include pricing techniques, column seeding techniques, techniques for proving optimality without having to bring in all positive price columns (and using another column generation process in a different formulation to do so), and column removal techniques
9-13:For the branch andprice search in the integer program that surrounds the LP, our enhancements include primal heuristics and we also compared branching strategies
9-14:Undoubtedly, further parameter tuning and perhaps additional speed improvement techniques could be used to make the algorithm even faster
9-15:Our algorithm also supports several generalizations, as desired by real world kidney exchanges
9-16:These include multiple alternative donors per patient, weighted edges in the market graph (to encode differences in expected life years added based on degrees of compatibility, patient age and weight, etc., as well as the probability of last minute incompatibility), angel triggered chains (chains of transplants triggered by altruistic donors who do not have patients associated with them, each chain ending with a left over kidney), and additional issues (such as different scores for saving different altruistic donors or left over kidneys for future match runs based on blood type, tissue type, and likelihood that the organ would not disappear from the market by the donor getting second thoughts)
9-17:Because we use an ILP methodology, we can also support a variety of side constraints, which often play an important role in markets in practice [19]
9-18:We can also support forcing part of the allocation, for example, This acutely sick teenager has to get a kidney if possible
9-19:Our work has treated the kidney exchange as a batch problem with full information (at least in the short run, kidney exchanges will most likely continue to run in batch mode every so often)
9-20:Two important directions for future work are to explicitly address both online and limited information aspects of the problem
9-21:The online aspect is that donees and donors will be arriving into the system over time, and it may be best to not execute the myopically optimal exchange now, but rather save part of the current market for later matches
9-22:In fact, some work has been done on this in certain restricted settings [22, 24]
9-23:The limited information aspect is that even in batch mode, the graph provided as input is not completely correct: a number of donor donee pairs believed to be compatible turn out to be incompatible when more expensive last minute tests are performed
9-24:Therefore, it would be desirable to perform an optimization with this in mind, such as outputting a low degree robust subgraph to be tested before the final match is produced, or to output a contingency plan in case of failure
9-25:We are currently exploring a number of questions along these lines but there is certainly much more to be done
9-26:Acknowledgments We thank economists Al Roth and Utku Unver, as well as kidney transplant surgeon Michael Rees, for alerting us to the fact that prior technology was inadequate for the clearing problem on a national scale, supplying initial data sets, and discussions on details of the kidney exchange process
9-27:We also thank Don Sheehy for bringing to our attention the idea of shoe exchange
9-28:This work was supported in part by the National Science Foundation under grants IIS 0427858 and CCF 0514922.
10 ABSTRACT :
10-1:C
10-2:Barnhart, E
10-3:L
10-4:Johnson, G
10-5:L
10-6:Nemhauser,
picture:
