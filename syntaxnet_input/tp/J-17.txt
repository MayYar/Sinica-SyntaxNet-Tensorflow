Truthful Mechanism Design for Multi-Dimensional 
content:
1 ABSTRACT :
1-1:We consider the problem of makespan minimization on m unrelated machines in the context of algorithmic mechanism design, where the machines are the strategic players .
1-2:This is a multidimensional scheduling domain, and the only known positive results for makespan minimization in such a domain are O(m) approximation truthful mechanisms [22, 20] .
1-3:We study a well motivated special case of this problem, where the processing time of a job on each machine may either be low or high, and the low and high values are public and job dependent .
1-4:This preserves the multidimensionality of the domain, and generalizes the restricted machines (i.e., {pj, ∞}) setting in scheduling .
1-5:We give a general technique to convert any c approximation algorithm to a 3capproximation truthful in expectation mechanism .
1-6:This is one of the few known results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms in a black box fashion .
1-7:When the low and high values are the same for all jobs, we devise a deterministic 2 approximation truthful mechanism .
1-8:These are the first truthful mechanisms with non trivial performance guarantees for a multidimensional scheduling domain .
1-9:Our constructions are novel in two respects .
1-10:First, we do not utilize or rely on explicit price definitions to prove truthfulness; instead we design algorithms that satisfy cycle monotonicity .
1-11:Cycle monotonicity [23] is a necessary and sufficient condition for truthfulness, is a generalization of value monotonicity for multidimensional domains .
1-12:However, whereas value monotonicity has been used extensively and successfully to design truthful mechanisms in singledimensional domains, ours is the first work that leverages cycle monotonicity in the multidimensional setting .
1-13:Second, our randomized mechanisms are obtained by first constructing a fractional truthful mechanism for a fractional relaxation of the problem, and then converting it into a truthfulin expectation mechanism .
1-14:This builds upon a technique of [16], and shows the usefulness of fractional mechanisms in truthful mechanism design .
1-15:F.2 [Analysis of Algorithms and Problem .
2 INTRODUCTION :
2-1:Mechanism design studies algorithmic constructions under the presence of strategic players who hold the inputs to the algorithm .
2-2:Algorithmic mechanism design has focused mainly on settings were the social planner or designer wishes to maximize the social welfare (or equivalently, minimize social cost), or on auction settings where revenuemaximization is the main goal .
2-3:Alternative optimization goals, such as those that incorporate fairness criteria (which have been investigated algorithmically and in social choice theory), have received very little or no attention .
2-4:In this paper, we consider such an alternative goal in the context of machine scheduling, namely, makespan minimization .
2-5:There are n jobs or tasks that need to be assigned to m machines, where each job has to be assigned to exactly one machine .
2-6:Assigning a job j to a machine i incurs a load (cost) of pij ≥ 0 on machine i, and the load of a machine is the sum of the loads incurred due to the jobs assigned to it; the goal is to schedule the jobs so as to minimize the maximum load of a machine, which is termed the makespan of the schedule .
2-7:Makespan minimization is a common objective in scheduling environments, and has been well studied algorithmically in both the Computer Science and Operations Research communities (see, e.g., the survey [12]) .
2-8:Following the work of Nisan and Ronen [22], we consider each machine to be a strategic player or agent who privately knows its own processing time for each job, and may misrepresent these values in order to decrease its load (which is its incurred cost) .
2-9:Hence, we approach the problem via mechanism design: the social designer, who holds the set of jobs to be assigned, needs to specify, in addition to a schedule, suitable payments to the players in order to incentivize them to reveal their true processing times .
2-10:Such a mechanism is called a truthful mechanism .
2-11:The makespan minimization objective is quite different from the classic goal of social welfare maximization, where one wants to maximize the total welfare (or minimize the total cost) of all players .
2-12:Instead, it 252 corresponds to maximizing the minimum welfare and the notion of max min fairness, and appears to be a much harder problem from the viewpoint of mechanism design .
2-13:In particular, the celebrated VCG [26, 9, 10] family of mechanisms does not apply here, and we need to devise new techniques .
2-14:The possibility of constructing a truthful mechanism for makespan minimization is strongly related to assumptions on the players" processing times, in particular, the dimensionality of the domain .
2-15:Nisan and Ronen considered the setting of unrelated machines where the pij values may be arbitrary .
2-16:This is a multidimensional domain, since a player"s private value is its entire vector of processing times (pij)j .
2-17:Very few positive results are known for multidimensional domains in general, and the only positive results known for multidimensional scheduling are O(m) approximation truthful mechanisms [22, 20] .
2-18:We emphasize that regardless of computational considerations, even the existence of a truthful mechanism with a significantly better (than m) approximation ratio is not known for any such scheduling domain .
2-19:On the negative side, [22] showed that no truthful deterministic mechanism can achieve approximation ratio better than 2, and strengthened this lower bound to m for two specific classes of deterministic mechanisms .
2-20:Recently, [20] extended this lower bound to randomized mechanisms, and [8] improved the deterministic lower bound .
2-21:In stark contrast with the above state of affairs, much stronger (and many more) positive results are known for a special case of the unrelated machines problem, namely, the setting of related machines .
2-22:Here, we have pij = pj si for every i, j, where pj is public knowledge, and the speed si is the only private parameter of machine i .
2-23:This assumption makes the domain of players" types single dimensional .
2-24:Truthfulness in such domains is equivalent to a convenient value monotonicity condition [21, 3], which appears to make it significantly easier to design truthful mechanisms in such domains .
2-25:Archer and Tardos [3] first considered the related machines setting and gave a randomized 3 approximation truthful in expectation mechanism .
2-26:The gap between the single dimensional and multidimensional domains is perhaps best exemplified by the fact that [3] showed that there exists a truthful mechanism that always outputs an optimal schedule .
2-27:(Recall that in the multidimensional unrelated machines setting, it is impossible to obtain a truthful mechanism with approximation ratio better than 2.) Various follow up results [2, 4, 1, 13] have strengthened the notion of truthfulness and or improved the approximation ratio .
2-28:Such difficulties in moving from the single dimensional to the multidimensional setting also arise in other mechanism design settings (e.g., combinatorial auctions) .
2-29:Thus, in addition to the specific importance of scheduling in strategic environments, ideas from multidimensional scheduling may also have a bearing in the more general context of truthful mechanism design for multidimensional domains .
2-30:In this paper, we consider the makespan minimization problem for a special case of unrelated machines, where the processing time of a job is either low or high on each machine .
2-31:More precisely, in our setting, pij ∈ {Lj, Hj} for every i, j, where the Lj, Hj values are publicly known (Lj ≡low, Hj ≡high) .
2-32:We call this model the jobdependent two values case .
2-33:This model generalizes the classic restricted machines setting, where pij ∈ {Lj, ∞} which has been well studied algorithmically .
2-34:A special case of our model is when Lj = L and Hj = H for all jobs j, which we denote simply as the two values scheduling model .
2-35:Both of our domains are multidimensional, since the machines are unrelated: one job may be low on one machine and high on the other, while another job may follow the opposite pattern .
2-36:Thus, the private information of each machine is a vector specifying which jobs are low and high on it .
2-37:Thus, they retain the core property underlying the hardness of truthful mechanism design for unrelated machines, and by studying these special settings we hope to gain some insights that will be useful for tackling the general problem .
2-38:Our Results and Techniques We present various positive results for our multidimensional scheduling domains .
2-39:Our first result is a general method to convert any capproximation algorithm for the job dependent two values setting into a 3c approximation truthful in expectation mechanism .
2-40:This is one of the very few known results that use an approximation algorithm in a black box fashion to obtain a truthful mechanism for a multidimensional problem .
2-41:Our result implies that there exists a 3 approximation truthfulin expectation mechanism for the Lj Hj setting .
2-42:Interestingly, the proof of truthfulness is not based on supplying explicit prices, and our construction does not necessarily yield efficiently computable prices (but the allocation rule is efficiently computable) .
2-43:Our second result applies to the twovalues setting (Lj = L, Hj = H), for which we improve both the approximation ratio and strengthen the notion of truthfulness .
2-44:We obtain a deterministic 2 approximation truthful mechanism (along with prices) for this problem .
2-45:These are the first truthful mechanisms with non trivial performance guarantees for a multidimensional scheduling domain .
2-46:Complementing this, we observe that even this seemingly simple setting does not admit truthful mechanisms that return an optimal schedule (unlike in the case of related machines) .
2-47:By exploiting the multidimensionality of the domain, we prove that no truthful deterministic mechanism can obtain an approximation ratio better than 1.14 to the makespan (irrespective of computational considerations) .
2-48:The main technique, and one of the novelties, underlying our constructions and proofs, is that we do not rely on explicit price specifications in order to prove the truthfulness of our mechanisms .
2-49:Instead we exploit certain algorithmic monotonicity conditions that characterize truthfulness to first design an implementable algorithm, i.e., an algorithm for which prices ensuring truthfulness exist, and then find these prices (by further delving into the proof of implementability) .
2-50:This kind of analysis has been the method of choice in the design of truthful mechanisms for singledimensional domains, where value monotonicity yields a convenient characterization enabling one to concentrate on the algorithmic side of the problem (see, e.g., [3, 7, 4, 1, 13]) .
2-51:But for multidimensional domains, almost all positive results have relied on explicit price specifications in order to prove truthfulness (an exception is the work on unknown single minded players in combinatorial auctions [17, 7]), a fact that yet again shows the gap in our understanding of multidimensional vs .
2-52:single dimensional domains .
2-53:Our work is the first to leverage monotonicity conditions for truthful mechanism design in arbitrary domains .
2-54:The monotonicity condition we use, which is sometimes called cycle monotonicity, was first proposed by Rochet [23] (see also [11]) .
2-55:It is a generalization of value monotonicity and completely characterizes truthfulness in every domain .
2-56:Our methods and analyses demonstrate the potential benefits 253 of this characterization, and show that cycle monotonicity can be effectively utilized to devise truthful mechanisms for multidimensional domains .
2-57:Consider, for example, our first result showing that any c approximation algorithm can be exported to a 3c approximation truthful in expectation mechanism .
2-58:At the level of generality of an arbitrary approximation algorithm, it seems unlikely that one would be able to come up with prices to prove truthfulness of the constructed mechanism .
2-59:But, cycle monotonicity does allow us to prove such a statement .
2-60:In fact, some such condition based only on the underlying algorithm (and not on the prices) seems necessary to prove such a general statement .
2-61:The method for converting approximation algorithms into truthful mechanisms involves another novel idea .
2-62:Our randomized mechanism is obtained by first constructing a truthful mechanism that returns a fractional schedule .
2-63:Moving to a fractional domain allows us to plug in truthfulness into the approximation algorithm in a rather simple fashion, while losing a factor of 2 in the approximation ratio .
2-64:We then use a suitable randomized rounding procedure to convert the fractional assignment into a random integral assignment .
2-65:For this, we use a recent rounding procedure of Kumar et al .
2-66:[14] that is tailored for unrelated machine scheduling .
2-67:This preserves truthfulness, but we lose another additive factor equal to the approximation ratio .
2-68:Our construction uses and extends some observations of Lavi and Swamy [16], and further demonstrates the benefits of fractional mechanisms in truthful mechanism design .
2-69:Related Work Nisan and Ronen [22] first considered the makespan minimization problem for unrelated machines .
2-70:They gave an m approximation positive result and proved various lower bounds .
2-71:Recently, Mu"alem and Schapira [20] proved a lower bound of 2 on the approximation ratio achievable by truthful in expectation mechanisms, and Christodoulou, Koutsoupias, and Vidali [8] proved a (1 + √ 2) lower bound for deterministic truthful mechanisms.Archer and Tardos [3] first considered the related machines problem and gave a 3 approximation truthful in expectation mechanism .
2-72:This been improved in [2, 4, 1, 13] to: a 2 approximation randomized mechanism [2]; an FPTAS for any fixed number of machines given by Andelman, Azar and Sorani [1], and a 3 approximation deterministic mechanism by Kov´acs [13] .
2-73:The algorithmic problem (i.e., without requiring truthfulness) of makespan minimization on unrelated machines is well understood and various 2 approximation algorithms are known .
2-74:Lenstra, Shmoys and Tardos [18] gave the first such algorithm .
2-75:Shmoys and Tardos [25] later gave a 2approximation algorithm for the generalized assignment problem, a generalization where there is a cost cij for assigning a job j to a machine i, and the goal is to minimize the cost subject to a bound on the makespan .
2-76:Recently, Kumar, Marathe, Parthasarathy, and Srinivasan [14] gave a randomized rounding algorithm that yields the same bounds .
2-77:We use their procedure in our randomized mechanism .
2-78:The characterization of truthfulness for arbitrary domains in terms of cycle monotonicity seems to have been first observed by Rochet [23] (see also Gui et al .
2-79:[11]) .
2-80:This generalizes the value monotonicity condition for single dimensional domains which was given by Myerson [21] and rediscovered by [3] .
2-81:As mentioned earlier, this condition has been exploited numerous times to obtain truthful mechanisms for single dimensional domains [3, 7, 4, 1, 13] .
2-82:For convex domains (i.e., each players" set of private values is convex), it is known that cycle monotonicity is implied by a simpler condition, called weak monotonicity [15, 6, 24] .
2-83:But even this simpler condition has not found much application in truthful mechanism design for multidimensional problems .
2-84:Objectives other than social welfare maximization and revenue maximization have received very little attention in mechanism design .
2-85:In the context of combinatorial auctions, the problems of maximizing the minimum value received by a player, and computing an envy minimizing allocation have been studied briefly .
2-86:Lavi, Mu"alem, and Nisan [15] showed that the former objective cannot be implemented truthfully; Bezakova and Dani [5] gave a 0.5 approximation mechanism for two players with additive valuations .
2-87:Lipton et al .
2-88:[19] showed that the latter objective cannot be implemented truthfully .
2-89:These lower bounds were strengthened in [20]. .
3 PRELIMINARIES :
3-1:2.1 The scheduling domain In our scheduling problem, we are given n jobs and m machines, and each job must be assigned to exactly one machine .
3-2:In the unrelated machines setting, each machine i is characterized by a vector of processing times (pij)j, where pij ∈ R≥0 ∪ {∞} denotes i"s processing time for job j with the value ∞ specifying that i cannot process j .
3-3:We consider two special cases of this problem: {Lj, Hj} for every i, j, with Lj ≤ Hj, and the values Lj, Hj are known .
3-4:This generalizes the classic scheduling model of restricted machines, where Hj = ∞ .
3-5:where Lj = L and Hj = H for all jobs j, i.e., pij ∈ {L, H} for every i, j .
3-6:We say that a job j is low on machine i if pij = Lj, and high if pij = Hj .
3-7:We will use the terms schedule and assignment interchangeably .
3-8:We represent a deterministic schedule by a vector x = (xij)i,j, where xij is 1 if job j is assigned to machine i, thus we have xij ∈ {0, 1} for every i, j, P i xij = 1 for every job j .
3-9:We will also consider randomized algorithms and algorithms that return a fractional assignment .
3-10:In both these settings, we will again specify an assignment by a vector x = (xij)i,j with P j xij = 1, but now xij ∈ [0, 1] for every i, j .
3-11:For a randomized algorithm, xij is simply the probability that j is assigned to i (thus, x is a convex combination of integer assignments) .
3-12:We denote the load of machine i (under a given assignment) by li = P j xijpij, and the makespan of a schedule is defined as the maximum load on any machine, i.e., maxi li .
3-13:The goal in the makespan minimization problem is to assign the jobs to the machines so as to minimize the makespan of the schedule .
3-14:2.2 Mechanism design We consider the makespan minimization problem in the above scheduling domains in the context of mechanism design .
3-15:Mechanism design studies strategic settings where the social designer needs to ensure the cooperation of the different entities involved in the algorithmic procedure .
3-16:Following the work of Nisan and Ronen [22], we consider the machines to be the strategic players or agents .
3-17:The social designer holds the set of jobs that need to be assigned, but does 254 not know the (true) processing times of these jobs on the different machines .
3-18:Each machine is a selfish entity, that privately knows its own processing time for each job .
3-19:on a machine incurs a cost to the machine equal to the true processing time of the job on the machine, and a machine may choose to misrepresent its vector of processing times, which are private, in order to decrease its cost .
3-20:We consider direct revelation mechanisms: each machine reports its (possibly false) vector of processing times, the mechanism then computes a schedule and hands out payments to the players (i.e., machines) to compensate them for the cost they incur in processing their assigned jobs .
3-21:A (direct revelation) mechanism thus consists of a tuple (x, P): x specifies the schedule, and P = {Pi} specifies the payments handed out to the machines, where both x and the Pis are functions of the reported processing times p = (pij)i,j .
3-22:The mechanism"s goal is to compute a schedule that has near optimal makespan with respect to the true processing times; a machine i is however only interested in maximizing its own utility, Pi − li, where li is its load under the output assignment, and may declare false processing times if this could increase its utility .
3-23:The mechanism must therefore incentivize the machines players to truthfully reveal their processing times via the payments .
3-24:This is made precise using the notion of dominant strategy truthfulness .
3-25:Definition 2.1 (Truthfulness) A scheduling mechanism is truthful if, for every machine i, every vector of processing times of the other machines, p−i, every true processing time vector p1 i and any other vector p2 i of machine i, we have: P1 i − X j x1 ijp1 ij ≥ P2 i − X j x2 ijp1 ij, (1) where (x1 , P1 ) and (x2 , P2 ) are respectively the schedule and payments when the other machines declare p−i and machine i declares p1 i and p2 i , i.e., x1 = x(p1 i , p−i), P1 i = Pi(p1 i , p−i) and x2 = x(p2 i , p−i), P2 i = Pi(p2 i , p−i) .
3-26:To put it in words, in a truthful mechanism, no machine can improve its utility by declaring a false processing time, no matter what the other machines declare .
3-27:We will also consider fractional mechanisms that return a fractional assignment, and randomized mechanisms that are allowed to toss coins and where the assignment and the payments may be random variables .
3-28:The notion of truthfulness for a fractional mechanism is the same as in Definition 2.1, where x1 , x2 are now fractional assignments .
3-29:For a randomized mechanism, we will consider the notion of truthfulness in expectation [3], which means that a machine (player) maximizes her expected utility by declaring her true processing time vector .
3-30:Inequality (1) also defines truthfulness in expectation for a randomized mechanism, where P1 i , P2 i now denote the expected payments made to player i, x1 , x2 are the fractional assignments denoting the randomized algorithm"s schedule (i.e., xk ij is the probability that j is assigned to i in the schedule output for (pk i , p−i)) .
3-31:For our two scheduling domains, the informational assumption is that the values Lj, Hj are publicly known .
3-32:The private information of a machine is which jobs have value Lj (or L) and which ones have value Hj (or H) on it .
3-33:We emphasize that both of our domains are multidimensional, since each machine i needs to specify a vector saying which jobs are low and high on it. .
4 CYCLE MONOTONICITY :
4-1:Although truthfulness is defined in terms of payments, it turns out that truthfulness actually boils down to a certain algorithmic condition of monotonicity .
4-2:This seems to have been first observed for multidimensional domains by Rochet [23] in 1987, and has been used successfully in algorithmic mechanism design several times, but for singledimensional domains .
4-3:However for multidimensional domains, the monotonicity condition is more involved and there has been no success in employing it in the design of truthful mechanisms .
4-4:Most positive results for multidimensional domains have relied on explicit price specifications in order to prove truthfulness .
4-5:One of the main contributions of this paper is to demonstrate that the monotonicity condition for multidimensional settings, which is sometimes called cycle monotonicity, can indeed be effectively utilized to devise truthful mechanisms .
4-6:We include a brief exposition on it for completeness .
4-7:The exposition here is largely based on [11] .
4-8:Cycle monotonicity is best described in the abstract social choice setting: there is a finite set A of alternatives, there are m players, and each player has a private type (valuation function) v : A → R, where vi(a) should be interpreted as i"s value for alternative a .
4-9:In the scheduling domain, A represents all the possible assignments of jobs to machines, and vi(a) is the negative of i"s load in the schedule a .
4-10:Let Vi denote the set of all possible types of player i .
4-11:A mechanism is a tuple (f, {Pi}) where f : V1 × · · · × Vm → A is the algorithm for choosing the alternative, and Pi : V1 × · · · × Vm → A is the price charged to player i (in the scheduling setting, the mechanism pays the players, which corresponds to negative prices) .
4-12:The mechanism is truthful if for every i, every v−i ∈ V−i = Q i =i Vi , and any vi, vi ∈ Vi we have vi(a) − Pi(vi, v−i) ≥ vi(b) − Pi(vi, v−i), where a = f(vi, v−i) and b = f(vi, v−i) .
4-13:A basic question that arises is given an algorithm f : V1 × · · · × Vm → A, do there exist prices that will make the resulting mechanism truthful? It is well known (see e.g .
4-14:[15]) that the price Pi can only depend on the alternative chosen and the others" declarations, that is, we may write Pi : V−i × A → R .
4-15:Thus, truthfulness implies that for every i, every v−i ∈ V−i, and any vi, vi ∈ Vi with f(vi, v−i) = a and f(vi, v−i) = b, we have vi(a) − Pi(a, v−i) ≥ vi(b) − Pi(b, v−i) .
4-16:Now fix a player i, and fix the declarations v−i of the others .
4-17:We seek an assignment to the variables {Pa}a∈A such that vi(a) − vi(b) ≥ Pa − Pb for every a, b ∈ A and vi ∈ Vi with f(vi, v−i) = a .
4-18:(Strictly speaking, we should use A = f(Vi, v−i) instead of A here.) Define δa,b := inf{vi(a)− vi(b) : vi ∈ Vi, f(vi, v−i) = a} .
4-19:We can now rephrase the above price assignment problem: we seek an assignment to the variables {Pa}a∈A such that Pa − Pb ≤ δa,b ∀a, b ∈ A (2) This is easily solved by looking at the allocation graph and applying a standard basic result of graph theory .
4-20:Definition 3.1 (Gui et al .
4-21:[11]) The allocation graph of f is a directed weighted graph G = (A, E) where E = A × A and the weight of an edge b → a (for any a, b ∈ A) is δa,b .
4-22:Theorem 3.2 There exists a feasible assignment to (2) iff the allocation graph has no negative length cycles .
4-23:Furthermore, if all cycles are non negative, a feasible assignment is 255 obtained as follows: fix an arbitrary node a∗ ∈ A and set Pa to be the length of the shortest path from a∗ to a .
4-24:This leads to the following definition, which is another way of phrasing the condition that the allocation graph have no negative cycles .
4-25:Definition 3.3 (Cycle monotonicity) A social choice function f satisfies cycle monotonicity if for every player i, every v−i ∈ V−i, every integer K, and every v1 i , .
4-26:.
4-27:.
4-28:, vK i ∈ Vi, KX k=1 h vk i (ak) − vk i (ak+1) i ≥ 0 where ak = f(vk i , v−i) for 1 ≤ k ≤ K, and aK+1 = a1 .
4-29:Corollary 3.4 There exist prices P such that the mechanism (f, P) is truthful iff f satisfies cycle monotonicity.1 We now consider our specific scheduling domain .
4-30:Fix a player i, p−i, and any p1 i , .
4-31:.
4-32:.
4-33:, pK i .
4-34:Let x(pk i , p−i) = xk for 1 ≤ k ≤ K, and let xK+1 = x1 , pK+1 = p1 .
4-35:xk could be a {0, 1} assignment or a fractional assignment .
4-36:We have vk i (xk ) = − P j xk ijpk ij, so cycle monotonicity translates to PK k=1 ˆ − P j xk ijpk ij + P j xk+1 ij pk ij ˜ ≥ 0 .
4-37:Rearranging, we get KX k=1 X j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 .
4-38:(3) Thus (3) reduces our mechanism design problem to a concrete algorithmic problem .
4-39:For most of this paper, we will consequently ignore any strategic considerations and focus on designing an approximation algorithm for minimizing makespan that satisfies (3). .
5 A GENERAL TECHNIQUE TO OBTAIN RANDOMIZED MECHANISMS :
5-1:RANDOMIZED MECHANISMS In this section, we consider the case of job dependent Lj, Hj values (with Lj ≤ Hj), which generalizes the classical restricted machines model (where Hj = ∞) .
5-2:We show the power of randomization, by providing a general technique that converts any c approximation algorithm into a 3c approximation, truthful in expectation mechanism .
5-3:This is one of the few results that shows how to export approximation algorithms for a multidimensional problem into truthful mechanisms when the algorithm is given as a black box .
5-4:Our construction and proof are simple, and based on two ideas .
5-5:First, as outlined above, we prove truthfulness using cycle monotonicity .
5-6:It seems unlikely that for an arbitrary approximation algorithm given only as a black box, one would be able to come up with payments in order to prove truthfulness; but cycle monotonicity allows us to prove precisely this .
5-7:Second, we obtain our randomized mechanism by (a) first moving to a fractional domain, and constructing a fractional truthful mechanism that is allowed to return fractional assignments; then (b) using a rounding procedure to express the fractional schedule as a convex combination of integer schedules .
5-8:This builds upon a theme introduced by Lavi and Swamy [16], namely that of using fractional mechanisms to obtain truthful in expectation mechanisms .
5-9:1 It is not clear if Theorem 3.2, and hence, this statement, hold if A is not finite .
5-10:We should point out however that one cannot simply plug in the results of [16] .
5-11:Their results hold for social welfaremaximization problems and rely on using VCG to obtain a fractional truthful mechanism .
5-12:VCG however does not apply to makespan minimization, and in our case even the existence of a near optimal fractional truthful mechanism is not known .
5-13:We use the following result adapted from [16] .
5-14:Lemma 4.1 (Lavi and Swamy [16]) Let M = (x, P) be a fractional truthful mechanism .
5-15:Let A be a randomized rounding algorithm that given a fractional assignment x, outputs a random assignment X such that E ˆ Xij ˜ = xij for all i, j .
5-16:Then there exist payments P such that the mechanism M = (A, P ) is truthful in expectation .
5-17:Furthermore, if M is individually rational then M is individually rational for every realization of coin tosses .
5-18:Let OPT(p) denote the optimal makespan (over integer schedules) for instance p .
5-19:As our first step, we take a capproximation algorithm and convert it to a 2c approximation fractional truthful mechanism .
5-20:This conversion works even when the approximation algorithm returns only a fractional schedule (satisfying certain properties) of makespan at most c · OPT(p) for every instance p .
5-21:We prove truthfulness by showing that the fractional algorithm satisfies cycle monotonicity (3) .
5-22:Notice that the alternative set of our fractional mechanism is finite (although the set of all fractional assignments is infinite): its cardinality is at most that of the inputdomain, which is at most 2mn in the two value case .
5-23:Thus, we can apply Corollary 3.4 here .
5-24:To convert this fractional truthful mechanism into a randomized truthful mechanism we need a randomized rounding procedure satisfying the requirements of Lemma 4.1 .
5-25:Fortunately, such a procedure is already provided by Kumar, Marathe, Parthasarathy, and Srinivasan [14] .
5-26:Lemma 4.2 (Kumar et al .
5-27:[14]) Given a fractional assignment x and a processing time vector p, there exists a randomized rounding procedure that yields a (random) assignment X such that, .
6 for any i, j, E ˆ :
6-1:ˆ Xij ˜ = xij. .
7 for any i, P :
7-1:P j Xijpij < P j xijpij + max{j:xij ∈(0,1)} pij with probability 1 .
7-2:Property 1 will be used to obtain truthfulness in expectation, and property 2 will allow us to prove an approximation guarantee .
7-3:We first show that any algorithm that returns a fractional assignment having certain properties satisfies cycle monotonicity .
7-4:Lemma 4.3 Let A be an algorithm that for any input p, outputs a (fractional) assignment x such that, if pij = Hj then xij ≤ 1 m, and if pij = Lj then xij ≥ 1 m .
7-5:Then A satisfies cycle monotonicity .
7-6:Proof .
7-7:Fix a player i, and the vector of processing times of the other players p−i .
7-8:We need to prove (3), that is, PK k=1 P j xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 for every p1 i , .
7-9:.
7-10:.
7-11:, pK i , where index k = K + 1 is taken to be k = 1 .
7-12:We will show that for every job j, PK k=1 xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 .
7-13:If pk ij is the same for all k (either always Lj or always Hj), then the above inequality clearly holds .
7-14:Otherwise we can 256 divide the indices 1, .
7-15:.
7-16:.
7-17:, K, into maximal segments, where a maximal segment is a maximal set of consecutive indices k , k + 1, .
7-18:.
7-19:.
7-20:, k − 1, k (where K + 1 ≡ 1) such that pk ij = Hj ≥ pk +1 ij ≥ · · · ≥ pk ij = Lj .
7-21:This follows because there must be some k such that pk ij = Hj > pk−1 ij = Lj .
7-22:We take k = k and then keep including indices in this segment till we reach a k such that pk ij = Lj and pk+1 ij = Hj .
7-23:We set k = k, and then start a new maximal segment with index k + 1 .
7-24:Note that k = k and k + 1 = k − 1 .
7-25:We now have a subset of indices and we can continue recursively .
7-26:So all indices are included in some maximal segment .
7-27:We will show that for every such maximal segment k , k +1, .
7-28:.
7-29:.
7-30:, k ,P k −1≤k<k xk+1 ij ` pk ij − pk+1 ij ´ ≥ 0 .
7-31:Adding this for each segment yields the desired inequality .
7-32:So now focus on a maximal segment k , k + 1, .
7-33:.
7-34:.
7-35:, k − 1, k .
7-36:Thus, there is some k∗ such that for k ≤ k < k∗ , we have pk ij = Hj, and for k∗ ≤ k ≤ k , we have pk ij = Lj .
7-37:Now the left hand side of the above inequality for this segment is simply xk ij (Lj −Hj)+xk∗ ij (Hj −Lj) ≥ 0, since xk ij ≤ 1 m ≤ xk∗ ij as pk ij = Hj and pk∗ ij = Lj .
7-38:We now describe how to use a c approximation algorithm to obtain an algorithm satisfying the property in Lemma 4.3 .
7-39:For simplicity, first suppose that the approximation algorithm returns an integral schedule .
7-40:The idea is to simply spread this schedule .
7-41:We take each job j assigned to a high machine and assign it to an extent 1 m on all machines; for each job j assigned to a low machine, say i, we assign 1 m fraction of it to the other machines where it is low, and assign its remaining fraction (which is at least 1 m) to i .
7-42:The resulting assignment clearly satisfies the desired properties .
7-43:Also observe that the load on any machine has at most increased by 1 m · (load on other machines) ≤ makespan, and hence the makespan has at most doubled .
7-44:This spreading out can also be done if the initial schedule is fractional .
7-45:We now describe the algorithm precisely .
7-46:Algorithm 1 Let A be any algorithm that on any input p outputs a possibly fractional assignment x such that xij > 0 implies that pij ≤ T, where T is the makespan of x .
7-47:(In particular, note that any algorithm that returns an integral assignment has these properties.) Our algorithm, which we call A , returns the following assignment xF .
7-48:Initialize xF ij = 0 for all i, j .
7-49:For every i, j, .
8 if pij = Hj, set xF :
8-1:ij = P i :pi j =Hj xi j m; .
9 if pij = Lj, set xF :
9-1:ij = xij + P i =i:pi j =Lj (xi j −xij) m+ P i :pi j =Hj xi j m .
9-2:Theorem 4.4 Suppose algorithm A satisfies the conditions in Algorithm 1 and returns a makespan of at most c·OPT(p) for every p .
9-3:Then, the algorithm A constructed above is a 2c approximation, cycle monotone fractional algorithm .
9-4:Moreover, if xF ij > 0 on input p, then pij ≤ c · OPT(p) .
9-5:Proof .
9-6:First, note that xF is a valid assignment: for every job j, P i xF ij = P i xij + P i,i =i:pij =pi j =Lj (xi j − xij) m = P i xij = 1 .
9-7:We also have that if pij = Hj then xF ij = P i :pi j =Hj xi j m ≤ 1 m .
9-8:If pij = Lj, then xF ij = xij(1 − m) + P i =i xi j m where = |{i = i : pi j = Lj}| ≤ m − 1; so xF ij ≥ P i xi j m ≥ 1 m .
9-9:Thus, by Lemma 4.3, A satisfies cycle monotonicity .
9-10:The total load on any machine i under xF is at mostP j:pij =Hj P i :pi j =Hj Hj· xi j m + P j:pij =Lj Lj ` xij+ P i =i xi j m ´ , which is at most P j pijxij + P i =i P j pi jxi j m ≤ 2c · OPT(p) .
9-11:Finally, if xF ij > 0 and pij = Lj, then pij ≤ OPT(p) .
9-12:If pij = Hj, then for some i (possibly i) with pi j = Hj we have xi j > 0, so by assumption, pi j = Hj = pij ≤ c · OPT(p) .
9-13:Theorem 4.4 combined with Lemmas 4.1 and 4.2, gives a 3c approximation, truthful in expectation mechanism .
9-14:The computation of payments will depend on the actual approximation algorithm used .
9-15:Section 3 does however give an explicit procedure to compute payments ensuring truthfulness, though perhaps not in polynomial time .
9-16:Theorem 4.5 The procedure in Algorithm 1 converts any c approximation fractional algorithm into a 3c approximation, truthful in expectation mechanism .
9-17:Taking A in Algorithm 1 to be the algorithm that returns an LP optimum assignment satisfying the required conditions (see [18, 25]), we obtain a 3 approximation mechanism .
9-18:Corollary 4.6 There is a truthful in expectation mechanism with approximation ratio 3 for the Lj Hj setting. .
10 ABSTRACT :
10-1:THE TWO VALUES CASE We now present a deterministic 2 approximation truthful mechanism for the case where pij ∈ {L, H} for all i, j
10-2:In the sequel, we will often say that j is assigned to a lowmachine to denote that j is assigned to a machine i where pij = L
10-3:We will call a job j a low job of machine i if pij = L; the low load of i is the load on i due to its low jobs, i.e., P j:pij =L xijpij
10-4:As in Section 4, our goal is to obtain an approximation algorithm that satisfies cycle monotonicity
10-5:We first obtain a simplification of condition (3) for our two values {L, H} scheduling domain (Proposition 5.1) that will be convenient to work with
10-6:We describe our algorithm in Section 5.1
10-7:In Section 5.2, we bound its approximation guarantee and prove that it satisfies cycle monotonicity
10-8:In Section 5.3, we compute explicit payments giving a truthful mechanism
10-9:Finally, in Section 5.4 we show that no deterministic mechanism can achieve the optimum makespan
10-10:Define nk, H = ˛ ˛{j : xk ij = 1, pk ij = L, pij = H} ˛ ˛ (4) nk, L = ˛ ˛{j : xk ij = 1, pk ij = H, pij = L} ˛ (p) = min ˘ T ≥ H, T multiple of L : np,T · L + (n − np,T ) · H ≤ m · T ¯
10-11:Note that np,T ·L+(n−np,T )·H −m·T is a decreasing function of T, so T∗ (p) can be computed in polynomial time via binary search
10-12:(p) and the corresponding partial assignment (i.e., j is assigned to i iff there is 1 unit of flow on edge (j, i))
10-13:the flow phase, in a greedy manner as follows
10-14:Consider these jobs in an arbitrary order and assign each job to the machine with the current lowest load (where the load includes the jobs assigned in the flow phase)
10-15:Our algorithm needs to compute a prefix maximal assignment for the threshold T∗ (p)
10-16:The proof showing the existence of a prefix maximal flow only yields a pseudopolynomial time algorithm for computing it
10-17:But notice that the max flow remains the same for any T ≥ T = n · L
10-18:So a prefix maximal flow for T is also prefix maximal for any T ≥ T
10-19:Thus, we only need to compute a prefix maximal flow for T = min{T∗ (p), T }
10-20:This can be be done in polynomial time by using the iterative augmenting paths algorithm in the existence proof to compute iteratively the maxflow for the polynomially many multiples of L up to (and including) T
10-21:Theorem 5.3 One can efficiently compute payments that when combined with Algorithm 2 yield a deterministic 2approximation truthful mechanism for the two values scheduling domain
10-22:5.2 Analysis Let OPT(p) denote the optimal makespan for p
10-23:We now prove that Algorithm 2 is a 2 approximation algorithm that satisfies cycle monotonicity
10-24:This will then allow us to compute payments in Section 5.3 and prove Theorem 5.3
10-25:5.2.1 Proof of approximation Claim 5.4 If OPT(p) < H, the makespan is at most OPT(p)
10-26:Proof
10-27:If OPT(p) < H, it must be that the optimal schedule assigns all jobs to low machines, so np,OPT(p) = n
10-28:Thus, we have T∗ (p) = L · H L
10-29:Furthermore, since we compute a prefix maximal flow for threshold T∗ (p) we have np,T ∗(p)|OPT(p) = np,OPT(p) = n, which implies that the load on each machine is at most OPT(p)
10-30:So in this case the makespan is at most (and hence exactly) OPT(p)
10-31:Claim 5.5 If OPT(p) ≥ H, then T∗ (p) ≤ L · OPT(p) L ≤ OPT(p) + L
10-32:Proof
10-33:Let nOPT(p) be the number of jobs assigned to low machines in an optimum schedule
10-34:The total load on all machines is exactly nOPT(p) · L + (n − nOPT(p)) · H, and is at most m · OPT(p), since every machine has load at most OPT(p)
10-35:So taking T = L · OPT(p) L ≥ H, since np,T ≥ nOPT(p) we have that np,T ·L+(n−np,T )·H ≤ m·T
10-36:Hence, T∗ (p), the smallest such T, is at most L · OPT(p) L
10-37:Claim 5.6 Each job assigned in step 3 of the algorithm is assigned to a high machine
10-38:258 Proof
10-39:Suppose j is assigned to machine i in step 3
10-40:If pij = L, then we must have ni p,T ∗(p) = T∗ (p), otherwise we could have assigned j to i in step 2 to obtain a flow of larger value
10-41:So at the point just before j is assigned in step 3, the load of each machine must be at least T∗ (p)
10-42:Hence, the total load after j is assigned is at least m · T∗ (p) + L > m · T∗ (p)
10-43:But the total load is also at most np,T ∗(p) · L + (n − np,T ∗(p)) · H ≤ m · T∗ (p), yielding a contradiction
10-44:Lemma 5.7 The above algorithm returns a schedule with makespan at most OPT(p)+max ˘ L, H(1− 1 m ) ¯ ≤ 2·OPT(p)
10-45:Proof
10-46:If OPT(p) < H, then by Claim 5.4, we are done
10-47:So suppose OPT(p) ≥ H
10-48:By Claim 5.5, we know that T∗ (p) ≤ OPT(p) + L
10-49:If there are no unassigned jobs after step 2 of the algorithm, then the makespan is at most T∗ (p) and we are done
10-50:So assume that there are some unassigned jobs after step 2
10-51:We will show that the makespan after step 3 is at most T +H ` 1− 1 m ´ where T = min ˘ T∗ (p), OPT(p) ¯
10-52:Suppose the claim is false
10-53:Let i be the machine with the maximum load, so li > T + H ` 1 − 1 m ´
10-54:Let j be the last job assigned to i in step 3, and consider the point just before it is assigned to i
10-55:So li > T − H m at this point
10-56:Also since j is assigned to i, by our greedy rule, the load on all the other machines must be at least li
10-57:So the total load after j is assigned, is at least H + m · li > m · T (since pij = H by Claim 5.6)
10-58:Also, for any assignment of jobs to machines in step 3, the total load is at most np,T ∗(p) · L + (n − np,T ∗(p)) · H since there are np,T ∗(p) jobs assigned to low machines
10-59:Therefore, we must have m · T < np,T ∗(p) · L + (n − np,T ∗(p)) · H
10-60:But we will argue that m · T ≥ np,T ∗(p) ·L+(n−np,T ∗(p))·H, which yields a contradiction
10-61:If T = T∗ (p), this follows from the definition of T∗ (p)
10-62:If T = OPT(p), then letting nOPT(p) denote the number of jobs assigned to low machines in an optimum schedule, we have np,T ∗(p) ≥ nOPT(p)
10-63:So np,T ∗(p) ·L+(n−np,T ∗(p))·H ≤ nOPT(p) ·L+(n−nOPT(p))·H
10-64:This is exactly the total load in an optimum schedule, which is at most m · OPT(p)
10-65:5.2.2 Proof of cycle monotonicity Lemma 5.8 Consider any two instances p = (pi, p−i) and p = (pi, p−i) where pi ≥ pi, i.e., pij ≥ pij ∀j
10-66:If T is a threshold such that np,T > np ,T , then every maximum flow x for (p , T) must assign all jobs j such that pij = L
10-67:Proof
10-68:Let Gp denote the residual graph for (p , T) and flow x
10-69:Suppose by contradiction that there exists a job j∗ with pij∗ = L that is unassigned by x
10-70:Since pi ≥ pi, all edges (j, i) that are present in the network for (p , T) are also present in the network for (p, T)
10-71:Thus, x is a valid flow for (p, T)
10-72:But it is not a max flow, since np,T > np ,T
10-73:So there exists an augmenting path P in the residual graph for (p, T) and flow x
10-74:Observe that node i must be included in P, otherwise P would also be an augmenting path in the residual graph Gp contradicting the fact that x is a maxflow
10-75:In particular, this implies that there is a path P ⊂ P from i to the sink t
10-76:Let P = (i, j1, i1,
10-77:
10-78:
10-79:, jK , iK , t)
10-80:All the edges of P are also present as edges in Gp  all reverse edges (i , j +1) are present since such an edge implies that xi j +1 = 1; all forward edges (j , i ) are present since i = i so pi j = pi j = L, and xi j +1 = 0
10-81:But then there is an augmenting path (j∗ , i, j1, i1,
10-82:
10-83:
10-84:, jK , iK , t) in Gp which contradicts the maximality of x
10-85:Let L denote the all low processing time vector
10-86:Define TL i (p−i) = T∗ (L, p−i)
10-87:Since we are focusing on machine i, and p−i is fixed throughout, we abbreviate TL i (p−i) to TL
10-88:Also, let pL = (L, p−i)
10-89:Note that T∗ (p) ≥ TL for every instance p = (pi, p−i)
10-90:Corollary 5.9 Let p = (pi, p−i) be any instance and let x be any prefix maximal flow for (p, T∗ (p))
10-91:Then, the low load on machine i is at most TL
10-92:Proof
10-93:Let T∗ = T∗ (p)
10-94:If T∗ = TL , then this is clearly true
10-95:Otherwise, consider the assignment x truncated at TL
10-96:Since x is prefix maximal, we know that this constitutes a max flow for (p, TL
11 ABSTRACT :
11-1:N
11-2:Andelman, Y
11-3:Azar, and M
11-4:Sorani
11-5:Truthful approximation mechanisms for scheduling selfish related machines
11-6:In Proc
11-7:22nd STACS, 69 82, 2005
11-8:A
11-9:Archer
11-10:Mechanisms for discrete optimization with rational agents
11-11:PhD thesis, Cornell University, 2004
11-12:A
11-13:Archer and ´E
11-14:Tardos
11-15:Truthful mechanisms for one parameter agents
11-16:In Proc
11-17:42nd FOCS, pages 482 491, 2001
11-18:V
11-19:Auletta, R
11-20:De Prisco, P
11-21:Penna, and G
11-22:Persiano
11-23:Deterministic truthful approximation mechanisms for scheduling related machines
11-24:In Proc
11-25:21st STACS, pages 608 619, 2004
11-26:I
11-27:Bez´akov´a and V
11-28:Dani
11-29:Allocating indivisible goods
11-30:In ACM SIGecom Exchanges, 2005
11-31:S
11-32:Bikhchandani, S
11-33:Chatterjee, R
11-34:Lavi, A
11-35:Mu"alem, N
11-36:Nisan, and A
11-37:Sen
11-38:Weak monotonicity characterizes deterministic dominant strategy implementation
11-39:Econometrica, 74:1109 1132, 2006
11-40:P
11-41:Briest, P
11-42:Krysta, and B
11-43:Vocking
11-44:Approximation techniques for utilitarian mechanism design
11-45:In Proc
11-46:37th STOC, pages 39 48, 2005
11-47:G
11-48:Christodoulou, E
11-49:Koutsoupias, and A
11-50:Vidali
11-51:A lower bound for scheduling mechanisms
11-52:In Proc
11-53:18th SODA, pages 1163 1170, 2007
11-54:E
11-55:Clarke
11-56:Multipart pricing of public goods
11-57:Public Choice, 8:17 33, 1971
11-58:T
11-59:Groves
11-60:Incentives in teams
11-61:Econometrica, 41:617 631, 1973
11-62:H
11-63:Gui, R
11-64:Muller, and R
11-65:V
11-66:Vohra
11-67:Characterizing dominant strategy mechanisms with multi dimensional types, 2004
11-68:Working paper
11-69:L
11-70:A
11-71:Hall
11-72:Approximation algorithms for scheduling
11-73:In D
11-74:Hochbaum, editor, Approximation Algorithms for NP Hard Problems
11-75:PWS Publishing, MA, 1996
11-76:A
11-77:Kov´acs
11-78:Fast monotone 3 approximation algorithm for scheduling related machines
11-79:In Proc
11-80:13th ESA, pages 616 627, 2005
11-81:V
11-82:S
11-83:A
11-84:Kumar, M
11-85:V
11-86:Marathe, S
11-87:Parthasarathy, and A
11-88:Srinivasan
11-89:Approximation algorithms for scheduling on multiple machines
11-90:In Proc
11-91:46th FOCS, pages 254 263, 2005
11-92:R
11-93:Lavi, A
11-94:Mu"alem, and N
11-95:Nisan
11-96:Towards a characterization of truthful combinatorial auctions
11-97:In Proc
11-98:44th FOCS, pages 574 583, 2003
11-99:R
11-100:Lavi and C
11-101:Swamy
11-102:Truthful and near optimal mechanism design via linear programming
11-103:In Proc
11-104:46th FOCS, pages 595 604, 2005
11-105:D
11-106:Lehmann, L
11-107:O"Callaghan, and Y
11-108:Shoham
11-109:Truth revelation in approximately efficient combinatorial auctions
11-110:Journal of the ACM, 49:577 602, 2002
11-111:J
11-112:K
11-113:Lenstra, D
11-114:B
11-115:Shmoys, and ´E
11-116:Tardos
11-117:Approximation algorithms for scheduling unrelated parallel machines
11-118:Math
11-119:Prog., 46:259 271, 1990
11-120:R
11-121:J
11-122:Lipton, E
11-123:Markakis, E
11-124:Mossel, and A
11-125:Saberi
11-126:On approximately fair allocations of indivisible goods
11-127:In Proc
11-128:5th EC, pages 125 131, 2004
11-129:A
11-130:Mu"alem and M
11-131:Schapira
11-132:Setting lower bounds on truthfulness
11-133:In Proc
11-134:18th SODA, 1143 1152, 2007
11-135:R
11-136:Myerson
11-137:Optimal auction design
11-138:Mathematics of Operations Research, 6:58 73, 1981
11-139:N
11-140:Nisan and A
11-141:Ronen
11-142:Algorithmic mechanism design
11-143:Games and Econ
11-144:Behavior, 35:166 196, 2001
11-145:J
11-146:C
11-147:Rochet
11-148:A necessary and sufficient condition for rationalizability in a quasilinear context
11-149:Journal of Mathematical Economics, 16:191 200, 1987
11-150:M
11-151:Saks and L
11-152:Yu
11-153:Weak monotonicity suffices for truthfulness on convex domains
11-154:In Proc
11-155:6th EC, pages 286 293, 2005
11-156:D
11-157:B
11-158:Shmoys and ´E
11-159:Tardos
11-160:An approximation algorithm for the generalized assignment problem
11-161:Mathematical Programming, 62:461 474, 1993
11-162:W
11-163:Vickrey
11-164:Counterspeculations, auctions, and competitive sealed tenders
11-165:J
11-166:Finance, 16:8 37, 1961
11-167:261
picture:
