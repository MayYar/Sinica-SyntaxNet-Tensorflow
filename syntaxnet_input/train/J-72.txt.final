Applying Learning Algorithms to Preference Elicitation 
content:
1 ABSTRACT :
1-1:We consider the parallels between the preference elicitation problem in combinatorial auctions and the problem of learning an unknown function from learning theory .
1-2:We show that learning algorithms can be used as a basis for preference elicitation algorithms .
1-3:The resulting elicitation algorithms perform a polynomial number of queries .
1-4:We also give conditions under which the resulting algorithms have polynomial communication .
1-5:Our conversion procedure allows us to generate combinatorial auction protocols from learning algorithms for polynomials, monotone DNF, and linear threshold functions .
1-6:In particular, we obtain an algorithm that elicits XOR bids with polynomial communication .
1-7:F.2.0 [Analysis of Algorithms and Problem .
2 INTRODUCTION :
2-1:In a combinatorial auction, agents may bid on bundles of goods rather than individual goods alone .
2-2:Since there are an exponential number of bundles (in the number of goods), communicating values over these bundles can be problematic .
2-3:Communicating valuations in a one shot fashion can be prohibitively expensive if the number of goods is only moderately large .
2-4:Furthermore, it might even be hard for agents to determine their valuations for single bundles [14] .
2-5:It is in the interest of such agents to have auction protocols which require them to bid on as few bundles as possible .
2-6:Even if agents can efficiently compute their valuations, they might still be reluctant to reveal them entirely in the course of an auction, because such information may be valuable to their competitors .
2-7:These considerations motivate the need for auction protocols that minimize the communication and information revelation required to determine an optimal allocation of goods .
2-8:There has been recent work exploring the links between the preference elicitation problem in combinatorial auctions and the problem of learning an unknown function from computational learning theory [5, 19] .
2-9:In learning theory, the goal is to learn a function via various types of queries, such as What is the function"s value on these inputs? In preference elicitation, the goal is to elicit enough partial information about preferences to be able to compute an optimal allocation .
2-10:Though the goals of learning and preference elicitation differ somewhat, it is clear that these problems share similar structure, and it should come as no surprise that techniques from one field should be relevant to the other .
2-11:We show that any exact learning algorithm with membership and equivalence queries can be converted into a preference elicitation algorithm with value and demand queries .
2-12:The resulting elicitation algorithm guarantees elicitation in a polynomial number of value and demand queries .
2-13:Here we mean polynomial in the number of goods, agents, and the sizes of the agents" valuation functions in a given encoding scheme .
2-14:Preference elicitation schemes have not traditionally considered this last parameter .
2-15:We argue that complexity guarantees for elicitation schemes should allow dependence on this parameter .
2-16:Introducing this parameter also allows us to guarantee polynomial worst case communication, which usually cannot be achieved in the number of goods and agents alone .
2-17:Finally, we use our conversion procedure to generate combinatorial auction protocols from learning algorithms for polynomials, monotone DNF, and linear threshold functions .
2-18:Of course, a one shot combinatorial auction where agents provide their entire valuation functions at once would also have polynomial communication in the size of the agents" valuations, and only require one query .
2-19:The advantage of our scheme is that agents can be viewed as black boxes that provide incremental information about their valuations .
2-20:There is no burden on the agents to formulate their valuations in an encoding scheme of the auctioneer"s choosing .
2-21:We expect this to be an important consideration in practice .
2-22:Also, with our scheme entire revelation only happens in the worst case .
2-23:180 For now, we leave the issue of incentives aside when deriving elicitation algorithms .
2-24:Our focus is on the time and communication complexity of preference elicitation regardless of incentive constraints, and on the relationship between the complexities of learning and preference elicitation .
2-25:Related work .
2-26:Zinkevich et al .
2-27:[19] consider the problem of learning restricted classes of valuation functions which can be represented using read once formulas and Toolbox DNF .
2-28:Read once formulas can represent certain substitutabilities, but no complementarities, whereas the opposite holds for Toolbox DNF .
2-29:Since their work is also grounded in learning theory, they allow dependence on the size of the target valuation as we do (though read once valuations can always be succinctly represented anyway) .
2-30:Their work only makes use of value queries, which are quite limited in power .
2-31:Because we allow ourselves demand queries, we are able to derive an elicitation scheme for general valuation functions .
2-32:Blum et al .
2-33:[5] provide results relating the complexities of query learning and preference elicitation .
2-34:They consider models with membership and equivalence queries in query learning, and value and demand queries in preference elicitation .
2-35:They show that certain classes of functions can be efficiently learned yet not efficiently elicited, and vice versa .
2-36:In contrast, our work shows that given a more general (yet still quite standard) version of demand query than the type they consider, the complexity of preference elicitation is no greater than the complexity of learning .
2-37:We will show that demand queries can simulate equivalence queries until we have enough information about valuations to imply a solution to the elicitation problem .
2-38:Nisan and Segal [12] study the communication complexity of preference elicitation .
2-39:They show that for many rich classes of valuations, the worst case communication complexity of computing an optimal allocation is exponential .
2-40:Their results apply to the black box model of computational complexity .
2-41:In this model algorithms are allowed to ask questions about agent valuations and receive honest responses, without any insight into how the agents internally compute their valuations .
2-42:This is in fact the basic framework of learning theory .
2-43:Our work also addresses the issue of communication complexity, and we are able to derive algorithms that provide significant communication guarantees despite Nisan and Segal"s negative results .
2-44:Their work motivates the need to rely on the sizes of agents" valuation functions in stating worst case results. .
3 THE MODELS :
3-1:2.1 Query Learning The query learning model we consider here is called exact learning from membership and equivalence queries, introduced by Angluin [2] .
3-2:In this model the learning algorithm"s objective is to exactly identify an unknown target function f : X → Y via queries to an oracle .
3-3:The target function is drawn from a function class C that is known to the algorithm .
3-4:Typically the domain X is some subset of {0, 1}m , and the range Y is either {0, 1} or some subset of the real numbers Ê .
3-5:As the algorithm progresses, it constructs a manifest hypothesis ˜f which is its current estimate of the target function .
3-6:Upon termination, the manifest hypothesis of a correct learning algorithm satisfies ˜f(x) = f(x) for all x ∈ X .
3-7:It is important to specify the representation that will be used to encode functions from C .
3-8:For example, consider the following function from {0, 1}m to Ê: f(x) = 2 if x consists of m 1"s, and f(x) = 0 otherwise .
3-9:This function may simply be represented as a list of 2m values .
3-10:Or it may be encoded as the polynomial 2x1 · · · xm, which is much more succinct .
3-11:The choice of encoding may thus have a significant impact on the time and space requirements of the learning algorithm .
3-12:Let size(f) be the size of the encoding of f with respect to the given representation class .
3-13:Most representation classes have a natural measure of encoding size .
3-14:The size of a polynomial can be defined as the number of non zero coefficients in the polynomial, for example .
3-15:We will usually only refer to representation classes; the corresponding function classes will be implied .
3-16:For example, the representation class of monotone DNF formulae implies the function class of monotone Boolean functions .
3-17:Two types of queries are commonly used for exact learning: membership and equivalence queries .
3-18:On a membership query, the learner presents some x ∈ X and the oracle replies with f(x) .
3-19:On an equivalence query, the learner presents its manifest hypothesis ˜f .
3-20:The oracle either replies ‘YES" if ˜f = f, or returns a counterexample x such that ˜f(x) = f(x) .
3-21:An equivalence query is proper if size( ˜f) ≤ size(f) at the time the manifest hypothesis is presented .
3-22:We are interested in efficient learning algorithms .
3-23:The following definitions are adapted from Kearns and Vazirani [9]: Definition 1 .
3-24:The representation class C is polynomialquery exactly learnable from membership and equivalence queries if there is a fixed polynomial p(·, ·) and an algorithm L with access to membership and equivalence queries of an oracle such that for any target function f ∈ C, L outputs after at most p(size(f), m) queries a function ˜f ∈ C such that ˜f(x) = f(x) for all instances x .
3-25:Similarly, the representation class C is efficiently exactly learnable from membership and equivalence queries if the algorithm L outputs a correct hypothesis in time p(size(f), m), for some fixed polynomial p(·, ·) .
3-26:Here m is the dimension of the domain .
3-27:Since the target function must be reconstructed, we also necessarily allow polynomial dependence on size(f) .
3-28:2.2 Preference Elicitation In a combinatorial auction, a set of goods M is to be allocated among a set of agents N so as to maximize the sum of the agents" valuations .
3-29:Such an allocation is called efficient in the economics literature, but we will refer to it as optimal and reserve the term efficient to refer to computational efficiency .
3-30:We let n = |N| and m = |M| .
3-31:An allocation is a partition of the objects into bundles (S1, .
3-32:.
3-33:.
3-34:, Sn), such that Si ∩ Sj = ∅ for all distinct i, j ∈ N .
3-35:Let Γ be the set of possible allocations .
3-36:Each agent i ∈ N has a valuation function vi : 2M → Ê over the space of possible bundles .
3-37:Each valuation vi is drawn from a known class of valuations Vi .
3-38:The valuation classes do not need to coincide .
3-39:We will assume that all the valuations considered are normalized, meaning v(∅) = 0, and that there are no externalities, meaning vi(S1, ..., Sn) = vi(Si), for all agents i ∈ N, for any allocation (S1, ..., Sn) ∈ Γ (that is, an agent cares only about the bundle allocated to her) .
3-40:Valuations satisfying these conditions are called general valuations.1 We 1 Often general valuations are made to satisfy the additional 181 also assume that agents have quasi linear utility functions, meaning that agents" utilities can be divided into monetary and non monetary components .
3-41:If an agent i is allocated bundle S at price p, it derives utility ui(S, p) = vi(S) − p .
3-42:A valuation function may be viewed as a vector of 2m − 1 non negative real values .
3-43:Of course there may also be more succinct representations for certain valuation classes, and there has been much research into concise bidding languages for various types of valuations [11] .
3-44:A classic example which we will refer to again later is the XOR bidding language .
3-45:In this language, the agent provides a list of atomic bids, which consist of a bundle together with its value .
3-46:To determine the value of a bundle S given these bids, one searches for the bundle S of highest value listed in the atomic bids such that S ⊆ S .
3-47:It is then the case that v(S) = v(S ) .
3-48:As in the learning theory setting, we will usually only refer to bidding languages rather than valuation classes, because the corresponding valuation classes will then be implied .
3-49:For example, the XOR bidding language implies the class of valuations satisfying free disposal, which is the condition that A ⊆ B ⇒ v(A) ≤ v(B) .
3-50:We let size(v1, .
3-51:.
3-52:.
3-53:, vn) = Èn i=1 size(vi) .
3-54:That is, the size of a vector of valuations is the size of the concatenation of the valuations" representations in their respective encoding schemes (bidding languages) .
3-55:To make an analogy to computational learning theory, we assume that all representation classes considered are polynomially interpretable [11], meaning that the value of a bundle may be computed in polynomial time given the valuation function"s representation .
3-56:More formally, a representation class (bidding language) C is polynomially interpretable if there exists an algorithm that given as input some v ∈ C and an instance x ∈ X computes the value v(x) in time q(size(v), m), for some fixed polynomial q(·, ·).2 In the intermediate rounds of an (iterative) auction, the auctioneer will have elicited information about the agents" valuation functions via various types of queries .
3-57:She will thus have constructed a set of manifest valuations, denoted ˜v1, .
3-58:.
3-59:.
3-60:, ˜vn.3 The values of these functions may correspond exactly to the true agent values, or they may for example be upper or lower bounds on the true values, depending on the types of queries made .
3-61:They may also simply be default or random values if no information has been acquired about certain bundles .
3-62:The goal in the preference elicitation problem is to construct a set of manifest valuations such that: arg max (S1,...,Sn)∈Γ i∈N ˜vi(Si) ⊆ arg max (S1,...,Sn)∈Γ i∈N vi(Si) That is, the manifest valuations provide enough information to compute an allocation that is optimal with respect to the true valuations .
3-63:Note that we only require one such optimal allocation .
3-64:condition of free disposal (monotonicity), but we do not need it at this point .
3-65:2 This excludes OR∗ , assuming P = NP, because interpreting bids from this language is NP hard by reduction from weighted set packing, and there is no well studied representation class in learning theory that is clearly analogous to OR∗ .
3-66:3 This view of iterative auctions is meant to parallel the learning setting .
3-67:In many combinatorial auctions, manifest valuations are not explicitly maintained but rather simply implied by the history of bids .
3-68:Two typical queries used in preference elicitation are value and demand queries .
3-69:On a value query, the auctioneer presents a bundle S ⊆ M and the agent responds with her (exact) value for the bundle v(S) [8] .
3-70:On a demand query, the auctioneer presents a vector of non negative prices p ∈ Ê(2m ) over the bundles together with a bundle S .
3-71:The agent responds ‘YES" if it is the case that S ∈ arg max S ⊆M   v(S ) − p(S ) ¡ or otherwise presents a bundle S such that v(S ) − p(S ) > v(S) − p(S) That is, the agent either confirms that the presented bundle is most preferred at the quoted prices, or indicates a better one [15].4 Note that we include ∅ as a bundle, so the agent will only respond ‘YES" if its utility for the proposed bundle is non negative .
3-72:Note also that communicating nonlinear prices does not necessarily entail quoting a price for every possible bundle .
3-73:There may be more succinct ways of communicating this vector, as we show in section 5 .
3-74:We make the following definitions to parallel the query learning setting and to simplify the statements of later results: Definition 2 .
3-75:The representation classes V1, .
3-76:.
3-77:.
3-78:, Vn can be polynomial query elicited from value and demand queries if there is a fixed polynomial p(·, ·) and an algorithm L with access to value and demand queries of the agents such that for any (v1, .
3-79:.
3-80:.
3-81:, vn) ∈ V1 × .
3-82:.
3-83:.
3-84:× Vn, L outputs after at most p(size(v1, .
3-85:.
3-86:.
3-87:, vn), m) queries an allocation (S1, .
3-88:.
3-89:.
3-90:, Sn) ∈ arg max(S1,...,Sn)∈Γ È vi(Si) .
3-91:Similarly, the representation class C can be efficiently elicited from value and demand queries if the algorithm L outputs an optimal allocation with communication p(size(v1, .
3-92:.
3-93:.
3-94:, vn), m), for some fixed polynomial p(·, ·) .
3-95:There are some key differences here with the query learning definition .
3-96:We have dropped the term exactly since the valuation functions need not be determined exactly in order to compute an optimal allocation .
3-97:Also, an efficient elicitation algorithm is polynomial communication, rather than polynomial time .
3-98:This reflects the fact that communication rather than runtime is the bottleneck in elicitation .
3-99:Computing an optimal allocation of goods even when given the true valuations is NP hard for a wide range of valuation classes .
3-100:It is thus unreasonable to require polynomial time in the definition of an efficient preference elicitation algorithm .
3-101:We are happy to focus on the communication complexity of elicitation because this problem is widely believed to be more significant in practice than that of winner determination [11].5 4 This differs slightly from the definition provided by Blum et al .
3-102:[5] Their demand queries are restricted to linear prices over the goods, where the price of a bundle is the sum of the prices of its underlying goods .
3-103:In contrast our demand queries allow for nonlinear prices, i.e .
3-104:a distinct price for every possible bundle .
3-105:This is why the lower bound in their Theorem 2 does not contradict our result that follows .
3-106:5 Though the winner determination problem is NP hard for general valuations, there exist many algorithms that solve it efficiently in practice .
3-107:These range from special purpose algorithms [7, 16] to approaches using off the shelf IP solvers [1] .
3-108:182 Since the valuations need not be elicited exactly it is initially less clear whether the polynomial dependence on size(v1, .
3-109:.
3-110:.
3-111:, vn) is justified in this setting .
3-112:Intuitively, this parameter is justified because we must learn valuations exactly when performing elicitation, in the worst case .
3-113:We address this in the next section. .
4 PARALLELSBETWEEN EQUIVALENCE AND DEMAND QUERIES :
4-1:AND DEMAND QUERIES We have described the query learning and preference elicitation settings in a manner that highlights their similarities .
4-2:Value and membership queries are clear analogs .
4-3:Slightly less obvious is the fact that equivalence and demand queries are also analogs .
4-4:To see this, we need the concept of Lindahl prices .
4-5:Lindahl prices are nonlinear and non anonymous prices over the bundles .
4-6:They are nonlinear in the sense that each bundle is assigned a price, and this price is not necessarily the sum of prices over its underlying goods .
4-7:They are non anonymous in the sense that two agents may face different prices for the same bundle of goods .
4-8:Thus Lindahl prices are of the form pi(S), for all S ⊆ M, for all i ∈ N .
4-9:Lindahl prices are presented to the agents in demand queries .
4-10:When agents have normalized quasi linear utility functions, Bikhchandani and Ostroy [4] show that there always exist Lindahl prices such that (S1, .
4-11:.
4-12:.
4-13:, Sn) is an optimal allocation if and only if Si ∈ arg max Si   vi(Si) − pi(Si) ¡ ∀i ∈ N (1) (S1, .
4-14:.
4-15:.
4-16:, Sn) ∈ arg max (S1,...,Sn)∈Γ i∈N pi(Si) (2) Condition (1) states that each agent is allocated a bundle that maximizes its utility at the given prices .
4-17:Condition (2) states that the allocation maximizes the auctioneer"s revenue at the given prices .
4-18:The scenario in which these conditions hold is called a Lindahl equilibrium, or often a competitive equilibrium .
4-19:We say that the Lindahl prices support the optimal allocation .
4-20:It is therefore sufficient to announce supporting Lindahl prices to verify an optimal allocation .
4-21:Once we have found an allocation with supporting Lindahl prices, the elicitation problem is solved .
4-22:The problem of finding an optimal allocation (with respect to the manifest valuations) can be formulated as a linear program whose solutions are guaranteed to be integral [4] .
4-23:The dual variables to this linear program are supporting Lindahl prices for the resulting allocation .
4-24:The objective function to the dual program is: min pi(S) πs + i∈N πi (3) with πi = max S⊆M (˜vi(S) − pi(S)) πs = max (S1,...,Sn)∈Γ i∈N pi(Si) The optimal values of πi and πs correspond to the maximal utility to agent i with respect to its manifest valuation and the maximal revenue to the seller .
4-25:There is usually a range of possible Lindahl prices supporting a given optimal allocation .
4-26:The agent"s manifest valuations are in fact valid Lindahl prices, and we refer to them as maximal Lindahl prices .
4-27:Out of all possible vectors of Lindahl prices, maximal Lindahl prices maximize the utility of the auctioneer, in fact giving her the entire social welfare .
4-28:Conversely, prices that maximize the È i∈N πi component of the objective (the sum of the agents" utilities) are minimal Lindahl prices .
4-29:Any Lindahl prices will do for our results, but some may have better elicitation properties than others .
4-30:Note that a demand query with maximal Lindahl prices is almost identical to an equivalence query, since in both cases we communicate the manifest valuation to the agent .
4-31:We leave for future work the question of which Lindahl prices to choose to minimize preference elicitation .
4-32:Considering now why demand and equivalence queries are direct analogs, first note that given the πi in some Lindahl equilibrium, setting pi(S) = max{0, ˜vi(S) − πi} (4) for all i ∈ N and S ⊆ M yields valid Lindahl prices .
4-33:These prices leave every agent indifferent across all bundles with positive price, and satisfy condition (1) .
4-34:Thus demand queries can also implicitly communicate manifest valuations, since Lindahl prices will typically be an additive constant away from these by equality (4) .
4-35:In the following lemma we show how to obtain counterexamples to equivalence queries through demand queries .
4-36:Lemma 1 .
4-37:Suppose an agent replies with a preferred bundle S when proposed a bundle S and supporting Lindahl prices p(S) (supporting with respect to the the agent"s manifest valuation) .
4-38:Then either ˜v(S) = v(S) or ˜v(S ) = v(S ) .
4-39:Proof .
4-40:We have the following inequalities: ˜v(S) − p(S) ≥ ˜v(S ) − p(S ) ⇒ ˜v(S ) − ˜v(S) ≤ p(S ) − p(S) (5) v(S ) − p(S ) > v(S) − p(S) ⇒ v(S ) − v(S) > p(S ) − p(S) (6) Inequality (5) holds because the prices support the proposed allocation with respect to the manifest valuation .
4-41:Inequality (6) holds because the agent in fact prefers S to S given the prices, according to its response to the demand query .
4-42:If it were the case that ˜v(S) = v(S) and ˜v(S ) = v(S ), these inequalities would represent a contradiction .
4-43:Thus at least one of S and S is a counterexample to the agent"s manifest valuation .
4-44:Finally, we justify dependence on size(v1, .
4-45:.
4-46:.
4-47:, vn) in elicitation problems .
4-48:Nisan and Segal (Proposition 1, [12]) and Parkes (Theorem 1, [13]) show that supporting Lindahl prices must necessarily be revealed in the course of any preference elicitation protocol which terminates with an optimal allocation .
4-49:Furthermore, Nisan and Segal (Lemma 1, [12]) state that in the worst case agents" prices must coincide with their valuations (up to a constant), when the valuation class is rich enough to contain dual valuations (as will be the case with most interesting classes) .
4-50:Since revealing Lindahl prices is a necessary condition for establishing an optimal allocation, and since Lindahl prices contain the same information as valuation functions (in the worst case), allowing for dependence on size(v1, .
4-51:.
4-52:.
4-53:, vn) in elicitation problems is entirely natural .
4-54:183 .
5 FROM LEARNING TO PREFERENCE ELICITATION :
5-1:ELICITATION The key to converting a learning algorithm to an elicitation algorithm is to simulate equivalence queries with demand and value queries until an optimal allocation is found .
5-2:Because of our Lindahl price construction, when all agents reply ‘YES" to a demand query, we have found an optimal allocation, analogous to the case where an agent replies ‘YES" to an equivalence query when the target function has been exactly learned .
5-3:Otherwise, we can obtain a counterexample to an equivalence query given an agent"s response to a demand query .
5-4:Theorem 1 .
5-5:The representation classes V1, .
5-6:.
5-7:.
5-8:, Vn can be polynomial query elicited from value and demand queries if they can each be polynomial query exactly learned from membership and equivalence queries .
5-9:Proof .
5-10:Consider the elicitation algorithm in Figure 1 .
5-11:Each membership query in step 1 is simulated with a value query since these are in fact identical .
5-12:Consider step 4 .
5-13:If all agents reply ‘YES", condition (1) holds .
5-14:Condition (2) holds because the computed allocation is revenue maximizing for the auctioneer, regardless of the agents" true valuations .
5-15:Thus an optimal allocation has been found .
5-16:Otherwise, at least one of Si or Si is a counterexample to ˜vi, by Lemma 1 .
5-17:We identify a counterexample by performing value queries on both these bundles, and provide it to Ai as a response to its equivalence query .
5-18:This procedure will halt, since in the worst case all agent valuations will be learned exactly, in which case the optimal allocation and Lindahl prices will be accepted by all agents .
5-19:The procedure performs a polynomial number of queries, since A1, .
5-20:.
5-21:.
5-22:, An are all polynomial query learning algorithms .
5-23:Note that the conversion procedure results in a preference elicitation algorithm, not a learning algorithm .
5-24:That is, the resulting algorithm does not simply learn the valuations exactly, then compute an optimal allocation .
5-25:Rather, it elicits partial information about the valuations through value queries, and periodically tests whether enough information has been gathered by proposing an allocation to the agents through demand queries .
5-26:It is possible to generate a Lindahl equilibrium for valuations v1, .
5-27:.
5-28:.
5-29:, vn using an allocation and prices derived using manifest valuations ˜v1, .
5-30:.
5-31:.
5-32:, ˜vn, and finding an optimal allocation does not imply that the agents" valuations have been exactly learned .
5-33:The use of demand queries to simulate equivalence queries enables this early halting .
5-34:We would not obtain this property with equivalence queries based on manifest valuations. .
6 COMMUNICATION COMPLEXITY :
6-1:In this section, we turn to the issue of the communication complexity of elicitation .
6-2:Nisan and Segal [12] show that for a variety of rich valuation spaces (such as general and submodular valuations), the worst case communication burden of determining Lindahl prices is exponential in the number of goods, m .
6-3:The communication burden is measured in terms of the number of bits transmitted between agents and auctioneer in the case of discrete communication, or in terms of the number of real numbers transmitted in the case of continuous communication .
6-4:Converting efficient learning algorithms to an elicitation algorithm produces an algorithm whose queries have sizes polynomial in the parameters m and size(v1, .
6-5:.
6-6:.
6-7:, vn) .
6-8:Theorem 2 .
6-9:The representation classes V1, .
6-10:.
6-11:.
6-12:, Vn can be efficiently elicited from value and demand queries if they can each be efficiently exactly learned from membership and equivalence queries .
6-13:Proof .
6-14:The size of any value query is O(m): the message consists solely of the queried bundle .
6-15:To communicate Lindahl prices to agent i, it is sufficient to communicate the agent"s manifest valuation function and the value πi, by equality (4) .
6-16:Note that an efficient learning algorithm never builds up a manifest hypothesis of superpolynomial size, because the algorithm"s runtime would then also be superpolynomial, contradicting efficiency .
6-17:Thus communicating the manifest valuation requires size at most p(size(vi), m), for some polynomial p that upper bounds the runtime of the efficient learning algorithm .
6-18:Representing the surplus πi to agent i cannot require space greater than q(size(˜vi), m) for some fixed polynomial q, because we assume that the chosen representation is polynomially interpretable, and thus any value generated will be of polynomial size .
6-19:We must also communicate to i its allocated bundle, so the total message size for a demand query is at most p(size(vi), m) + q(p(size(vi), m), m)+O(m) .
6-20:Clearly, an agent"s response to a value or demand query has size at most q(size(vi), m) + O(m) .
6-21:Thus the value and demand queries, and the responses to these queries, are always of polynomial size .
6-22:An efficient learning algorithm performs a polynomial number of queries, so the total communication of the resulting elicitation algorithm is polynomial in the relevant parameters .
6-23:There will often be explicit bounds on the number of membership and equivalence queries performed by a learning algorithm, with constants that are not masked by big O notation .
6-24:These bounds can be translated to explicit bounds on the number of value and demand queries made by the resulting elicitation algorithm .
6-25:We upper bounded the size of the manifest hypothesis with the runtime of the learning algorithm in Theorem 2 .
6-26:We are likely to be able to do much better than this in practice .
6-27:Recall that an equivalence query is proper if size( ˜f) ≤ size(f) at the time the query is made .
6-28:If the learning algorithm"s equivalence queries are all proper, it may then also be possible to provide tight bounds on the communication requirements of the resulting elicitation algorithm .
6-29:Theorem 2 show that elicitation algorithms that depend on the size(v1, .
6-30:.
6-31:.
6-32:, vn) parameter sidestep Nisan and Segal"s [12] negative results on the worst case communication complexity of efficient allocation problems .
6-33:They provide guarantees with respect to the sizes of the instances of valuation functions faced at any run of the algorithm .
6-34:These algorithms will fare well if the chosen representation class provides succinct representations for the simplest and most common of valuations, and thus the focus moves back to one of compact yet expressive bidding languages .
6-35:We consider these issues below. .
7 APPLICATIONS :
7-1:In this section, we demonstrate the application of our methods to particular representation classes for combinatorial valuations .
7-2:We have shown that the preference elicitation problem for valuation classes V1, .
7-3:.
7-4:.
7-5:, Vn can be reduced 184 Given: exact learning algorithms A1, .
7-6:.
7-7:.
7-8:, An for valuations classes V1, .
7-9:.
7-10:.
7-11:, Vn respectively .
7-12:Loop until there is a signal to halt: equivalence query, or has halted with the agent"s exact valuation .
7-13:the manifest valuations ˜v1, .
7-14:.
7-15:.
7-16:, ˜vn determined so far .
7-17:has replied with some preferred bundle Si .
7-18:Perform value queries on Si and Si to find a counterexample to ˜vi, and provide it to Ai .
7-19:Figure 1: Converting learning algorithms to an elicitation algorithm .
7-20:to the problem of finding an efficient learning algorithm for each of these classes separately .
7-21:This is significant because there already exist learning algorithms for a wealth of function classes, and because it may often be simpler to solve each learning subproblem separately than to attack the preference elicitation problem directly .
7-22:We can develop an elicitation algorithm that is tailored to each agent"s valuation, with the underlying learning algorithms linked together at the demand query stages in an algorithm independent way .
7-23:We show that existing learning algorithms for polynomials, monotone DNF formulae, and linear threshold functions can be converted into preference elicitation algorithms for general valuations, valuations with free disposal, and valuations with substitutabilities, respectively .
7-24:We focus on representations that are polynomially interpretable, because the computational learning theory literature places a heavy emphasis on computational tractability [18] .
7-25:In interpreting the methods we emphasize the expressiveness and succinctness of each representation class .
7-26:The representation class, which in combinatorial auction terms defines a bidding language, must necessarily be expressive enough to represent all possible valuations of interest, and should also succinctly represent the simplest and most common functions in the class .
7-27:6.1 Polynomial Representations Schapire and Sellie [17] give a learning algorithm for sparse multivariate polynomials that can be used as the basis for a combinatorial auction protocol .
7-28:The equivalence queries made by this algorithm are all proper .
7-29:Specifically, their algorithm learns the representation class of t sparse multivariate polynomials over the real numbers, where the variables may take on values either 0 or 1 .
7-30:A t sparse polynomial has at most t terms, where a term is a product of variables, e.g .
7-31:x1x3x4 .
7-32:A polynomial over the real numbers has coefficients drawn from the real numbers .
7-33:Polynomials are expressive: every valuation function v : 2M → Ê+ can be uniquely written as a polynomial [17] .
7-34:To get an idea of the succinctness of polynomials as a bidding language, consider the additive and single item valuations presented by Nisan [11] .
7-35:In the additive valuation, the value of a bundle is the number of goods the bundle contains .
7-36:In the single item valuation, all bundles have value 1, except ∅ which has value 0 (i.e .
7-37:the agent is satisfied as soon as it has acquired a single item) .
7-38:It is not hard to show that the single item valuation requires polynomials of size 2m − 1, while polynomials of size m suffice for the additive valuation .
7-39:Polynomials are thus appropriate for valuations that are mostly additive, with a few substitutabilities and complementarities that can be introduced by adjusting coefficients .
7-40:The learning algorithm for polynomials makes at most mti +2 equivalence queries and at most (mti +1)(t2 i +3ti) 2 membership queries to an agent i, where ti is the sparcity of the polynomial representing vi [17] .
7-41:We therefore obtain an algorithm that elicits general valuations with a polynomial number of queries and polynomial communication.6 6.2 XOR Representations The XOR bidding language is standard in the combinatorial auctions literature .
7-42:Recall that an XOR bid is characterized by a set of bundles B ⊆ 2M and a value function w : B → Ê+ defined on those bundles, which induces the valuation function: v(B) = max {B ∈B | B ⊆B} w(B ) (7) XOR bids can represent valuations that satisfy free disposal (and only such valuations), which again is the property that A ⊆ B ⇒ v(A) ≤ v(B) .
7-43:The XOR bidding language is slightly less expressive than polynomials, because polynomials can represent valuations that do not satisfy free disposal .
7-44:However, XOR is as expressive as required in most economic settings .
7-45:Nisan [11] notes that XOR bids can represent the single item valuation with m atomic bids, but 2m − 1 atomic bids are needed to represent the additive valuation .
7-46:Since the opposite holds for polynomials, these two languages are incomparable in succinctness, and somewhat complementary for practical use .
7-47:Blum et al .
7-48:[5] note that monotone DNF formulae are the analogs of XOR bids in the learning theory literature .
7-49:A monotone DNF formula is a disjunction of conjunctions in which the variables appear unnegated, for example x1x2 ∨ x3 ∨ x2x4x5 .
7-50:Note that such formulae can be represented as XOR bids where each atomic bid has value 1; thus XOR bids generalize monotone DNF formulae from Boolean to real valued functions .
7-51:These insights allow us to generalize a classic learning algorithm for monotone DNF ([3] Theorem 6 Note that Theorem 1 applies even if valuations do not satisfy free disposal .
7-52:185 1, [18] Theorem B) to a learning algorithm for XOR bids.7 Lemma 2 .
7-53:An XOR bid containing t atomic bids can be exactly learned with t + 1 equivalence queries and at most tm membership queries .
7-54:Proof .
7-55:The algorithm will identify each atomic bid in the target XOR bid in turn .
7-56:Initialize the manifest valuation ˜v to the bid that is identically zero on all bundles (this is an XOR bid containing 0 atomic bids) .
7-57:Present ˜v as an equivalence query .
7-58:If the response is ‘YES", we are done .
7-59:Otherwise we obtain a bundle S for which v(S) = ˜v(S) .
7-60:Create a bundle T as follows .
7-61:First initialize T = S .
7-62:For each item i in T, check via a membership query whether v(T) = v(T − {i}) .
7-63:If so set T = T − {i} .
7-64:Otherwise leave T as is and proceed to the next item .
7-65:We claim that (T, v(T)) is an atomic bid of the target XOR bid .
7-66:For each item i in T, we have v(T) = v(T − {i}) .
7-67:To see this, note that at some point when generating T, we had a ¯T such that T ⊆ ¯T ⊆ S and v( ¯T) > v( ¯T − {i}), so that i was kept in ¯T .
7-68:Note that v(S) = v( ¯T) = v(T) because the value of the bundle S is maintained throughout the process of deleting items .
7-69:Now assume v(T) = v(T − {i}) .
7-70:Then v( ¯T) = v(T) = v(T − {i}) > v( ¯T − {i}) which contradicts free disposal, since T − {i} ⊆ ¯T − {i} .
7-71:Thus v(T) > v(T − {i}) for all items i in T .
7-72:This implies that (T, v(T)) is an atomic bid of v .
7-73:If this were not the case, T would take on the maximum value of its strict subsets, by the definition of an XOR bid, and we would have v(T) = max i∈T { max T ⊆T −{i} v(T )} = max i∈T {v(T − {i})} < v(T) which is a contradiction .
7-74:We now show that v(T) = ˜v(T), which will imply that (T, v(T)) is not an atomic bid of our manifest hypothesis by induction .
7-75:Assume that every atomic bid (R, ˜v(R)) identified so far is indeed an atomic bid of v (meaning R is indeed listed in an atomic bid of v as having value v(R) = ˜v(R)) .
7-76:This assumption holds vacuously when the manifest valuation is initialized .
7-77:Using the notation from (7), let ( ˜B, ˜w) be our hypothesis, and (B, w) be the target function .
7-78:We have ˜B ⊆ B, and ˜w(B) = w(B) for B ∈ ˜B by assumption .
7-79:Thus, ˜v(S) = max {B∈ ˜B | B⊆S} ˜w(B) = max {B∈ ˜B | B⊆S} w(B) ≤ max {B∈B | B⊆S} w(B) = v(S) (8) Now assume v(T) = ˜v(T) .
7-80:Then, ˜v(T) = v(T) = v(S) = ˜v(S) (9) The second equality follows from the fact that the value remains constant when we derive T from S .
7-81:The last inequality holds because S is a counterexample to the manifest valuation .
7-82:From equation (9) and free disposal, we 7 The cited algorithm was also used as the basis for Zinkevich et al."s [19] elicitation algorithm for Toolbox DNF .
7-83:Recall that Toolbox DNF are polynomials with non negative coefficients .
7-84:For these representations, an equivalence query can be simulated with a value query on the bundle containing all goods .
7-85:have ˜v(T) < ˜v(S) .
7-86:Then again from equation (9) it follows that v(S) < ˜v(S) .
7-87:This contradicts (8), so we in fact have v(T) = ˜v(T) .
7-88:Thus (T, v(T)) is not currently in our hypothesis as an atomic bid, or we would correctly have ˜v(T) = v(T) by the induction hypothesis .
7-89:We add (T, v(T)) to our hypothesis and repeat the process above, performing additional equivalence queries until all atomic bids have been identified .
7-90:After each equivalence query, an atomic bid is identified with at most m membership queries .
7-91:Each counterexample leads to the discovery of a new atomic bid .
7-92:Thus we make at most tm membership queries and exactly t + 1 equivalence queries .
7-93:The number of time steps required by this algorithm is essentially the same as the number of queries performed, so the algorithm is efficient .
7-94:Applying Theorem 2, we therefore obtain the following corollary: Theorem 3 .
7-95:The representation class of XOR bids can be efficiently elicited from value and demand queries .
7-96:This contrasts with Blum et al."s negative results ([5], Theorem 2) stating that monotone DNF (and hence XOR bids) cannot be efficiently elicited when the demand queries are restricted to linear and anonymous prices over the goods .
7-97:6.3 Linear Threshold Representations Polynomials, XOR bids, and all languages based on the OR bidding language (such as XOR of OR, OR of XOR, and OR∗ ) fail to succinctly represent the majority valuation [11] .
7-98:In this valuation, bundles have value 1 if they contain at least m 2 items, and value 0 otherwise .
7-99:More generally, consider the r of S family of valuations where bundles have value 1 if they contain at least r items from a specified set of items S ⊆ M, and value 0 otherwise .
7-100:The majority valuation is a special case of the r of S valuation with r = m 2 and S = M .
7-101:These valuations are appropriate for representing substitutabilities: once a required set of items has been obtained, no other items can add value .
7-102:Letting k = |S|, such valuations are succinctly represented by r of k threshold functions .
7-103:These functions take the form of linear inequalities: xi1 + .
7-104:.
7-105:.
7-106:+ xik ≥ r where the function has value 1 if the inequality holds, and 0 otherwise .
7-107:Here i1, .
7-108:.
7-109:.
7-110:, ik are the items in S .
7-111:Littlestone"s WINNOW 2 algorithm can learn such functions using equivalence queries only, using at most 8r2 + 5k + 14kr ln m + 1 queries [10] .
7-112:To provide this guarantee, r must be known to the algorithm, but S (and k) are unknown .
7-113:The elicitation algorithm that results from WINNOW 2 uses demand queries only (value queries are not necessary here because the values of counterexamples are implied when there are only two possible values) .
7-114:Note that r of k threshold functions can always be succinctly represented in O(m) space .
7-115:Thus we obtain an algorithm that can elicit such functions with a polynomial number of queries and polynomial communication, in the parameters n and m alone .
7-116:186 .
8-1:We have shown that exact learning algorithms with membership and equivalence queries can be used as a basis for preference elicitation algorithms with value and demand queries
8-2:At the heart of this result is the fact that demand queries may be viewed as modified equivalence queries, specialized to the problem of preference elicitation
8-3:Our result allows us to apply the wealth of available learning algorithms to the problem of preference elicitation
8-4:A learning approach to elicitation also motivates a different approach to designing elicitation algorithms that decomposes neatly across agent types
8-5:If the designer knowns beforehand what types of preferences each agent is likely to exhibit (mostly additive, many substitutes, etc...), she can design learning algorithms tailored to each agents" valuations and integrate them into an elicitation scheme
8-6:The resulting elicitation algorithm makes a polynomial number of queries, and makes polynomial communication if the original learning algorithms are efficient
8-7:We do not require that agent valuations can be learned with value and demand queries
8-8:Equivalence queries can only be, and need only be, simulated up to the point where an optimal allocation has been computed
8-9:This is the preference elicitation problem
8-10:Theorem 1 implies that elicitation with value and demand queries is no harder than learning with membership and equivalence queries, but it does not provide any asymptotic improvements over the learning algorithms" complexity
8-11:It would be interesting to find examples of valuation classes for which elicitation is easier than learning
8-12:Blum et al
8-13:[5] provide such an example when considering membership value queries only (Theorem 4)
8-14:In future work we plan to address the issue of incentives when converting learning algorithms to elicitation algorithms
8-15:In the learning setting, we usually assume that oracles will provide honest responses to queries; in the elicitation setting, agents are usually selfish and will provide possibly dishonest responses so as to maximize their utility
8-16:We also plan to implement the algorithms for learning polynomials and XOR bids as elicitation algorithms, and test their performance against other established combinatorial auction protocols [6, 15]
8-17:An interesting question here is: which Lindahl prices in the maximal to minimal range are best to quote in order to minimize information revelation? We conjecture that information revelation is reduced when moving from maximal to minimal Lindahl prices, namely as we move demand queries further away from equivalence queries
8-18:Finally, it would be useful to determine whether the OR∗ bidding language [11] can be efficiently learned (and hence elicited), given this language"s expressiveness and succinctness for a wide variety of valuation classes
8-19:Acknowledgements We would like to thank Debasis Mishra for helpful discussions
8-20:This work is supported in part by NSF grant IIS0238147.
9-1:A
9-2:Andersson, M
9-3:Tenhunen, and F
9-4:Ygge
9-5:Integer programming for combinatorial auction winner determination
9-6:In Proceedings of the Fourth International Conference on Multiagent Systems (ICMAS 00), 2000
9-7:D
9-8:Angluin
9-9:Learning regular sets from queries and counterexamples
9-10:Information and Computation, 75:87 106, November 1987
9-11:D
9-12:Angluin
9-13:Queries and concept learning
9-14:Machine Learning, 2:319 342, 1987
9-15:S
9-16:Bikhchandani and J
9-17:Ostroy
9-18:The Package Assignment Model
9-19:Journal of Economic Theory, 107(2), December 2002
9-20:A
9-21:Blum, J
9-22:Jackson, T
9-23:Sandholm, and M
9-24:Zinkevich
9-25:Preference elicitation and query learning
9-26:In Proc
9-27:16th Annual Conference on Computational Learning Theory (COLT), Washington DC, 2003
9-28:W
9-29:Conen and T
9-30:Sandholm
9-31:Partial revelation VCG mechanism for combinatorial auctions
9-32:In Proc
9-33:the 18th National Conference on Artificial Intelligence (AAAI), 2002
9-34:Y
9-35:Fujishima, K
9-36:Leyton Brown, and Y
9-37:Shoham
9-38:Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches
9-39:In Proc
9-40:the 16th International Joint Conference on Artificial Intelligence (IJCAI), pages 548 553, 1999
9-41:B
9-42:Hudson and T
9-43:Sandholm
9-44:Using value queries in combinatorial auctions
9-45:In Proc
9-46:4th ACM Conference on Electronic Commerce (ACM EC), San Diego, CA, June 2003
9-47:M
9-48:J
9-49:Kearns and U
9-50:V
9-51:Vazirani
9-52:An Introduction to Computational Learning Theory
9-53:MIT Press, 1994
9-54:N
9-55:Littlestone
9-56:Learning quickly when irrelevant attributes abound: A new linear threshold algorithm
9-57:Machine Learning, 2:285 318, 1988
9-58:N
9-59:Nisan
9-60:Bidding and allocation in combinatorial auctions
9-61:In Proc
9-62:the ACM Conference on Electronic Commerce, pages 1 12, 2000
9-63:N
9-64:Nisan and I
9-65:Segal
9-66:The communication requirements of efficient allocations and supporting Lindahl prices
9-67:Working Paper, Hebrew University, 2003
9-68:D
9-69:C
9-70:Parkes
9-71:Price based information certificates for minimal revelation combinatorial auctions
9-72:In Padget et al., editor, Agent Mediated Electronic Commerce IV,LNAI 2531, pages 103 122
9-73:Springer Verlag, 2002
9-74:D
9-75:C
9-76:Parkes
9-77:Auction design with costly preference elicitation
9-78:In Special Issues of Annals of Mathematics and AI on the Foundations of Electronic Commerce, Forthcoming (2003)
9-79:D
9-80:C
9-81:Parkes and L
9-82:H
9-83:Ungar
9-84:Iterative combinatorial auctions: Theory and practice
9-85:In Proc
9-86:17th National Conference on Artificial Intelligence (AAAI 00), pages 74 81, 2000
9-87:T
9-88:Sandholm, S
9-89:Suri, A
9-90:Gilpin, and D
9-91:Levine
9-92:CABOB: A fast optimal algorithm for combinatorial auctions
9-93:In Proc
9-94:the 17th International Joint Conference on Artificial Intelligence (IJCAI), pages 1102 1108, 2001
9-95:R
9-96:Schapire and L
9-97:Sellie
9-98:Learning sparse multivariate polynomials over a field with queries and counterexamples
9-99:In Proceedings of the Sixth Annual ACM Workshop on Computational Learning Theory, pages 17 26
9-100:ACM Press, 1993
9-101:187 L
9-102:Valiant
9-103:A theory of the learnable
9-104:Commun
9-105:ACM, 27(11):1134 1142, Nov
9-106:1984
9-107:M
9-108:Zinkevich, A
9-109:Blum, and T
9-110:Sandholm
9-111:On polynomial time preference elicitation with value queries
9-112:In Proc
9-113:4th ACM Conference on Electronic Commerce (ACM EC), San Diego, CA, June 2003
9-114:188
picture:
