Towards Truthful Mechanisms for Binary Demand Games: 
content:
1 ABSTRACT :
1-1:The family of Vickrey Clarke Groves mechanisms is arguably the most celebrated achievement in truthful mechanism design .
1-2:However, VCG mechanisms have their limitations .
1-3:They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function .
1-4:For many optimization problems, finding the optimal output is computationally intractable .
1-5:If we apply VCG mechanisms to polynomial time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful .
1-6:In light of these limitations, it is useful to study whether we can design a truthful non VCG payment scheme that is computationally tractable for a given allocation rule O .
1-7:In this paper, we focus our attention on binary demand games in which the agents" only available actions are to take part in the a game or not to .
1-8:For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property .
1-9:We provide a general framework to design such P .
1-10:We further propose several general composition based techniques to compute P efficiently for various types of output .
1-11:In particular, we show how P can be computed through or and combinations, round based combinations, and some more complex combinations of the outputs from subgames .
1-12:F.2 [Analysis of Algorithms and Problem Complexity]: .
2 INTRODUCTION :
2-1:In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable .
2-2:The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation .
2-3:However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational maximize their own profits according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents .
2-4:Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines .
2-5:The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents" valuations .
2-6:Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP .
2-7:Some mechanisms other than VCG mechanism are needed to address these issues .
2-8:Archer and Tardos [2] studied a scheduling problem where it is NP Hard to find the optimal output .
2-9:They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem .
2-10:Auletta et al .
2-11:[3] studied a similar scheduling problem .
2-12:They provided a family of deterministic truthful (2 + ) approximation mechanisms for any fixed number of machines and several (1 + ) truthful mechanisms for some NP hard restrictions of their scheduling problem .
2-13:Lehmann et al .
2-14:[12] studied the single minded combinatorial auction and gave a√ m approximation truthful mechanism, where m is the number of goods .
2-15:They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism .
2-16:The work of Mu"alem and Nisan [13] is the closest in spirit to our work .
2-17:They characterized all truthful mechanisms based on a certain monotonicity property in a single minded auction setting .
2-18:They also showed how to used MAX and IF THEN ELSE to combine outputs from subproblems .
2-19:As shown in this paper, the MAX and IF THEN ELSE combinations are special cases of the composition based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions .
2-20:More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected .
2-21:We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type .
2-22:Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P .
2-23:Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately .
2-24:In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function .
2-25:In fact, we do not even require the existence of an objective function .
2-26:Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property .
2-27:The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful .
2-28:We complement this existence theorem with a general framework to design such a payment scheme P .
2-29:Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round based combinations; or through intermediate results, which may be themselves computed from other subproblems .
2-30:The remainder of the paper is organized as follows .
2-31:In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games .
2-32:In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P) .
2-33:A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O .
2-34:In Section 5, we provide several examples to demonstrate the effectiveness of our general framework .
2-35:We conclude our paper in Section 6 with some possible future directions. .
3 PRELIMINARIES :
3-1:2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well defined incentives and will deviate from the protocol only if the deviation improves their gain .
3-2:A standard model for mechanism design is as follows .
3-3:There are n agents 1, .
3-4:.
3-5:.
3-6:, n and each agent i has some private information ti, called its type, only known to itself .
3-7:For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction .
3-8:The agents" types define the type vector t = (t1, t2, .
3-9:.
3-10:.
3-11:, tn) .
3-12:Each agent i has a set of strategies Ai from which it can choose .
3-13:For each input vector a = (a1, .
3-14:.
3-15:.
3-16:, an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), .
3-17:.
3-18:.
3-19:, pn(a)) .
3-20:Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents .
3-21:A game is defined as G = (S, M), where S is the setting for the game the game starts and do not depend on the players" strategies .
3-22:For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node .
3-23:Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O .
3-24:A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o .
3-25:Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent i"s actual type ti, which is private information to agent i .
3-26:Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti .
3-27:Here, following a common assumption in the literature, we assume the utility for agent i is quasi linear, i.e., ui(ti, o) = v(ti, o) + Pi(a) .
3-28:Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai .
3-29:Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i .
3-30:Sometimes, we write (a−i, bi) as a|i bi .
3-31:An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i .
3-32:A direct revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism .
3-33:An incentive compatible mechanism is a direct revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility .
3-34:Then, in a direct revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti) .
3-35:Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agent"s utility of participating in the output of the mechanism is not less than the utility of the agent of not participating .
3-36:A direct revelation mechanism is strategproof if it satisfies both IC and IR properties .
3-37:Arguably the most important positive result in mechanism design is the generalized Vickrey Clarke Groves mechanism by Vickrey [21], Clarke [5], and Groves [11] .
3-38:The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents" valuations) and the set of possible outputs is assumed to be finite .
3-39:A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi is an arbitrary function of t−i .
3-40:Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10] .
3-41:The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function .
3-42:This makes the mechanism computationally intractable in many cases .
3-43:Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used .
3-44:In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function .
3-45:2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .
3-46:In other words, the output is a n tuple vector O(t) = (O1(t), O2(t), .
3-47:.
3-48:.
3-49:, On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected .
3-50:Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13] .
3-51:Hereafter, we make the following further assumptions .
3-52:a function of v(ti, oi) only is denoted as v(ti, oi) .
3-53:normalized to 0 .
3-54:This assumption is needed to guarantee the IR property .
3-55:Thus, throughout his paper, we only consider these direct revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1) .
3-56:214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative .
3-57:For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service .
3-58:Throughout this paper, we will use ci instead of vi in our analysis .
3-59:All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction .
3-60:In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game .
3-61:The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game .
3-62:optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function .
3-63:We even do not require the existence of an objective function .
3-64:a binary demand game, while the agents" valuations may be correlated in a VCG mechanism .
3-65:In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification .
3-66:2.3 Previous Work Lehmann et al .
3-67:[12] studied how to design an efficient truthful mechanism for single minded combinatorial auction .
3-68:In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci .
3-69:A single minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .
3-70:In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness .
3-71:Lehmann et al .
3-72:gave a greedy round based allocation algorithm, based on the rank ai |Si|1 2 , that has an approximation ratio √ m, where m is the number of goods in S .
3-73:Based on the approximation algorithm, they gave a truthful payment scheme .
3-74:For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0 .
3-75:Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game .
3-76:Their payment scheme inspired our payment scheme for binary demand game .
3-77:In [1], Archer et al .
3-78:studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si .
3-79:They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction .
3-80:As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability .
3-81:On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules .
3-82:In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agent"s private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load .
3-83:The mechanism"s output could be arbitrary real number but their valuation is a quasi linear function t · w, where t is the private per unit cost and w is the work load .
3-84:Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems .
3-85:Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game .
3-86:If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output .
3-87:But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion can"t directly apply to binary demand games .
3-88:The paper of Ahuva Mu"alem and Noam Nisan [13] is closest in spirit to our work .
3-89:They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12] .
3-90:They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value .
3-91:With a simple generalization, we get our conclusion for general binary demand game .
3-92:They proposed several combination methods including MAX, IF THEN ELSE construction to perform partial search .
3-93:All of their methods required the welfare function associated with the output satisfying bitonic property .
3-94:Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property .
3-95:Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction .
3-96:In addition, the binary demand game studied here is different from the traditional packing IP"s: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function .
3-97:Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. .
4 GENERAL APPROACHES :
4-1:3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful .
4-2:THEOREM 1 .
4-3:If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ) .
4-4:COROLLARY 2 .
4-5:For any strategy proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0 .
4-6:THEOREM 3 .
4-7:Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC .
4-8:The proofs of above theorems are straightforward and thus omitted due to space limit .
4-9:This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected .
4-10:Hereafter, we will only consider normalized payment schemes .
4-11:215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P .
4-12:In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O .
4-13:Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P .
4-14:DEFINITION 1 (MONOTONE NON INCREASING PROPERTY (MP)) .
4-15:An output method O is said to satisfy the monotone non increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ) .
4-16:This definition is not restricted only to binary demand games .
4-17:For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1 .
4-18:THEOREM 4 .
4-19:Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i) .
4-20:When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie breaker of the allocation rule in our proofs. .
5 The allocation rule O satisfies MP. :
5-1:demand game .
5-2:PROOF .
5-3:The proof that Condition 2 implies Condition is straightforward and is omitted here .
5-4:We then show Condition 3 implies Condition 2 .
5-5:The proof of this is similar to a proof in [13] .
5-6:To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0 .
5-7:From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .
5-8:Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .
5-9:When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .
5-10:Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .
5-11:Now consider the scenario when the actual valuation of agent i is ci = ci2 .
5-12:Its utility is p1 i − ci2 when it reports its true valuation .
5-13:Similarly, if it lies its valuation to ci1 , its utility is p0 i .
5-14:Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .
5-15:Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .
5-16:This inequality implies that ci1 > ci2 , which is a contradiction .
5-17:We then show Condition 1 implies Condition 3 .
5-18:We prove this by constructing a payment scheme and proving that this payment scheme is truthful .
5-19:The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0 .
5-20:From condition 1, if Oi(c) = 1 then ci > κi(O, c−i) .
5-21:Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR .
5-22:In the following we prove that this payment scheme also satisfies IC property .
5-23:There are two cases here .
5-24:Case 1: ci < κ(O, c−i) .
5-25:In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0 .
5-26:Now consider the situation when i declares a cost di = ci .
5-27:If di < κi(O, c−i), then i gets the same payment and utility since it is still selected .
5-28:If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore .
5-29:Thus, it has no incentive to lie in this case .
5-30:Case 2: ci ≥ κ(O, c−i) .
5-31:In this case, when i reveals its true valuation, its payment is 0 and the utility is 0 .
5-32:Now consider the situation when i declares a valuation di = ci .
5-33:If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected .
5-34:If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now .
5-35:Thus, it has no incentive to lie .
5-36:The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games .
5-37:The details are omitted here due to space limit .
5-38:We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O .
5-39:General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP .
5-40:If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful .
5-41:Otherwise, define the payment scheme P as follows .
5-42:Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i) .
5-43:Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1 .
5-44:THEOREM 5 .
5-45:The payment defined by our general framework is minimum among all truthful payment schemes using O as output. .
6 COMPUTING CUT VALUE FUNCTIONS :
6-1:To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2 .
6-2:Notice that binary search does not work generally since the valuations of agents may be continuous .
6-3:We give some general techniques that can help with finding the cut value function under certain circumstances .
6-4:Our basic approach is as follows .
6-5:First, we decompose the allocation rule into several allocation rules .
6-6:Next find the cut value function for each of these new allocation rules .
6-7:Then, we compute the original cut value function by combining these cut value functions of the new allocation rules .
6-8:4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions .
6-9:For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n tuple vector (κ1(O, c−1), κ2(O, c−2), .
6-10:.
6-11:.
6-12:, κn(O, c−n)) .
6-13:Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed .
6-14:THEOREM 6 .
6-15:With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .
6-16:Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property .
6-17:Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c) .
6-18:PROOF .
6-19:Assume that ci > ci and Oi(c) = 1 .
6-20:Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ Fj(c|i di) < τj .
6-21:Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj} .
6-22:This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i) .
6-23:which is a contradiction .
6-24:This finishes our proof .
6-25:In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian .
6-26:Thus, we can compute the inverse of F−1 j efficiently .
6-27:Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive .
6-28:However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13] .
6-29:Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare .
6-30:If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP .
6-31:From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP .
6-32:Further, the cut value of the MAX combination can be found by Algorithm 6 .
6-33:As we will show in Section 5, the complex combination can apply to some more complicated problems. .
7 CONCRETE EXAMPLES :
7-1:5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci .
7-2:Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn) .
7-3:We want to find a subset of agents D such that U ⊆ S i∈D Si .
7-4:The selected subsets is called the set cover for P i∈D ci, which is the objective function to be minimized .
7-5:Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost .
7-6:It is well known that finding the optimal solution is NP hard .
7-7:In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem .
7-8:For the completeness of presentation, we review their method here .
7-9:Algorithm 7 Greedy Set Cover Input: Agent i"s subset Si covered and cost ci .
7-10:(1 ≤ i ≤ n) .
7-11:Output: A set of agents that can cover all elements .
7-12:1: Initialize r = 1, T0 = ∅, and R = ∅ .
7-13:2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| .
7-14:4: Set Tr+1 = Tr S Sj and R = R S j .
7-15:5: r = r + 1 6: Output R .
7-16:Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c .
7-17:Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge .
7-18:Here, we consider a more general case in which the type of an agent is (Si, ci) .
7-19:In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si .
7-20:This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint .
7-21:We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful .
7-22:Obviously, the set cover problem is a binary demand game .
7-23:For the moment, we assume that agent i won"t be able to lie about Si .
7-24:We will drop this assumption later .
7-25:We show how to design a truthful mechanism by applying our general framework .
7-26:Algorithm 7 is a round based output .
7-27:Thus, for an agent i, we first focus on the output of one round r .
7-28:In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents .
7-29:Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents .
7-30:Consequently, agent i is still selected in round r, which means the output of round r satisfies MP .
7-31:Now we look into the updating rules .
7-32:For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross independent .
7-33:Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP .
7-34:with fixed cost vector c−i, we follow the steps in Algorithm agent selected in round r and T−i r+1 be the corresponding set .
7-35:Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r | .
7-36:Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t .
7-37:Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0 .
7-38:We now consider the scenario when agent i can lie about Si .
7-39:Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si .
7-40:We argue that agent i will not lie about its elements Si .
7-41:Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r | .
7-42:Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si .
7-43:Thus, lying its set as Si will not increase the cut value for each round .
7-44:Thus lying about Si will not improve agent i"s utility .
7-45:5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei .
7-46:The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .
7-47:For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k .
7-48:Here the links are agents .
7-49:The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H) .
7-50:It is NP hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20] .
7-51:The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17] .
7-52:Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20] .
7-53:Algorithm 8 Find LinkWeighted SteinerTree Input: Network G = (V, E, c) where c is the cost vector for link set E .
7-54:Source node s and receiver set Q .
7-55:Output: A tree LST rooted at s and spanned all receivers .
7-56:1: Set r = 1, G1 = G, Q1 = Q and s1 = s .
7-57:2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr .
7-58:4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0 .
7-59:The new graph is denoted as Gr+1 .
7-60:5: Set tr as qi and Pr = LCP(s, qi, c) .
7-61:6: Set Qr+1 = Qr \qi and r = r + 1 .
7-62:7: until all receivers are spanned .
7-63:Hereafter, let LST(G) be the final tree constructed using the above method .
7-64:It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism .
7-65:We then show how to design a truthful payment scheme using our general framework .
7-66:Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing independence .
7-67:Thus, from Theorem 8, the roundbased output LST satisfies MP .
7-68:In round r, the cut value for a link ei can be obtained by using the VCG mechanism .
7-69:Now we set ci = ∞ and execute Algorithm 8 .
7-70:Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞ .
7-71:Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi .
7-72:Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r} .
7-73:Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0 .
7-74:5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used .
7-75:Assume that Q is the set of receivers, including the sender .
7-76:Assume that the nodes in a node weighted graph are all agents .
7-77:The virtual minimum spanning tree is constructed as follows .
7-78:Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d) .
7-79:3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)| .
7-80:4: Build the minimum spanning tree on K(d), denoted as V MST(d) .
7-81:5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network .
7-82:7: Mark the agents on LCP(qi, qj, d) selected .
7-83:The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism .
7-84:We then show how to design a truthful mechanism based on the framework we described .
7-85:complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)| .
7-86:In other words, we implicitly defined |Q|(|Q| − 1) 2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)| .
7-87:We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP .
7-88:From Theorem 9, the allocation rule VMST satisfies the monotonicity property .
7-89:MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows .
7-90:(a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST .
7-91:Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T .
7-92:We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T) .
7-93:Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value cost function for LCP .
7-94:Assume vk ∈ LCP(qi, qj, d), then the value cost function is xk = yk − |LCPvk (qi, qj, d|k 0)| .
7-95:Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path .
7-96:(c) Remove vk and calculate the value K(d|k ∞) .
7-97:Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector .
7-98:Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST .
7-99:It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)| .
7-100:Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)| .
7-101:The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k) .
7-102:in V MST(d); else we pay it 0 .
7-103:5.4 Combinatorial Auctions Lehmann et al .
7-104:[12] studied how to design an efficient truthful mechanism for single minded combinatorial auction .
7-105:In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi .
7-106:A single minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .
7-107:Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅ .
7-108:Given the bids b1, b2, · · · , bn, they gave a greedy round based algorithm as follows .
7-109:First the bids are sorted by some criterion ( ai |Si|1 2 is used in[12]) in an increasing order and let L be the list of sorted bids .
7-110:The first bid is granted .
7-111:Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted .
7-112:If it does, it is denied .
7-113:They proved that this greedy allocation scheme using criterion ai |Si|1 2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S .
7-114:In the auction settings, we have ci = −ai .
7-115:It is easy to verify the output of the greedy algorithm is a round based output .
7-116:Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after .
7-117:This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing independence .
7-118:In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai .
7-119:Thus, for every round, it satisfies MP and the cut value is |Si|1 2 · ajr |Sjr |1 2 where jr is the bidder selected in round r if we did not consider the agent i at all .
7-120:Notice ajr |Sjr |1 2 does not increase when round r increases, so the final cut value is |Si|1 2 · aj |Sj |1 2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i .
7-121:Thus, the payment by agent i is |Si|1 2 · aj |Sj |1 2 if ai ≥ |Si|1 2 · aj |Sj |1 2 , and 0 otherwise .
7-122:This payment scheme is exactly the same as the payment scheme in [12]. .
8-1:In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game
8-2:We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist
8-3:We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time
8-4:We further presented several general composition based techniques to compute P efficiently for various allocation rules O
8-5:Several concrete examples were discussed to demonstrate our general framework for designing P and for composition based techniques of computing P in polynomial time
8-6:In this paper, we have concentrated on how to compute P in polynomial time
8-7:Our algorithms do not necessarily have the optimal running time for computing P given O
8-8:It would be of interest to design algorithms to compute P in optimal time
8-9:We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time
8-10:Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game
8-11:Many works [12, 13] in the mechanism design literature are in this direction
8-12:We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given
8-13:It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme
8-14:In this paper, we have studied mechanism design for binary demand games
8-15:However, some problems cannot be directly formulated as binary demand games
8-16:The job scheduling problem in [2] is such an example
8-17:For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner
8-18:It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non binary demand games
8-19:Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+
8-20:The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist
8-21:Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions.
9-1:A
9-2:ARCHER, C
9-3:PAPADIMITRIOU, K
9-4:T., AND TARDOS, E
9-5:An approximate truthful mechanism for combinatorial auctions with single parameter agents
9-6:In ACM SIAM SODA (2003), pp
9-7:205 214
9-8:ARCHER, A., AND TARDOS, E
9-9:Truthful mechanisms for one parameter agents
9-10:In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p
9-11:482
9-12:AULETTA, V., PRISCO, R
9-13:D., PENNA, P., AND PERSIANO, P
9-14:Deterministic truthful approximation schemes for scheduling related machines
9-15:CHVATAL, V
9-16:A greedy heuristic for the set covering problem
9-17:Mathematics of Operations Research 4, 3 (1979), 233 235
9-18:CLARKE, E
9-19:H
9-20:Multipart pricing of public goods
9-21:Public Choice (1971), 17 33
9-22:R
9-23:Muller, and R
9-24:V
9-25:Vohra
9-26:On Dominant Strategy Mechanisms
9-27:Working paper, 2003
9-28:DEVANUR, N
9-29:R., MIHAIL, M., AND VAZIRANI, V
9-30:V
9-31:Strategyproof cost sharing mechanisms for set cover and facility location games
9-32:In ACM Electronic Commerce (EC03) (2003)
9-33:FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S
9-34:Approximation and collusion in multicast cost sharing (abstract)
9-35:In ACM Economic Conference (2001)
9-36:FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S
9-37:A BGP based mechanism for lowest cost routing
9-38:In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing
9-39:(2002), pp
9-40:173 182
9-41:GREEN, J., AND LAFFONT, J
9-42:J
9-43:Characterization of satisfactory mechanisms for the revelation of preferences for public goods
9-44:Econometrica (1977), 427 438
9-45:GROVES, T
9-46:Incentives in teams
9-47:Econometrica (1973), 617 631
9-48:LEHMANN, D., OCALLAGHAN, L
9-49:I., AND SHOHAM, Y
9-50:Truth revelation in approximately efficient combinatorial auctions
9-51:Journal of ACM 49, 5 (2002), 577 602
9-52:MU"ALEM, A., AND NISAN, N
9-53:Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract
9-54:In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp
9-55:379 384
9-56:NISAN, N., AND RONEN, A
9-57:Algorithmic mechanism design
9-58:In Proc
9-59:31st Annual ACM STOC (1999), pp
9-60:129 140
9-61:E
9-62:Halperin
9-63:Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs
9-64:In Proceedings of the 11th Annual ACM SIAM Symposium on Discrete Algorithms, pages 329 337, 2000
9-65:R
9-66:Bar Yehuda and S
9-67:Even
9-68:A local ratio theorem for approximating the weighted vertex cover problem
9-69:Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27 46, 1985
9-70:Editor: G
9-71:Ausiello and M
9-72:Lucertini ROBINS, G., AND ZELIKOVSKY, A
9-73:Improved steiner tree approximation in graphs
9-74:In Proceedings of the 11th annual ACM SIAM SODA (2000), pp
9-75:770 779
9-76:A
9-77:Zelikovsky
9-78:An 11 6 approximation algorithm for the network Steiner problem
9-79:Algorithmica, 9(5):463 470, 1993
9-80:D
9-81:S
9-82:Hochbaum
9-83:Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243 254, 1983
9-84:TAKAHASHI, H., AND MATSUYAMA, A
9-85:An approximate solution for the steiner problem in graphs
9-86:Math
9-87:Japonica 24 (1980), 573 577
9-88:VICKREY, W
9-89:Counterspeculation, auctions and competitive sealed tenders
9-90:Journal of Finance (1961), 8 37
9-91:WANG, W., AND LI, X. Y
9-92:Truthful low cost unicast in selfish wireless networks
9-93:In 4th IEEE Transactions on Mobile Computing (2005), to appear
9-94:WANG, W., LI, X. Y., AND SUN, Z
9-95:Design multicast protocols for non cooperative networks
9-96:IEEE INFOCOM 2005, to appear
9-97:WANG, W., LI, X. Y., AND WANG, Y
9-98:Truthful multicast in selfish wireless networks
9-99:ACM MobiCom, 2005
9-100:222
picture:
