Operational Semantics of Multiagent Interactions 
content:
1 ABSTRACT :
1-1:The social stance advocated by institutional frameworks and most multi agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms .
1-2:Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre defined abstractions .
1-3:The main hypothesis motivating this paper is that the variety of multi agent interaction mechanisms both, organizational and communicative, share a common semantic core .
1-4:In the realm of software architectures, the paper proposes a connector based model of multi agent interactions which attempts to identify the essential structure underlying multi agent interactions .
1-5:Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions .
1-6:The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms .
1-7:I.2.11 [Artificial Intelligence]: Distributed Artificial .
2 INTRODUCTION :
2-1:The suitability of agent based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15] .
2-2:Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi agent system methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components .
2-3:This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS .
2-4:This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc.), which leverage multi agent middlewares built upon raw ACL based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages .
2-5:Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre defined abstractions .
2-6:The main hypothesis motivating this paper is that the variety of multi agent interaction mechanisms both, organizational and communicative, share a common semantic core .
2-7:This paper thus focuses on the fundamental building blocks of multi agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions .
2-8:Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent based computing: autonomy, situatedness and sociality [26] .
2-9:To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17] .
2-10:The outcome of this analysis will be a connector based model of multi agent interactions between autonomous social and situated components, i.e .
2-11:agents, attempting to identify their essential structure .
2-12:Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi agent (or social) interactions .
2-13:Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose .
2-14:The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced .
2-15:Next, the dynamics of social interactions will show how these entities and relationships evolve .
2-16:Last, relevant work in the literature is discussed 889 978 81 904262 7 5 c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. .
3 SOCIAL INTERACTION STRUCTURE :
3-1:From an architectural point of view, interactions between software components are embodied in software connectors: first class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1] .
3-2:The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector .
3-3:The attachment operation binds a component to the role of a given connector .
3-4:The analysis of social interactions introduced in this section gives rise to a new kind of social connector .
3-5:It refines the generic model in several respects, attending to the features commonly ascribed to agent based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e .
3-6:role) in a social interaction, so called agents .
3-7:Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 .
3-8:• A second group of participants, so called environmental resources, may be identified from the situatedness feature .
3-9:Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction .
3-10:Moreover, the participation of resources in an interaction is not mandatory .
3-11:• Last, according to the sociality of agents, the specification of social connector protocols the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23] .
3-12:Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources .
3-13:In the following, we describe the basic entities involved in social interactions .
3-14:Each kind of entity T will be specified as a record type T l1 : T1, .
3-15:.
3-16:.
3-17:ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state .
3-18:Instances or values v of a record type T will be represented as v = v1, .
3-19:.
3-20:.
3-21:, vn : T .
3-22:The type SetT represents a collection of values drawn from type T .
3-23:The type QueueT represents a queue of values v : T waiting to be processed .
3-24:The value v in the expression [v| ] : Queue[T] represents the head of the queue .
3-25:The type Enum {v1, .
3-26:.
3-27:.
3-28:, vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective .
3-29:Basically, this means that software components counting as agents in a social interaction may behave non autonomously in other contexts, e.g .
3-30:in their interactions through human user interfaces .
3-31:This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB .
3-32:represents an enumeration type whose values are v1, .
3-33:.
3-34:.
3-35:, vn .
3-36:Given some value v : T, the term vl refers to the value of the field l of a record type T .
3-37:Given some labels l1, l2, .
3-38:.
3-39:.
3-40:, the expression vl1,l2,.. .
3-41:is syntactic sugar for ((vl1 )l2 ) .
3-42:.
3-43:. .
3-44:The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise .
3-45:The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses .
3-46:2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions .
3-47:Let"s consider an interaction representing a university course (e.g .
3-48:on data structures) .
3-49:On the one hand, this interaction is actually a complex one, made up of lower level interactions .
3-50:For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on .
3-51:Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions .
3-52:A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom level interactions represented by communicative actions (e.g .
3-53:request, agree, refuse, .
3-54:.
3-55:.
3-56:) .
3-57:On the other hand, courses are run within the scope of a particular degree (e.g .
3-58:computer science), a higher level interaction .
3-59:Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi agent community or agent society .
3-60:The community is thus the top level interaction which subsumes any other kind of multi agent interaction2 .
3-61:The organizational and communicative interaction types identified above clearly differ in many ways .
3-62:However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space .
3-63:Accordingly, we may specify the type I of social interactions, ranged over by the meta variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def .
3-64:: (1) icontext = i1 ⇔ i ∈ isub 1 inv .
3-65:: (2) iini = nil ⇔ icontext = nil act .
3-66:: setUp, join, create, destroy where the member and environment fields represent the agents and local resources participating in the interaction; the sub interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction .
3-67:The event channel, to be described in the next section, allows the dispatching of local events to external interactions .
3-68:The context of some interaction is defined as its super interaction (def .
3-69:1), so that the context of the toplevel interaction is nil .
3-70:The type SI Enum {open, closing, closed} represents the possible execution states of the interaction .
3-71:Any interaction, but the top level one, is set up within the context of another interaction by an initiator agent .
3-72:The initiator is 2 In the context of this application, a one to one mapping between human users and software components attached to the community as agents would be a right choice .
3-73:890 The Sixth Intl .
3-74:Joint Conf .
3-75:on Autonomous Agents and Multi Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv .
3-76:2) .
3-77:The life cycle of the interaction begins in the open state .
3-78:Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment .
3-79:Eventually, the interaction may come to an end (according to the protocol"s rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants .
3-80:The transient closing state will be described in the next section .
3-81:2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something .
3-82:The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .
3-83:The types of agents participating in a given interaction are primarily identified from their purposes .
3-84:For instance, students are those agents participating in a course who purport to obtain a certificate in the course"s subject .
3-85:Other members of the course include lecturers and teaching assistants .
3-86:The type A of agents, ranged over by meta variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def .
3-87:: (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act .
3-88:: see where the purpose is represented as a well formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise .
3-89:The context of some agent is defined as the interaction in which it participates (def .
3-90:3) .
3-91:The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent .
3-92:Its life cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi agent system (in this latter case, the player value is nil) .
3-93:The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def .
3-94:4, 5)4 .
3-95:An agent may play roles at interactions within or outside the scope of its context .
3-96:For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D .
3-97:degrees, are modelled as sub interactions of the faculty) .
3-98:Components will normally attempt to perform different actions (e.g .
3-99:to set up sub interactions) in order to satisfy their purposes within some interaction .
3-100:Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction .
3-101:Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component .
3-102:4 Free variables in the antecedents consequents of implications shall be understood as universally existentially quantified .
3-103:and the attempts of members, are subject to the rules governing the interaction .
3-104:The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events received by the agent which have not been observed yet .
3-105:An agent may update its event queue by seeing the state of some entity of the community .
3-106:The last field of the structure represents the obligations of agents, to be described later .
3-107:Eventually, the participation of some agent in the interaction will be over .
3-108:This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction .
3-109:In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise .
3-110:The transient leaving state will be described in the next section .
3-111:2.3 Resources Resources are software components which may represent different types of non autonomous informational or computational entities .
3-112:For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction .
3-113:Students may also create programs to satisfy the requirements of some assignment .
3-114:Other types of computational resources put at the disposal of students by teachers include compilers and interpreters .
3-115:The type R of resources, ranged over by meta variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def .
3-116:: (6) rcontext = i ⇔ r ∈ ienv act .
3-117:: take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting .
3-118:This means that resources are created, accessed and manipulated by agents in a social interaction context (def .
3-119:6), according to the rules specified by its protocol .
3-120:The mandatory feature creator represents the agent who created this resource .
3-121:Moreover, resources may have owners .
3-122:The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocol"s rules that govern the interaction of agents and the environment .
3-123:Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties .
3-124:For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students .
3-125:The last operations feature represents the interface of the resource, consisting of a set of operations .
3-126:A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interaction"s protocol .
3-127:The set of operations of a resource makes up its interface .
3-128:2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics .
3-129:The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols .
3-130:Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl .
3-131:Joint Conf .
3-132:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def .
3-133:: (7) pcontext = i ⇔ p = iprot inv .
3-134:: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act .
3-135:: Close, Leave We demand from protocols four major kinds of functions .
3-136:Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g .
3-137:its members, the environment, etc.) through the execution of some action (e.g .
3-138:join, create, etc.) .
3-139:Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose .
3-140:Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction .
3-141:Empowerments may only be exercised under certain circumstances that permissions specify .
3-142:Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf .
3-143:permitted field) .
3-144:For instance, the course"s protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the course"s subject, and own the certificates corresponding to its prerequisite subjects .
3-145:Permission rules, in turn, specify that those students may only join the course in the admission stage .
3-146:Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .
3-147:Secondly, protocols shall allow to determine the obligations of agents towards the interaction .
3-148:Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction .
3-149:These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked .
3-150:The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated .
3-151:Moreover, it returns for each agent a collection of events representing the changes in the obligation set .
3-152:For instance, the course"s protocol establishes that members of departments must join the course as teachers whenever they are assigned to the course"s subject .
3-153:Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction .
3-154:Corresponding rules shall establish the set of agents that must be awared of some event .
3-155:For instance, this func5 The formalization assumes that protocol"s functions implicitly recieve as input the interaction being regulated .
3-156:6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application dependent field of the agent structure for this kind of roles .
3-157:Similarly, the admission stage is an additional boolean field of the structure for school interactions .
3-158:The generic types I, A, R and P are thus extendable .
3-159:tionality is exploited by teachers in order to monitor the enrollment of students to the course .
3-160:Last, the protocol shall allow to control the state of the interaction as well as the states of its members .
3-161:Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over .
3-162:Thus, the function field finish returns true if the regulated interaction must finish its execution .
3-163:If so happens, a well defined set of protocols must ensure that its sub interactions and members are finished as well (inv .
3-164:8,9) .
3-165:Similarly, the function over returns true if the participation of the specified member must be over .
3-166:Well formed protocols must ensure the consistency between these functions across playing roles (inv .
3-167:10)7 .
3-168:For instance, the course"s protocol establishes that the participation of students is over when they gain ownership of the course"s certificate or the chances to get it are exhausted .
3-169:It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. .
4 SOCIAL INTERACTION DYNAMICS :
4-1:The dynamics of the multi agent community is influenced by the external actions executed by software components and the protocols governing their interactions .
4-2:This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action .
4-3:The description of other external actions concerning agents (e.g .
4-4:observe the events from its event queue, enter or exit from the community) and resources (e.g .
4-5:a timer resource may signal the pass of time) will be skipped .
4-6:The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub interactions .
4-7:These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members .
4-8:This section will also describe the way in which these events are processed .
4-9:The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously .
4-10:Due to lack of space, we only include some of the operational rules that formalise the execution semantics .
4-11:3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action .
4-12:This action is intended to alter the state of some target interaction (possibly, the performer"s context itself), and notify a collection of addressees of the changes resulting from a successful execution .
4-13:Accordingly, the type ACT of actions, ranged over by meta variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def .
4-14:: (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section .
4-15:Additional actions, such as permit, forbid, empower, etc., to update other protocol"s fields are yet to be identified in future work .
4-16:892 The Sixth Intl .
4-17:Joint Conf .
4-18:on Autonomous Agents and Multi Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing .
4-19:This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel .
4-20:3.1.1 Empowerment checking The post condition of an attempt consists of inserting the action in the queue of attempts of the specified performer .
4-21:As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction .
4-22:If this condition is not met, the attempt will simply be ignored .
4-23:Moreover, the performer agent must be in the playing state (this pre condition is also required for any rule concerning the processing of attempts) .
4-24:If these pre conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage .
4-25:For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked .
4-26:If the (degree) student has passed the course"s prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution .
4-27:αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performer"s queue of attempts are fully processed and removed from the queue .
4-28:Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub section) .
4-29:If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g .
4-30:it will be checked whether the student paid the fee for the course"s subject) .
4-31:If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2) .
4-32:Otherwise, the action is discharged and removed from the queue .
4-33:Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing .
4-34:αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications .
4-35:Moreover, note that record updates in where clauses only affect the specified fields .
4-36:3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed .
4-37:The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps .
4-38:Actions of the first kind are constructive ones such as set up and join .
4-39:The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol .
4-40:As an example of constructive action, let"s consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv .
4-41:: (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated .
4-42:Its sets of participants (agents and resources) and sub interactions must be empty (inv .
4-43:13) and its state must be open (inv .
4-44:14) .
4-45:The setting up of the new interaction may thus affect its protocol and possible application dependent fields (e.g .
4-46:the subject of a course interaction) .
4-47:According to rule 3, the outcome of the execution is threefold: firstly, the performer"s attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the target"s set of sub interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the target"s event channel .
4-48:αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Let"s consider now the case of a close action .
4-49:This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function) .
4-50:The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .
4-51:Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv .
4-52:: (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field .
4-53:10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc .
4-54:The Sixth Intl .
4-55:Joint Conf .
4-56:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 893 update field represents a proper higher order function to update the target"s protocol (inv .
4-57:17) .
4-58:The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port .
4-59:This event will actually trigger the closing process of the interaction as described in the next subsection .
4-60:αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions .
4-61:Channels, ranged over by meta variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv .
4-62:: (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channel"s interaction .
4-63:Its first purpose is to dispatch the local events to the agents identified by the protocol"s monitoring function .
4-64:Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function whose invariants will be explained later on .
4-65:Thus, input ports serve as a coordination mechanism which activate the re evaluation of the above functios whenever some event is received11 .
4-66:Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update .
4-67:The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched .
4-68:3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched .
4-69:As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi agent community .
4-70:In this scenario, interactions would trigger themselves without requiring any explicit notification .
4-71:On the contrary, we adhere to the more realistic assumption of limited awareness .
4-72:with the returned values of the dispatching and protocol"s monitoring functions, respectively (rule 5) .
4-73:Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty) .
4-74:Last, the event is removed from the queue and the auxiliary fields are re set to nil .
4-75:The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channel"s interaction itself)12 .
4-76:For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the school"s degrees .
4-77:Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action .
4-78:Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the course"s teachers and itself will also be notified of the successful execution .
4-79:ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received .
4-80:Irrespective of the kind of incoming event, the first processing action is to check whether the channel"s interaction must be finished .
4-81:Thus, the dispatching of the finish event resulting from a close action (inv .
4-82:18) serves as a trigger of the closing procedure .
4-83:If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members .
4-84:Otherwise, we can consider two possible scenarios .
4-85:In the first one, the interaction has no members and no sub interactions .
4-86:In this case, the interaction can be inmediately closed down .
4-87:As rule 6 shows, the interaction is closed, removed from the context"s set of sub interactions and a closed event is inserted in its output channel .
4-88:According to invariant 22, this event will be later inserted to its input channel to allow for further treatment .
4-89:cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub interaction .
4-90:In this case, clean up is required prior to the disposal of the interaction (e.g .
4-91:if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself) .
4-92:As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port .
4-93:According to invariant 20, the closing event will be dispatched to every sub interaction in order to activate its closing procedure (guaranteed by invariant 8) .
4-94:Moreover, 12 This is essentially determined by the protocol rules of these interactions .
4-95:The way in which the dispatching function is initialised and updated is out of the scope of this paper .
4-96:894 The Sixth Intl .
4-97:Joint Conf .
4-98:on Autonomous Agents and Multi Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage .
4-99:This stage will further initiate the leaving process of the members (according to invariant 9) .
4-100:cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub interaction will be closed .
4-101:Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold .
4-102:3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocol"s over function .
4-103:When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocol"s obligation update function .
4-104:If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose) .
4-105:The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv .
4-106:23) .
4-107:Otherwise, the member enters the transient leaving state, thus preventing any action performance .
4-108:Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv .
4-109:21) .
4-110:3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly .
4-111:When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update .
4-112:For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member .
4-113:Moreover, the event representing this change is added to the output channel of the department interaction. .
5 DISCUSSION :
5-1:This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components .
5-2:In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions) .
5-3:Thus, top level interactions may represent the kind of agent web pursued by large scale initiatives such as the Agentcities openNet one [25] .
5-4:Large scale interactions, modelling complex aggregates of agent interactions such as those represented by e institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first level social interactions .
5-5:The last levels of the interaction tree may represent small scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2] .
5-6:Finally, bottom level interactions may represent communicative actions .
5-7:From this perspective, the member types of a CA include the speaker and possibly many listeners .
5-8:The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA .
5-9:The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi agent systems [2, 26, 10, 7] and the normative perspective on multi agent protocols [12, 23, 20] .
5-10:These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi agent interactions .
5-11:Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3] .
5-12:Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6] .
5-13:These analyses shall result in new organizational and communicative abstractions obtained through a refinement and or extension of the general model of social interactions .
5-14:Thus, the proposed model is not intended to capture every organizational or communicative feature of multi agent interactions, but to reveal their roots in basic interaction mechanisms .
5-15:In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols .
5-16:Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions .
5-17:We argue that the current field of multi agent system programming may greatly benefit from multi agent programming languages that allow programmers to accommodate an open set of interaction mechanisms .
5-18:The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type .
5-19:This abstract machine would be independent of particular agent architectures and languages (i.e .
5-20:software components may be programmed in a BDI language such as Jason [5] or in a non agent oriented language) .
5-21:On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services .
5-22:We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl .
5-23:Joint Conf .
5-24:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms .
5-25:In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g .
5-26:prohibitions) and defaults play in this domain. .
6-1:The authors thank anonymous reviewers for their comments and suggestions
6-2:Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455 C03 03.
7-1:R
7-2:Allen and D
7-3:Garlan
7-4:A Formal Basis for Architectural Connection
7-5:ACM Transactions on Software Engineering and Methodology, 6(3):213 249, June 1997
7-6:J
7-7:L
7-8:Arcos, M
7-9:Esteva, P
7-10:Noriega, J
7-11:A
7-12:Rodr´ıguez, and C
7-13:Sierra
7-14:Engineering open environments with electronic institutions
7-15:Journal on Engineering Applications of Artificial Intelligence, 18(2):191 204, 2005
7-16:G
7-17:Boella, R
7-18:Damiano, J
7-19:Hulstijn, and L
7-20:W
7-21:N
7-22:van der Torre
7-23:Role based semantics for agent communication: embedding of the "mental attitudes" and "social commitments" semantics
7-24:In AAMAS, pages 688 690, 2006
7-25:R
7-26:H
7-27:Bordini, L
7-28:Braubach, M
7-29:Dastani, A
7-30:E
7-31:F
7-32:Seghrouchni, J
7-33:J
7-34:G
7-35:Sanz, J
7-36:Leite, G
7-37:O"Hare, A
7-38:Pokahr, and A
7-39:Ricci
7-40:A survey of programming languages and platforms for multi agent systems
7-41:Informatica, 30:33 44, 2006
7-42:R
7-43:H
7-44:Bordini, J
7-45:F
7-46:H¨ubner, and R
7-47:Vieira
7-48:Jason and the golden fleece of agent oriented programming
7-49:In
picture:
