A Complete Distributed Constraint Optimization Method 
content:
1 ABSTRACT :
1-1:Distributed Constraint Optimization is a general framework that can model complex problems in multi agent systems .
1-2:Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure .
1-3:We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements .
1-4:Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches .
1-5:The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP .
1-6:We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm .
1-7:We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge traversal heuristics that will outperform a cross edged pseudotree .
1-8:We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space time complexity .
1-9:For some problem instances we observe significant improvements in message and computation sizes compared to DPOP .
1-10:I.2.11 [Artificial Intelligence]: Distributed Artificial .
2 INTRODUCTION :
2-1:Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems .
2-2:With the advent of distributed AI, multi agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems .
2-3:CSPs were originally extended to distributed agent environments in [9] .
2-4:Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2] .
2-5:Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint .
2-6:Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi valued utility functions .
2-7:Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility .
2-8:This extension to the original DisCSP approach has become popular in multi agent systems, and has been labeled the Distributed Constraint Optimization Problem [1] .
2-9:Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming .
2-10:Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3] .
2-11:Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7] .
2-12:To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem .
2-13:It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree .
2-14:However, it was also shown that finding the optimal pseudotree was NP Hard .
2-15:We began to investigate the performance of traditional pseudotrees generated by current edge traversal heuristics .
2-16:We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors .
2-17:We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes .
2-18:After exploring these other arrangements we found that cross edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees .
2-19:Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types .
2-20:In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross edged pseudotrees .
2-21:We begin with a definition of 741 978 81 904262 7 5 c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross edged pseudotrees .
2-22:We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm .
2-23:We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics .
2-24:We then show that our Distributed Cross edged Pseudotree Optimization Procedure performs significantly better in practice than the original DPOP algorithm for some problem instances .
2-25:We conclude with a selection of ideas for future work and extensions for DCPOP. .
3 PROBLEM DEFINITION :
3-1:DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6] .
3-2:A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal .
3-3:Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities .
3-4:The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values .
3-5:For this paper we only consider binary utility functions involving two variables .
3-6:Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity .
3-7:2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches .
3-8:As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T .
3-9:A back edge is an edge between a node X and any node which lies on the path from X to the root (excluding X"s parent) .
3-10:Figure 1 shows a pseudotree with four nodes, three edges (A B, B C, BD), and one back edge (A C) .
3-11:Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) the pseudo parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back edges (In Figure 1, A = PP(C)) • PC(X) the pseudo children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree .
3-12:Solid line edges represent parent child relationships and the dashed line represents a pseudo parent pseudo child relationship .
3-13:Figure 2: A cross edged pseudotree .
3-14:Solid line edges represent parent child relationships, the dashed line represents a pseudoparent pseudo child relationship, and the dotted line represents a branch parent branch child relationship .
3-15:The bolded node, B, is the merge point for node E .
3-16:2.2 Cross edged Pseudotrees We define a cross edge as an edge from node X to a node Y that is above X but not in the path from X to the root .
3-17:A cross edged pseudotree is a traditional pseudotree with the addition of cross edges .
3-18:Figure 2 shows a cross edged pseudotree with a cross edge (D E) .
3-19:In a cross edged pseudotree we designate certain edges as primary .
3-20:The set of primary edges defines a spanning tree of the nodes .
3-21:The parent, child, pseudo parent, and pseudo child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree .
3-22:This definition also yields two additional types of relationships that may exist between nodes: • BP(X) the branch parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) the branch children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl .
3-23:Joint Conf .
3-24:on Autonomous Agents and Multi Agent Systems (AAMAS 07) Current algorithms usually have a pre execution phase to generate a traditional pseudotree from a general DCOP instance .
3-25:Our DCPOP algorithm generates a cross edged pseudotree in the same fashion .
3-26:First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U .
3-27:Next, various heuristics are used to arrange this graph into a pseudotree .
3-28:One common heuristic is to perform a guided depth first search as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion .
3-29:We define an edge traversal based method as any method that produces a pseudotree in which all parent child pairs share an edge in the original graph .
3-30:This includes DFS, breadth first search, and best first search based traversals .
3-31:Our heuristics that generate cross edged pseudotrees use a distributed best first search traversal. .
4 DPOP ALGORITHM :
4-1:The original DPOP algorithm operates in three main phases .
4-2:The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm .
4-3:The second phase joins utility hypercubes from children and the local node and propagates them towards the root .
4-4:The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node .
4-5:The complexity of DPOP depends on the size of the largest computation and utility message during phase two .
4-6:It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6] .
4-7:DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP hard .
4-8:Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8] .
4-9:At the end of the first phase, each agent knows its parent, children, pseudo parents, and pseudo children .
4-10:3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube .
4-11:This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X) .
4-12:This hypercube has dimensional size equal to the number of pseudo parents plus one .
4-13:A message containing this hypercube is sent to P(X) .
4-14:Agents located at non leaf nodes wait for all messages from children to arrive .
4-15:Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y .
4-16:The local utility hypercube is then joined with all of the hypercubes from the child messages .
4-17:At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube .
4-18:This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains .
4-19:A message containing this hypercube is now sent to P(Y) .
4-20:The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube .
4-21:This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children .
4-22:3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children .
4-23:Since Z has no parents or pseudo parents, it simply combines the utility hypercubes received from its children .
4-24:The combined hypercube contains only values for the domain for Z .
4-25:At this point the agent at node Z simply chooses the assignment for its domain that has the best utility .
4-26:A value propagation message with this assignment is sent to each node in C(Z) .
4-27:Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message .
4-28:The node adds its domain assignment to the assignments it received and passes the set of assignments to its children .
4-29:The algorithm is complete when all nodes have chosen an assignment for their domain. .
5 DCPOP ALGORITHM :
5-1:Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases .
5-2:The first phase generates the cross edged pseudotree for the DCOP instance .
5-3:The second phase merges branches and propagates the utility hypercubes .
5-4:The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node .
5-5:For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity .
5-6:The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross edged pseudotree .
5-7:Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross edged pseudotree .
5-8:A description of this method and the pseudotree selection process appears in Section 5 .
5-9:At the end of the first phase, each agent knows its parent, children, pseudo parents, pseudo children, branch parents, and branch children .
5-10:4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo parents .
5-11:In DCPOP, a node X is allowed to have a utility function involving a branch parent .
5-12:The concept of a branch can be seen in Figure 2 with node E representing our node X .
5-13:The two distinct paths from node E to node B are called branches of E .
5-14:The single node where all branches of E meet is node B, which is called the merge point of E .
5-15:Agents with nodes that have branch parents begin by sending a utility propagation message to each branch parent .
5-16:This message includes a two dimensional utility hypercube with domains for the node X and the branch parent BP(X) .
5-17:It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1) .
5-18:Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X .
5-19:In Figure 2, node E sends a utility propagation message to its branch parent, node D .
5-20:This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch .
5-21:As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent .
5-22:In DCPOP this message contains dimensions for the domains of P(X) and PP(X) .
5-23:If node X also has branch parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure .
5-24:In Figure 2, node E sends a utility propagation message to its parent, node C .
5-25:This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch .
5-26:When a node Y receives utility propagation messages from all of The Sixth Intl .
5-27:Joint Conf .
5-28:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 743 its children and branch children, it merges any branches with the same origination node X .
5-29:The merged branch information structure accumulates the number of merged branches for X .
5-30:If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X .
5-31:This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X .
5-32:In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes .
5-33:To illustrate this process, we will examine what happens in the second phase for node B in Figure 2 .
5-34:In the second phase Node B receives two utility propagation messages .
5-35:The first comes from node C and includes dimensions for domains E, B, and A .
5-36:It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch .
5-37:The second comes from node D and includes dimensions for domains E and B .
5-38:It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch .
5-39:Node B then merges the branch information structures from both messages because they have the same origination, node E .
5-40:Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E .
5-41:Node B also eliminates the dimension for its own domain, leaving only information about domain A .
5-42:Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A .
5-43:Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains .
5-44:In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y .
5-45:This lazy approach to joins helps to reduce message sizes .
5-46:4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children .
5-47:At this point the agent at node Z chooses the assignment for its domain that has the best utility .
5-48:If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X .
5-49:Thus any node that is a merge point will choose assignments for a domain other than its own .
5-50:These assignments are then passed down the primary edge hierarchy .
5-51:If node X in the hierarchy has branch parents, then the value assignment message from P(X) will contain an assignment for the domain of X .
5-52:Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children .
5-53:The algorithm is complete when all nodes have chosen or received an assignment for their domain .
5-54:4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP .
5-55:Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP .
5-56:Using a traditional pseudotree arrangement no nodes have branch parents or branch children since all edges are either back edges or tree edges .
5-57:Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo parents of a node .
5-58:Since no node has any branch parents, no branches exist, and thus no node serves as a merge point for any other node .
5-59:Thus all value propagation assignments are chosen at the node of the assignment domain .
5-60:For DCPOP execution with cross edged pseudotrees, some nodes serve as merge points .
5-61:We note that any node X that is not a merge point assigns its value exactly as in DPOP .
5-62:The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X) .
5-63:As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X) .
5-64:Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X) .
5-65:Thus after eliminating domains for which assignments are known, only the domain of X is left .
5-66:The agent at node X can now correctly choose the assignment with maximum utility for its own domain .
5-67:If node X is a merge point for some branch child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root .
5-68:From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages .
5-69:Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree .
5-70:For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X) .
5-71:Thus X has utility information about all of the utility functions of which Y is a part .
5-72:By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and with maximum utility for the domains of X and Y .
5-73:4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X) .
5-74:The second phase sends one value assignment message to each C(X) .
5-75:Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross edged pseudotree and the original DCOP instance .
5-76:The actual complexity of DCPOP depends on two additional measurements: message size and computation size .
5-77:Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back edges .
5-78:It was shown in [6] that the number of overlapping back edges is equal to the induced width of the pseudotree .
5-79:In a poorly constructed cross edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X .
5-80:Thus, the total message size in DCPOP in a poorly constructed instance can be space exponential in the total number of nodes in the graph .
5-81:However, in practice a well constructed cross edged pseudotree can achieve much better results .
5-82:Later we address the issue of choosing well constructed crossedged pseudotrees from a set .
5-83:We introduce an additional measurement of the maximum sequential path cost through the algorithm .
5-84:This measurement directly relates to the maximum amount of parallelism achievable by the algorithm .
5-85:To take this measurement we first store the total computation size for each node during phase two and three .
5-86:This computation size represents the number of individual accesses to a value in a hypercube at each node .
5-87:For example, a join between two domains of size 4 costs 4 ∗ 4 = 16 .
5-88:Two directed acyclic graphs can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes .
5-89:The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. .
6 HEURISTICS :
6-1:In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm .
6-2:We acknowledge 744 The Sixth Intl .
6-3:Joint Conf .
6-4:on Autonomous Agents and Multi Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e .
6-5:Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance .
6-6:The problem of finding the best pseudotree for a given DCOP instance is NP Hard .
6-7:Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic .
6-8:Some previous research focused on finding heuristics to generate good pseudotrees [8] .
6-9:While we have developed some heuristics that generate good cross edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees .
6-10:We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance .
6-11:The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross edged pseudotree in linear space time complexity .
6-12:To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments .
6-13:Instead, messages include dimensional and branch information but no utility hypercubes .
6-14:After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree .
6-15:The root then broadcasts the total complexity for that heuristic to all nodes .
6-16:After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree .
6-17:Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic .
6-18:The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal .
6-19:The general distributed algorithm uses a token passing mechanism and a linear number of messages .
6-20:Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion .
6-21:The DFS based heuristics used in our experiments come from the work done in [4, 8] .
6-22:5.1 The best first cross edged pseudotree heuristic The heuristics used to generate cross edged pseudotrees perform a best first traversal .
6-23:A general distributed best first algorithm for node expansion is presented in Algorithm 2 .
6-24:An evaluation function at each node provides the values that are used to determine the next best node to expand .
6-25:Note that in this algorithm each node only exchanges its best value with its neighbors .
6-26:In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbor"s placement depth in the tree if it was placed) .
6-27:From these we can calculate branchparents, branch children, and unknown relationships for a potential node placement .
6-28:The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak .
6-29:After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo parents, branchparents, pseudo children, and branch children .
6-30:The complexity of the best first traversal depends on the complexity of the evaluation function .
6-31:Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best first traversal is O(V · E) which is at worst O(n3 next node to place using the getBestNeighbor operation .
6-32:The place operation is at most O(V ) because of the sent messages .
6-33:Finding the next node uses recursion and traverses only already placed The Sixth Intl .
6-34:Joint Conf .
6-35:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions .
6-36:Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors .
6-37:This operation is O(V · E), but results can be cached using only O(V ) space at each node .
6-38:Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E) .
6-39:If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E) .
6-40:This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E) .
6-41:Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). .
7 COMPARISON OF COMPLEXITY IN DPOP AND DCPOP :
7-1:DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP .
7-2:We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity .
7-3:If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space time complexity .
7-4:We will now show that there exists a DCOP instance for which a cross edged pseudotree outperforms all possible traditional pseudotrees (based on edge traversal heuristics) .
7-5:In Figure 3(a) we have a DCOP instance with six nodes .
7-6:This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross edged pseudotree arrangement for the DCOP instance partition .
7-7:In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance .
7-8:It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession .
7-9:We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree .
7-10:Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b) .
7-11:We can see that the back edges F B and F A overlap node C .
7-12:Node C also has a parent E, and a back edge with D .
7-13:Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E .
7-14:In contrast, the cross edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP .
7-15:Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches .
7-16:In addition each of these nodes has node A as its parent .
7-17:Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F) .
7-18:Since no better traditional pseudotree arrangement can be created using an edge traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge traversal .
7-19:We acknowledge that pseudotree arrangements that allow parent child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains .
7-20:However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint .
7-21:Also, while we do not prove it here, cross edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar .
7-22:In practice, since finding the best pseudotree arrangement is NP Hard, we find that heuristics that produce cross edged pseudotrees often produce significantly smaller computation and message sizes. .
8 EXPERIMENTAL RESULTS :
8-1:746 The Sixth Intl .
8-2:Joint Conf .
8-3:on Autonomous Agents and Multi Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size .
8-4:We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance .
8-5:We also introduced the maximum sequential path cost as a measurement of the maximum amount of parallelism achievable by the algorithm .
8-6:The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node .
8-7:We also include as metrics the maximum computation size in number of dimensions and maximum message size in number of dimensions .
8-8:To analyze the relative complexity of a given DCOP instance, we find the minimum induced width of any traditional pseudotree produced by a heuristic for the original DPOP .
8-9:7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each .
8-10:Each problem was generated by assigning a random number (picked from a range) of constraints to each variable .
8-11:The generator then created binary constraints until each variable reached its maximum number of constraints .
8-12:The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5 .
8-13:The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3 .
8-14:Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem .
8-15:Results are shown for the first set in Table 1 and for the second set in Table 2 .
8-16:For the two problem sets we split the cases into low density and high density categories .
8-17:Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g .
8-18:IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems) .
8-19:High density problems consist of the remainder of the problem sets .
8-20:In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross edged pseudotrees (DCPOP CE), and the DCPOP algorithm using traditional and cross edged pseudotrees (DCPOP All) .
8-21:The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC .
8-22:These are all versions of the guided DFS traversal discussed in Section 5 .
8-23:The cross edged pseudotrees used for DCPOP CE were generated using 5 heuristics: MCN, LCN, MCN A B, LCN A B, and LCSG A B .
8-24:These are all versions of the best first traversal discussed in Section 5 .
8-25:For both DPOP and DCPOP CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set .
8-26:For DCPOP All we chose the best pseudotree produced by all 10 heuristics for each problem in the set .
8-27:For the CD and MD metrics the value shown is the average number of dimensions .
8-28:For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem) .
8-29:The final row in both tables is a measurement of improvement of DCPOP All over DPOP .
8-30:For the CD and MD metrics the value shown is a reduction in number of dimensions .
8-31:For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100) .
8-32:Notice that DCPOPAll outperforms DPOP on all metrics .
8-33:This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP .
8-34:Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl .
8-35:Joint Conf .
8-36:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 0.01 0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP .
8-37:Another trend we notice is that the improvement is greater for high density problems than low density problems .
8-38:We show this trend in greater detail in Figures 4, 5, and 6 .
8-39:Notice how the improvement increases as the complexity of the problem increases .
8-40:7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem as described in [6] .
8-41:The problem setup includes a number of people that are grouped into departments .
8-42:Each person must attend a specified number of meetings .
8-43:Meetings can be held within departments or among departments, and can be assigned to one of eight time slots .
8-44:The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting .
8-45:All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot .
8-46:All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot .
8-47:Unary constraints are placed on each variable to account for a person"s valuation of each meeting and time slot .
8-48:For our tests we generated 100 sample problems for each combination of agents and meetings .
8-49:Results are shown in Table 3 .
8-50:The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree .
8-51:The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP All over DPOP .
8-52:Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. .
9-1:We presented a complete, distributed algorithm that solves general DCOP instances using cross edged pseudotree arrangements
9-2:Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase
9-3:Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes
9-4:We have shown that DCPOP fully extends DPOP by performing the same operations given the same input
9-5:We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross edged pseudotrees
9-6:We placed particular emphasis on the role that edge traversal heuristics play in the generation of pseudotrees
9-7:We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space time complexity
9-8:Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees
9-9:Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP.
10-1:J
10-2:Liu and K
10-3:P
10-4:Sycara
10-5:Exploiting problem structure for distributed constraint optimization
10-6:In V
10-7:Lesser, editor, Proceedings of the First International Conference on Multi Agent Systems, pages 246 254, San Francisco, CA, 1995
10-8:MIT Press
10-9:P
10-10:J
10-11:Modi, H
10-12:Jung, M
10-13:Tambe, W. M
10-14:Shen, and S
10-15:Kulkarni
10-16:A dynamic distributed constraint satisfaction approach to resource allocation
10-17:Lecture Notes in Computer Science, 2239:685 700, 2001
10-18:P
10-19:J
10-20:Modi, W
10-21:Shen, M
10-22:Tambe, and M
10-23:Yokoo
10-24:An asynchronous complete method for distributed constraint optimization
10-25:In AAMAS 03, 2003
10-26:A
10-27:Petcu
10-28:Frodo: A framework for open distributed constraint optimization
10-29:Technical Report No
10-30:2006 001 2006 001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006
10-31:http:  liawww.epfl.ch frodo
10-32:A
10-33:Petcu and B
10-34:Faltings
10-35:A dpop: Approximations in distributed optimization
10-36:In poster in CP 2005, pages 802 806, Sitges, Spain, October 2005
10-37:A
10-38:Petcu and B
10-39:Faltings
10-40:Dpop: A scalable method for multiagent constraint optimization
10-41:In IJCAI 05, pages 266 271, Edinburgh, Scotland, Aug 2005
10-42:A
10-43:Petcu, B
10-44:Faltings, and D
10-45:Parkes
10-46:M dpop: Faithful distributed implementation of efficient social choice problems
10-47:In AAMAS 06, pages 1397 1404, Hakodate, Japan, May 2006
10-48:G
10-49:Ushakov
10-50:Solving meeting scheduling problems using distributed pseudotree optimization procedure
10-51:Master"s thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005
10-52:M
10-53:Yokoo, E
10-54:H
10-55:Durfee, T
10-56:Ishida, and K
10-57:Kuwabara
10-58:Distributed constraint satisfaction for formalizing distributed problem solving
10-59:In International Conference on Distributed Computing Systems, pages 614 621, 1992
10-60:M
10-61:Yokoo, E
10-62:H
10-63:Durfee, T
10-64:Ishida, and K
10-65:Kuwabara
10-66:The distributed constraint satisfaction problem: Formalization and algorithms
10-67:Knowledge and Data Engineering, 10(5):673 685, 1998
10-68:748 The Sixth Intl
10-69:Joint Conf
10-70:on Autonomous Agents and Multi Agent Systems (AAMAS 07)
picture:
