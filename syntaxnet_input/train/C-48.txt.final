Multi-dimensional Range Queries in Sensor Networks∗ 
content:
1 ABSTRACT :
1-1:In many sensor networks, data or events are named by attributes .
1-2:Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query .
1-3:An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15 .
1-4:Such queries are useful for correlating events occurring within the network .
1-5:In this paper, we describe the design of a distributed index that scalably supports multi dimensional range queries .
1-6:Our distributed index for multi dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm .
1-7:Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)) .
1-8:In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network .
1-9:Finally, experiments on a small scale testbed validate the feasibility of DIMs .
1-10:C.2.4 [Computer Communication Networks]: Distributed .
2 INTRODUCTION :
2-1:In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3] .
2-2:Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc .
2-3:In these systems, we argue, one natural way to query for events of interest will be to use multi dimensional range queries on these attributes .
2-4:For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20 .
2-5:Such range queries can be used in two distinct ways .
2-6:They can help users efficiently drill down their search for events of interest .
2-7:The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro organisms .
2-8:More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions .
2-9:For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras .
2-10:In traditional database systems, such range queries are supported using pre computed indices .
2-11:Indices trade off some initial pre computation cost to achieve a significantly more efficient querying capability .
2-12:For sensor networks, we assert that a centralized index for multi dimensional range queries may not be feasible for energy efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network) .
2-13:Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi dimensional range queries .
2-14:In this paper, we present just such a data structure, that we call a DIM1 .
2-15:DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network .
2-16:DIMs leverage two key ideas: in network 1 Distributed Index for Multi dimensional data .
2-17:63 data centric storage, and a novel locality preserving geographic hash (Section 3) .
2-18:DIMs trace their lineage to datacentric storage systems [23] .
2-19:The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events .
2-20:Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes .
2-21:DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion .
2-22:We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3) .
2-23:We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6) .
2-24:Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)) .
2-25:In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network .
2-26:Experiments on a small scale testbed validate the feasibility of DIMs (Section 6) .
2-27:Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity .
2-28:We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks .
2-29:DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact match queries [23], or continuous queries [15, 18] .
2-30:All such systems will likely be integrated to a sensor network database system such as TinyDB [17] .
2-31:Application designers could then choose the appropriate method of information access .
2-32:For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio temporal progress of the hotspots .
2-33:Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. .
3 RELATED WORK :
3-1:The basic problem that this paper addresses multidimensional range queries is typically solved in database systems using indexing techniques .
3-2:The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature .
3-3:Indexing techniques essentially trade off some data insertion cost to enable efficient querying .
3-4:Indexing has, for long, been a classical research problem in the database community [5, 2] .
3-5:Our work draws its inspiration from the class of multi key constant branching index structures, exemplified by k d trees [2], where k represents the dimensionality of the data space .
3-6:Our approach essentially represents a geographic embedding of such structures in a sensor field .
3-7:There is one important difference .
3-8:The classical indexing structures are data dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]) .
3-9:The index structure is decided not only by the data, but also by the order in which data is inserted .
3-10:Our current design is not data dependent .
3-11:Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11] .
3-12:While there has been some work on distributed indexing, the problem has not been extensively explored .
3-13:There exist distributed indices of a restricted kind those that allow exact match or partial prefix match queries .
3-14:Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table systems exemplified by Freenet[4], Chord[24], and CAN[19] .
3-15:Our work is superficially similar to CAN in that both construct a zone based overlay atop of the underlying physical network .
3-16:The underlying details make the two systems very different: CAN"s overlay is purely logical while our overlay is consistent with the underlying physical topology .
3-17:More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context .
3-18:Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17] .
3-19:Our work is similar in spirit to this body of literature .
3-20:In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17] .
3-21:Our work departs from prior work in this area in two significant respects .
3-22:Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations .
3-23:This hashing is the key to scaling multi dimensional range searches .
3-24:In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system .
3-25:Our work avoids query flooding by an appropriate choice of hashing .
3-26:Madden et al .
3-27:[17] also describe a distributed index, called Semantic Routing Trees .
3-28:This index is used to direct queries to nodes that have detected relevant data .
3-29:Our work differs from SRT in three key aspects .
3-30:First, SRT is built on single attributes while DIM supports mulitple attributes .
3-31:Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values .
3-32:Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node .
3-33:A similar differentiation applies with respect to work on data centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25] .
3-34:These approaches work well for relatively long lived queries .
3-35:Finally, our work is most close related to data centric storage [23] systems, which include geographic hash tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous .
3-36:GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location .
3-37:We also leverage properties in GPSR (as we describe later), but we use a locality preserving hash to store data, enabling efficient multi dimensional range queries .
3-38:DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. .
4 THE DESIGN OF DIMS :
4-1:Most sensor networks are deployed to collect data from the environment .
4-2:In these networks, nodes (either individually or collaboratively) will generate events .
4-3:An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level) .
4-4:The focus of this paper is the design of systems to efficiently answer multi dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .
4-5:Such a query returns all events whose attribute values fall into the corresponding ranges .
4-6:Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries .
4-7:As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network .
4-8:It is possible to implement range queries by flooding a query within the network .
4-9:However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently .
4-10:The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries .
4-11:Shenker et al .
4-12:[23] also make similar arguments with respect to data centric storage schemes in general; DIMs are an instance of such schemes .
4-13:The system we present in this paper, the DIM, relies upon two foundations: a locality preserving geographic hash, and an underlying geographic routing scheme .
4-14:The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby .
4-15:The basic insight underlying DIM is that data locality can be obtained by a locality preserving geographic hash function .
4-16:Our geographic hash function finds a localitypreserving mapping from the multi dimensional space (described by the set of attributes) to a 2 d geographic space; this mapping is inspired by k d trees [2] and is described later .
4-17:Moreover, each node in the network self organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node .
4-18:Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries .
4-19:This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location .
4-20:The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X .
4-21:In GPSR, this is called greedy mode forwarding .
4-22:When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right hand rule to circumnavigate voids .
4-23:GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation .
4-24:For all of this to work, DIMs make two assumptions that are consistent with the literature [23] .
4-25:First, all nodes know the approximate geographic boundaries of the network .
4-26:These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol .
4-27:Second, each node knows its geographic location .
4-28:Node locations can be automatically determined by a localization system or by other means .
4-29:Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles .
4-30:We now describe the complete design of DIMs .
4-31:3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality preserving hash that maps a multi attribute event to a geographic zone .
4-32:Intuitively, a zone is a subdivision of the geographic extent of a sensor field .
4-33:A zone is defined by the following constructive procedure .
4-34:Consider a rectangle R on the x y plane .
4-35:Intuitively, R is the bounding rectangle that contains all sensors withing the network .
4-36:We call a sub rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles .
4-37:If i is an odd (even) number, the i th division is parallel to the y axis (x axis) .
4-38:That is, the bounding rectangle R is first sub divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub zones can be split into two zones at level 1 by a horizontal line, and so on .
4-39:We call the non negative integer k the level of zone Z, i.e .
4-40:level(Z) = k .
4-41:A zone can be identified either by a zone code code(Z) or by an address addr(Z) .
4-42:The code code(Z) is a 0 1 bit string of length level(Z), and is defined as follows .
4-43:If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1 .
4-44:If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1 .
4-45:The remaining bits of code(Z) are then recursively defined on each of the four quadrants of of zones given above, encoding divisions of the sensor field geography by bit strings .
4-46:Thus, in Figure 2, the zone in the top right corner of the rectangle R has a zone code of 1111 .
4-47:Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree .
4-48:The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z .
4-49:The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known .
4-50:Two zones are called sibling zones if their zone codes are the same except for the last bit .
4-51:For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones .
4-52:The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree .
4-53:We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right most zone in the sibling subtree; otherwise, the backup zone is the left most zone in the sibling subtree .
4-54:For a zone Z, let p be the first level(Z) − 1 digits of code(Z) .
4-55:Let backup(Z) be the backup zone of zone Z .
4-56:If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1"s (∗ means 0 or 1 occurrences) .
4-57:If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0"s .
4-58:3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field .
4-59:Now we describe how zones are mapped to nodes .
4-60:Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node .
4-61:If the sensor network were deployed in a grid like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level k zone .
4-62:In general, however, the node placements within a sensor field are likely to be less regular than the grid .
4-63:For some k, some zones may be empty and other zones might have more than one node situated within them .
4-64:One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest) .
4-65:Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different sized zones .
4-66:To precisely understand the associations between zones and nodes, we define the notion of zone ownership .
4-67:For any given placement of network nodes, consider a node A .
4-68:Let ZA to be the largest zone that includes only node A and no other node .
4-69:Then, we say that A owns ZA .
4-70:Notice that this definition of ownership may leave some sections of the sensor field un associated with a node .
4-71:For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner .
4-72:To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z) .
4-73:In our example, that empty zone"s owner would also be the node that owns 1110, its backup zone .
4-74:Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network? In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone .
4-75:In practice, however, communication voids and obstacles make the algorithm much more challenging .
4-76:In particular, resolving the ownership of zones that do not contain any nodes is complicated .
4-77:Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone .
4-78:Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted .
4-79:The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary) .
4-80:These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed .
4-81:We now describe the algorithm, and illustrate it using examples .
4-82:In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary .
4-83:1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries .
4-84:0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes) .
4-85:When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network .
4-86:The zone boundary algorithm now relies upon GPSR"s beacon messages to learn the locations of neighbors within radio range .
4-87:Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly .
4-88:In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A .
4-89:(Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A) .
4-90:Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors .
4-91:Figure 2 illustrates the results of applying this algorithm for the network in Figure 1 .
4-92:Figure 3 describes the corresponding zone tree .
4-93:Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1]) 2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3]) 2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A .
4-94:Insert Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send Message(c, e) Send Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← caller"s code 8 Send(m) Figure 5: Inserting an event in a DIM .
4-95:Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B) .
4-96:source(m) is used to set the source address of message m .
4-97:child by 0 and the branch to the right child by 1 .
4-98:This binary tree forms the index that we will use in the following event and query processing procedures .
4-99:We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes .
4-100:Notice that in Figure 2, there is an empty zone whose code should be 110 .
4-101:In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction .
4-102:As we have mentioned before, the undecided boundaries are resolved using GPSR"s perimeter mode when an event is inserted, or a query sent .
4-103:We describe event insertion in the next step .
4-104:Finally, this description does not describe how a node"s zone codes are adjusted when neighboring nodes fail, or new nodes come up .
4-105:We return to this in Section 3.5 .
4-106:3.3 Inserting an Event In this section, we describe how events are inserted into a DIM .
4-107:There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone .
4-108:As we shall see, these two algorithms are inter related .
4-109:3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field .
4-110:We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 .
4-111:.
4-112:.
4-113:Am .
4-114:For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node .
4-115:We will relax this assumption shortly .
4-116:Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1 .
4-117:Our hashing scheme assigns a k bit zone code to an event as follows .
4-118:For i between 1 and m, if Ai < 0.5, the i th bit of the zone code is assigned 0, else 1 .
4-119:For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1) .
4-120:We repeat this procedure until all k bits have been assigned .
4-121:As an example, consider event E = 0.3, 0.8 .
4-122:For this event, the 5 bit zone code is code(ZA) = 01110 .
4-123:Essentially, our hashing scheme uses the values of the attributes in round robin fashion on the zone tree (such as the one in Figure 3), in order to map an m attribute event to a zone code .
4-124:This is reminiscent of k d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re balancing algorithms in k d trees .
4-125:In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes .
4-126:Rather, suppose the encoding node is A and its own zone code is of length kA .
4-127:Then, given an event E, node A only hashes E to a zone code of length kA .
4-128:We denote the zone code assigned to an event E by code(E) .
4-129:As we describe below, as the event is routed, code(E) is refined by intermediate nodes .
4-130:This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination .
4-131:3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone .
4-132:We call this node the owner of the event .
4-133:Consider an event E that has just been generated at a node A .
4-134:After encoding event E, node A compares code(E) with code(A) .
4-135:If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner .
4-136:To do this, note that code(E) corresponds to some zone Z , which is A"s current guess for the zone at which event E should be stored .
4-137:A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1) .
4-138:The message contains the event E, code(E), and the target geographic location for storing the event .
4-139:In the message, A also marks itself as the owner of event E .
4-140:As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes .
4-141:GPSR now delivers this message to the next hop towards addr(Z ) from A .
4-142:This next hop node (call it B) does not immediately forward the message .
4-143:Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have .
4-144:Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings .
4-145:DIM treats NULL as an extreme value for range comparisons .
4-146:As an aside, a network may have many DIM instances running concurrently .
4-147:67 pute a new zone code for E to get a new code codenew(E) .
4-148:B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message .
4-149:In this manner, as the event wends its way to its owner, its zone code gets refined .
4-150:Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message .
4-151:If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next) .
4-152:If B"s zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop .
4-153:3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E .
4-154:It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E .
4-155:In that case, C stores E locally, but only if all four of C"s zone boundaries are decided .
4-156:When this condition holds, C knows for sure that no other nodes have overlapped zones with it .
4-157:In this case, we call C an internal node .
4-158:Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of C"s boundaries may be undecided .
4-159:If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap .
4-160:To do this, C now sets itself to be the owner of E and continues forwarding the message .
4-161:Here we rely on GPSR"s perimeter mode routing to probe around the void that causes the undecided boundary .
4-162:Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message .
4-163:If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally .
4-164:If this does not happen, there are two possibilities .
4-165:The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with C"s marks itself to be the owner of the event, but otherwise does not change the event"s zone code .
4-166:This node also recognizes that its own zone overlaps with C"s and initiates a message exchange which causes each of them to appropriately shrink their zone .
4-167:Figures 6 through 8 show an example of this data driven zone shrinking .
4-168:Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other .
4-169:Suppose that A inserts an event E = 0.4, 0.8, 0.9 .
4-170:A encodes E to 0 and claims itself to be the owner of E .
4-171:Since A is not an internal node, it sends out E, looking for other owner candidates of E .
4-172:Once E gets to node B, B will see in the message"s owner field A"s code that is the same as its own .
4-173:B then shrinks its zone from 0 to 01 according to A"s location which is also recorded in the message and send a shrink request to A .
4-174:Upon receiving this request, A also shrinks its zone from 0 to 00 .
4-175:A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code) .
4-176:Let us label this node D .
4-177:D now tries to initiate delivery to the centroid of the new zone .
4-178:This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone .
4-179:A B <0.4,0.8,0.9> Figure 7: An event query message (filled arrows) triggers zone shrinking (hollow arrows) .
4-180:A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking .
4-181:Now node A and B have been mapped to different zones .
4-182:might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone) .
4-183:However, D would not be the owner of the event, which would still be C .
4-184:In routing to the centroid of this zone, the message may traverse the perimeter and return to D .
4-185:Now D notices that C was the original owner, so it encapsulates the event and directs it to C .
4-186:In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own .
4-187:X will shrink its zone to resolve the overlap .
4-188:If X"s zone is smaller than or equal to C"s zone, X will also send a shrink request to C .
4-189:Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary .
4-190:In this manner, the zone formation process is resolved on demand in a data driven way .
4-191:68 There are several interesting effects with respect to perimeter walking that arise in our algorithm .
4-192:The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .
4-193:Figure 6 also works as an example where the outer perimeter is traversed .
4-194:Event E inserted by A will eventually be stored in node B .
4-195:Before node B stores event E, if B"s nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node .
4-196:But if B"s nominal radio range intersects the network boundary, it then has two choices .
4-197:It can assume that there will not be any nodes outside the network boundary and so B is an internal node .
4-198:This is an aggressive approach .
4-199:On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet .
4-200:B will then force the message walking another perimeter before storing it .
4-201:In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone .
4-202:The event will end up being stored at a different node than the real owner .
4-203:In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery .
4-204:Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event .
4-205:To do this, a node C, say, needs to know the zone codes of its neighboring nodes .
4-206:We deploy GPSR"s beaconing message to piggyback the zone codes for nodes .
4-207:So by simply comparing the event"s code and neighbor"s code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E .
4-208:C delivers E to Y , which simply follows the decision making procedure discussed above .
4-209:3.3.4 Summary and Pseudo code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism .
4-210:The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the event"s zone code, and it leverages GPSR"s perimeter walking mechanism to fix undecided zone boundaries .
4-211:In Section 3.5, we address robustness of event insertion to packet loss or to node failures .
4-212:Figure 5 shows the pseudo code for inserting and forwarding an event e .
4-213:In this pseudo code, we have omitted a description of the zone shrinking procedure .
4-214:In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message .
4-215:Procedure Send Message is used to send either an event message or a query message .
4-216:If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice .
4-217:3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk .
4-218:3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries .
4-219:Routing a point query is identical to routing an event .
4-220:Thus, the rest of this section details how range queries are routed .
4-221:The key challenge in routing zone queries is brought out by the following strawman design .
4-222:If the entire network was divided evenly into zones of depth k (for some pre defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones .
4-223:This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined .
4-224:Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries .
4-225:We describe this algorithm here .
4-226:The first step of the algorithm is to map a range query to a zone code prefix .
4-227:Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub tree, and none of its children in the tree do .
4-228:The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree .
4-229:The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)) .
4-230:Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q) .
4-231:Our approach to split a query Q into subqueries is as follows .
4-232:If the range of Q"s first attribute contains the value 0.5, A divides Q into two sub queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to Let"s call it QA .
4-233:If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it .
4-234:For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .
4-235:The splitting steps is shown in Figure 2 .
4-236:After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .
4-237:This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting .
4-238:A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above .
4-239:More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split .
4-240:Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split) .
4-241:Figure 10 describes the pseudo code for the zone splitting algorithm .
4-242:As shown in the above algorithm, once a subquery has been recognized as belonging to the caller"s zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier .
4-243:Every query message contains 4 By point queries, we mean the equality condition on all indexed keys .
4-244:DIM index attributes are not necessarily primary keys .
4-245:69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator .
4-246:Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting .
4-247:We omit this in the pseudo code .
4-248:3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms .
4-249:Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure .
4-250:We now discuss how DIMs can be made robust to these kinds of dynamics .
4-251:3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided .
4-252:These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above .
4-253:When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries .
4-254:At this time, those zones can also transfer to the new node those events they store but which should belong to the new node .
4-255:Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node .
4-256:Node deletion may also cause zone expansion .
4-257:In order to keep the mapping between the binary zone tree"s leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1) .
4-258:The rule is: if zone(A)"s sibling zone becomes empty, then A can expand its own zone to include its sibling zone .
4-259:Now, we turn our attention to node failures .
4-260:Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node .
4-261:But how does a node decide if its sibling has failed? If the sibling is within radio range, the absence of GPSR beaconing messages can detect this .
4-262:Once it detects this, the node can expand its zone .
4-263:A different approach is needed for detecting siblings who are not within radio range .
4-264:These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship .
4-265:In this case, we detect the failure in a data driven fashion, with obvious efficiency benefits compared to periodic keepalives .
4-266:Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal .
4-267:A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead .
4-268:If A"s zone happens to be the sibling of B"s zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages .
4-269:3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data .
4-270:To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes .
4-271:Mirror replication is conceptually easy .
4-272:Suppose an event E has a zone code code(E) .
4-273:Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the one"s complement of code(E) .
4-274:This technique essentially creates a mirror DIM .
4-275:A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed .
4-276:Clearly, the trade off here is an approximate doubling of both insertion and query costs .
4-277:There exists a far cheaper technique to ensure resilience to random node failures .
4-278:Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails .
4-279:This node is defined as the node responsible for A"s zone"s backup zone (see Section 3.1) .
4-280:The basic idea is that A replicates each data item it has in this node .
4-281:We call this node A"s local replica .
4-282:Let A"s local replica be B .
4-283:Often B will be a radio neighbor of A and can be detected from GPSR beacons .
4-284:Sometimes, however, this is not the case, and B will have to be explicitly discovered .
4-285:We use an explicit message for discovering the local replica .
4-286:Discovering the local replica is data driven, and uses a mechanism similar to that of event insertion .
4-287:Node A sends a message whose geographic destination is a random nearby location chosen by A .
4-288:The location is close enough to A such that GPSR will guarantee that the message will delivered back to A .
4-289:In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A) .
4-290:Then the packet will be delivered in GPSR perimeter mode .
4-291:Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location .
4-292:Once the packet comes back to A, it will know the location of its local replica and can start to send replicas .
4-293:In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1 2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic .
4-294:However, a node"s local replica itself may fail .
4-295:There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas .
4-296:The former has higher overhead, but more quickly discovers failed replicas .
4-297:3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss .
4-298:For event insertion, a simple ACK scheme suffices .
4-299:Of course, queries and responses can be lost as well .
4-300:In this case, there exists an efficient approach for error recovery .
4-301:This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment) .
4-302:After a conservative timeout, the querier can re issue the queries selectively to these zones .
4-303:If DIM cannot get any answers (positive or negative) from 70 <0.3 0.8, 0.6 0.9> <0.5 0.8, 0.6 0.9><0.3 0.5, 0.6 0.9> <0.3 0.5, 0.6 0.9> <0.3 0.5, 0.6 0.9> <0.3 0.5, 0.6 0.75> <0.3 0.5, 0.75 0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve Range Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. .
5 DIMS: AN ANALYSIS :
5-1:In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi dimensional range queries in sensor networks .
5-2:In the next section, we validate these analyses using detailed packet level simulations .
5-3:Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network .
5-4:Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network .
5-5:It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against .
5-6:In DIMs, event insertion essentially uses geographic routing .
5-7:In a dense N node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23] .
5-8:On the other hand, the query delivery cost depends upon the size of ranges specified in the query .
5-9:Recall that our query delivery mechanism is careful about splitting a query into sub queries, doing so only when the query nears the zone that covers the query range .
5-10:Thus, when the querier is far from the queried zone, there are two components to the query delivery cost .
5-11:The first, which is proportional to √ N, is the cost to deliver the query near the covering zone .
5-12:If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M .
5-13:The average cost of query delivery depends upon the distribution of query range sizes .
5-14:Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx .
5-15:To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely .
5-16:In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query .
5-17:For the uniform distribution P(x) ∝ c for some constant c .
5-18:If each query size from 1 .
5-19:.
5-20:.
5-21:N is equally likely, the average query delivery cost of uniformly distributed queries is O(N) .
5-22:Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding .
5-23:However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic .
5-24:Somewhat more realistic is a situation where all query sizes are bounded by a constant B .
5-25:In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B) .
5-26:Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone .
5-27:Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N) .
5-28:The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k Our analysis gives us some insight into the asymptotic behavior of various approaches for multi dimensional range queries .
5-29:In this section, we use simulation to compare DIMs against flooding and GHT R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches .
5-30:5.1 Simulation Methodology We use ns 2 for our simulations .
5-31:Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns 2 .
5-32:We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter .
5-33:This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query .
5-34:In addition, to this, we implemented in ns 2 most of the DIM mechanisms described in Section 3 .
5-35:Of those mechanisms, the only one we did not implement is mirror replication .
5-36:We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work .
5-37:Our DIM implementation in ns 2 is 2800 lines of code .
5-38:Finally, we implemented GHT R, our GHT based multidimensional range query mechanism in ns 2 .
5-39:This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals .
5-40:Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT R) .
5-41:For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes .
5-42:Each node has a radio range of 40m .
5-43:For the results presented here, each node has on average 20 nodes within its nominal radio range .
5-44:We have conducted experiments at other node densities; they are in agreement with the results presented here .
5-45:In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event) .
5-46:We have conducted experiments for three different event value distributions .
5-47:Our uniform event distribution generates 2 dimensional events and, for each dimension, every attribute value is equally likely .
5-48:Our normal event distribution generates 2 dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid point of the attribute value range .
5-49:The normal event distribution represents a skewed data set .
5-50:Finally, our trace event distribution is a collection of 4 dimensional events obtained from a habitat monitoring network .
5-51:As we shall see, this represents a fairly skewed data set .
5-52:Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries .
5-53:The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential .
5-54:Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed .
5-55:For our GHT R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time .
5-56:Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results .
5-57:The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4 .
5-58:5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space .
5-59:Figure 11 plots the average insertion costs for DIM and GHT R (for flooding, of course, the insertion costs are zero) .
5-60:DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events) .
5-61:The reason for this is interesting .
5-62:In GHT R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20] .
5-63:By contrast, in DIM, storing an event incurs a perimeter traversal only when a node"s boundaries are undecided .
5-64:Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs .
5-65:Figure 13 plots the average query cost for a bounded uniform query size distribution .
5-66:For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost .
5-67:For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion .
5-68:Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4 .
5-69:Since we don"t have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs .
5-70:72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT R Figure 11: Average insertion cost for DIM and GHT .
5-71:0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance .
5-72:query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .
5-73:Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding) .
5-74:Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attribute"s range .
5-75:Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query) .
5-76:The superior scaling of DIMs is evident in these graphs .
5-77:Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare .
5-78:This is also the regime in which one would expect to use multi dimensional range queries: to perform relatively tight correlations .
5-79:As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low .
5-80:Figure 12 describes the efficacy of local replication .
5-81:To obtain this figure, we conducted the following experiment .
5-82:On a 100 node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers .
5-83:Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re issued the same query .
5-84:The figure plots the fraction of expected responses actually received, with and without replication .
5-85:As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect .
5-86:We note that DIMs (as currently designed) are not perfect .
5-87:When the data is highly skewed as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attribute"s range a few DIM nodes will clearly become the bottleneck .
5-88:This is depicted in Figure 15, which shows that for DIMs, and GHT Rs, the maximum number of transmissions at any network node (the hotspots) is rather high .
5-89:(For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.) This is a standard problem that the database indices have dealt with by tree re balancing .
5-90:In our case, simpler solutions might be possible (and we discuss this in Section 7) .
5-91:However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions .
5-92:Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space) .
5-93:Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way .
5-94:As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely .
5-95:For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution .
5-96:For normally distributed events, the insertion costs be much better than this .
5-97:Assuming a node and its replica don"t simultaneously fail often, a node will almost always detect a replica failure and re replicate, leading to near 100% response rates .
5-98:73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven Thread based) update useuse update GPSR Upper interface(Event driven Thread based) Lower interface(Event driven Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution .
5-99:Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range) .
5-100:We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones .
5-101:We leave an understanding of this to future work .
5-102:Also left to future work is a detailed understanding of the impact of location error on DIM"s mechanisms .
5-103:Recent work [22] has examined the impact of imprecise location information on other data centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. .
6 IMPLEMENTATION :
6-1:We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC 104 class machines .
6-2:To implement DIMs, we had to develop and test an independent implementation of GPSR .
6-3:Our GPSR implementation is full featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented .
6-4:The software architecture of DIM GPSR system is shown in Figure 16 .
6-5:The entire system (about 5000 lines of code) is event driven and multi threaded .
6-6:The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions .
6-7:The GPSR system is implemented as user level daemon process .
6-8:Applications are executed as clients .
6-9:For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter mode termination .
6-10:We tested our implementation on a testbed consisting of 8 PC 104 class machines .
6-11:Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication .
6-12:These boxes are laid out in an office building with a total spatial separation of over a hundred feet .
6-13:We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location .
6-14:The network topology is approximately a chain .
6-15:On this testbed, we inserted queries and events from a single designated node .
6-16:Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all) .
6-17:Our queries span four sizes, returning 1, 4, 9 and 16 events respectively .
6-18:Figure 17 plots the number of events received for different sized queries .
6-19:It might appear that we received fewer events than expected, but this graph doesn"t count the events that were already stored at the querier .
6-20:With that adjustment, the number of responses matches our expectation .
6-21:Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed .
6-22:While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof of concept for DIMs .
6-23:Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes .
6-24:74 .
7-1:In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi dimensional range queries in sensor networks
7-2:Our design of DIMs relies upon a novel locality preserving hash inspired by early work in database indexing, and is built upon GPSR
7-3:We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future
7-4:There are several interesting future directions that we intend to pursue
7-5:One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots
7-6:Unlike traditional database indices that re balance trees upon data insertion, in sensor networks it might be feasible to re structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution
7-7:Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger sized zones for themselves
7-8:A third is support for efficient resolution of existential queries whether there exists an event matching a multi dimensional range
7-9:Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao.
8-1:J
8-2:Aspnes and G
8-3:Shah
8-4:Skip Graphs
8-5:In Proceedings of 14th Annual ACM SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003
8-6:J
8-7:L
8-8:Bentley
8-9:Multidimensional Binary Search Trees Used for Associative Searching
8-10:Communicaions of the ACM, 18(9):475 484, 1975
8-11:P
8-12:Bonnet, J
8-13:E
8-14:Gerhke, and P
8-15:Seshadri
8-16:Towards Sensor Database Systems
8-17:In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001
8-18:I
8-19:Clarke, O
8-20:Sandberg, B
8-21:Wiley, and T
8-22:W
8-23:Hong
8-24:Freenet: A Distributed Anonymous Information Storage and Retrieval System
8-25:In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability
8-26:Springer, New York, 2001
8-27:D
8-28:Comer
8-29:The Ubiquitous B tree
8-30:ACM Computing Surveys, 11(2):121 137, 1979
8-31:R
8-32:A
8-33:Finkel and J
8-34:L
8-35:Bentley
8-36:Quad Trees: A Data Structure for Retrieval on Composite Keys
8-37:Acta Informatica, 4:1 9, 1974
8-38:D
8-39:Ganesan, D
8-40:Estrin, and J
8-41:Heidemann
8-42:DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks? In Proceedings of the First Workshop on Hot Topics In Networks (HotNets I), Princeton, NJ, October 2002
8-43:A
8-44:Gionis, P
8-45:Indyk, and R
8-46:Motwani
8-47:Similarity Search in High Dimensions via Hashing
8-48:In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999
8-49:R
8-50:Govindan, J
8-51:Hellerstein, W
8-52:Hong, S
8-53:Madden, M
8-54:Franklin, and S
8-55:Shenker
8-56:The Sensor Network as a Database
8-57:Technical Report 02 771, Computer Science Department, University of Southern California, September 2002
8-58:B
8-59:Greenstein, D
8-60:Estrin, R
8-61:Govindan, S
8-62:Ratnasamy, and S
8-63:Shenker
8-64:DIFS: A Distributed Index for Features in Sensor Networks
8-65:In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003
8-66:A
8-67:Guttman
8-68:R trees: A Dynamic Index Structure for Spatial Searching
8-69:In Proceedings of the ACM SIGMOD, Boston, MA, June 1984
8-70:M
8-71:Harren, J
8-72:M
8-73:Hellerstein, R
8-74:Huebsch, B
8-75:T
8-76:Loo, S
8-77:Shenker, and I
8-78:Stoica
8-79:Complex Queries in DHT based Peer to Peer Networks
8-80:In P
8-81:Druschel, F
8-82:Kaashoek, and A
8-83:Rowstron, editors, Proceedings of 1st International Workshop on Peer to Peer Systems (IPTPS"02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002
8-84:Springer Verlag
8-85:P
8-86:Indyk and R
8-87:Motwani
8-88:Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality
8-89:In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998
8-90:P
8-91:Indyk, R
8-92:Motwani, P
8-93:Raghavan, and S
8-94:Vempala
8-95:Locality preserving Hashing in Multidimensional Spaces
8-96:In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618  625, El Paso, Texas, May 1997
8-97:ACM Press
8-98:C
8-99:Intanagonwiwat, R
8-100:Govindan, and D
8-101:Estrin
8-102:Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks
8-103:In Proceedings of the Sixth Annual ACM IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000
8-104:B
8-105:Karp and H
8-106:T
8-107:Kung
8-108:GPSR: Greedy Perimeter Stateless Routing for Wireless Networks
8-109:In Proceedings of the Sixth Annual ACM IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000
8-110:S
8-111:Madden, M
8-112:Franklin, J
8-113:Hellerstein, and W
8-114:Hong
8-115:The Design of an Acquisitional Query Processor for Sensor Networks
8-116:In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003
8-117:S
8-118:Madden, M
8-119:J
8-120:Franklin, J
8-121:M
8-122:Hellerstein, and W
8-123:Hong
8-124:TAG: a Tiny AGregation Service for ad hoc Sensor Networks
8-125:In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002
8-126:S
8-127:Ratnasamy, P
8-128:Francis, M
8-129:Handley, R
8-130:Karp, and S
8-131:Shenker
8-132:A Scalable Content Addressable Network
8-133:In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001
8-134:S
8-135:Ratnasamy, B
8-136:Karp, L
8-137:Yin, F
8-138:Yu, D
8-139:Estrin, R
8-140:Govindan, and S
8-141:Shenker
8-142:GHT: A Geographic Hash Table for Data Centric Storage
8-143:In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002
8-144:H
8-145:Samet
8-146:Spatial Data Structures
8-147:In W
8-148:Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361 385
8-149:Addison Wesley ACM, 1995
8-150:K
8-151:Sead, A
8-152:Helmy, and R
8-153:Govindan
8-154:On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks
8-155:In Under submission, 2003
8-156:S
8-157:Shenker, S
8-158:Ratnasamy, B
8-159:Karp, R
8-160:Govindan, and D
8-161:Estrin
8-162:Data Centric Storage in Sensornets
8-163:In Proc
8-164:ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002
8-165:I
8-166:Stoica, R
8-167:Morris, D
8-168:Karger, M
8-169:F
8-170:Kaashoek, and H
8-171:Balakrishnan
8-172:Chord: A Scalable Peer To Peer Lookup Service for Internet Applications
8-173:In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001
8-174:F
8-175:Ye, H
8-176:Luo, J
8-177:Cheng, S
8-178:Lu, and L
8-179:Zhang
8-180:A Two Tier Data Dissemination Model for Large scale Wireless Sensor Networks
8-181:In Proceedings of the Eighth Annual ACM IEEE International Conference on Mobile Computing and Networking (Mobicom"02), Atlanta, GA, September 2002
8-182:75
picture:
