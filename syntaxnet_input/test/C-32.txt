BuddyCache: High-Performance Object Storage 
content:
1 ABSTRACT :
1-1:Collaborative applications provide a shared work environment for groups of networked clients collaborating on a common task .
1-2:They require strong consistency for shared persistent data and efficient access to fine grained objects .
1-3:These properties are difficult to provide in wide area networks because of high network latency .
1-4:BuddyCache is a new transactional caching approach that improves the latency of access to shared persistent objects for collaborative strong consistency applications in high latency network environments .
1-5:The challenge is to improve performance while providing the correctness and availability properties of a transactional caching protocol in the presence of node failures and slow peers .
1-6:We have implemented a BuddyCache prototype and evaluated its performance .
1-7:Analytical results, confirmed by measurements of the BuddyCache prototype using the multiuser 007 benchmark indicate that for typical Internet latencies, e.g .
1-8:ranging from 40 to 80 milliseconds round trip time to the storage server, peers using BuddyCache can reduce by up to 50% the latency of access to shared objects compared to accessing the remote servers directly .
1-9:C.2.4 [Computer Systems Organization]: Distributed .
2 INTRODUCTION :
2-1:Improvements in network connectivity erode the distinction between local and wide area computing and, increasingly, users expect their work environment to follow them wherever they go .
2-2:Nevertheless, distributed applications may perform poorly in wide area network environments .
2-3:Network bandwidth problems will improve in the foreseeable future, but improvement in network latency is fundamentally limited .
2-4:BuddyCache is a new object caching technique that addresses the network latency problem for collaborative applications in wide area network environment .
2-5:Collaborative applications provide a shared work environment for groups of networked users collaborating on a common task, for example a team of engineers jointly overseeing a construction project .
2-6:Strong consistency collaborative applications, for example CAD systems, use client server transactional object storage systems to ensure consistent access to shared persistent data .
2-7:Up to now however, users have rarely considered running consistent network storage systems over wide area networks as performance would be unacceptable [24] .
2-8:For transactional storage systems, the high cost of wide area network interactions to maintain data consistency is the main cost limiting the performance and therefore, in wide area network environments, collaborative applications have been adapted to use weaker consistency storage systems [22] .
2-9:Adapting an application to use weak consistency storage system requires significant effort since the application needs to be rewritten to deal with a different storage system semantics .
2-10:If shared persistent objects could be accessed with low latency, a new field of distributed strong consistency applications could be opened .
2-11:Cooperative web caching [10, 11, 15] is a well known approach to reducing client interaction with a server by allowing one client to obtain missing objects from a another client instead of the server .
2-12:Collaborative applications seem a particularly good match to benefit from this approach since one of the hard problems, namely determining what objects are cached where, becomes easy in small groups typical of collaborative settings .
2-13:However, cooperative web caching techniques do not provide two important properties needed by collaborative applications, strong consistency and efficient 26 access to fine grained objects .
2-14:Cooperative object caching systems [2] provide these properties .
2-15:However, they rely on interaction with the server to provide fine grain cache coherence that avoids the problem of false sharing when accesses to unrelated objects appear to conflict because they occur on the same physical page .
2-16:Interaction with the server increases latency .
2-17:The contribution of this work is extending cooperative caching techniques to provide strong consistency and efficient access to fine grain objects in wide area environments .
2-18:Consider a team of engineers employed by a construction company overseeing a remote project and working in a shed at the construction site .
2-19:The engineers use a collaborative CAD application to revise and update complex project design documents .
2-20:The shared documents are stored in transactional repository servers at the company home site .
2-21:The engineers use workstations running repository clients .
2-22:The workstations are interconnected by a fast local Ethernet but the network connection to the home repository servers is slow .
2-23:To improve access latency, clients fetch objects from repository servers and cache and access them locally .
2-24:A coherence protocol ensures that client caches remain consistent when objects are modified .
2-25:The performance problem facing the collaborative application is coordinating with the servers consistent access to shared objects .
2-26:With BuddyCache, a group of close by collaborating clients, connected to storage repository via a high latency link, can avoid interactions with the server if needed objects, updates or coherency information are available in some client in the group .
2-27:BuddyCache presents two main technical challenges .
2-28:One challenge is how to provide efficient access to shared finegrained objects in the collaborative group without imposing performance overhead on the entire caching system .
2-29:The other challenge is to support fine grain cache coherence in the presence of slow and failed nodes .
2-30:BuddyCache uses a redirection approach similar to one used in cooperative web caching systems [11] .
2-31:A redirector server, interposed between the clients and the remote servers, runs on the same network as the collaborating group and, when possible, replaces the function of the remote servers .
2-32:If the client request can not be served locally, the redirector forwards it to a remote server .
2-33:When one of the clients in the group fetches a shared object from the repository, the object is likely to be needed by other clients .
2-34:BuddyCache redirects subsequent requests for this object to the caching client .
2-35:Similarly, when a client creates or modifies a shared object, the new data is likely to be of potential interest to all group members .
2-36:BuddyCache uses redirection to support peer update, a lightweight application level multicast technique that provides group members with consistent access to the new data committed within the collaborating group without imposing extra overhead outside the group .
2-37:Nevertheless, in a transactional system, redirection interferes with shared object availability .
2-38:Solo commit, is a validation technique used by BuddyCache to avoid the undesirable client dependencies that reduce object availability when some client nodes in the group are slow, or clients fail independently .
2-39:A salient feature of solo commit is supporting fine grained validation using inexpensive coarse grained coherence information .
2-40:Since redirection supports the performance benefits of reducing interaction with the server but introduces extra processing cost due to availability mechanisms and request forwarding, this raises the question is the cure worse than the disease? We designed and implemented a BuddyCache prototype and studied its performance benefits and costs using analytical modeling and system measurements .
2-41:We compared the storage system performance with and without BuddyCache and considered how the cost benefit balance is affected by network latency .
2-42:Analytical results, supported by measurements based on the multi user 007 benchmark, indicate that for typical Internet latencies BuddyCache provides significant performance benefits, e.g .
2-43:for latencies ranging from 40 to 80 milliseconds round trip time, clients using the BuddyCache can reduce by up to 50% the latency of access to shared objects compared to the clients accessing the repository directly .
2-44:These strong performance gains could make transactional object storage systems more attractive for collaborative applications in wide area environments. .
3 RELATED WORK :
3-1:Cooperative caching techniques [20, 16, 13, 2, 28] provide access to client caches to avoid high disk access latency in an environment where servers and clients run on a fast local area network .
3-2:These techniques use the server to provide redirection and do not consider issues of high network latency .
3-3:Multiprocessor systems and distributed shared memory systems [14, 4, 17, 18, 5] use fine grain coherence techniques to avoid the performance penalty of false sharing but do not address issues of availability when nodes fail .
3-4:Cooperative Web caching techniques, (e.g .
3-5:[11, 15]) investigate issues of maintaining a directory of objects cached in nearby proxy caches in wide area environment, using distributed directory protocols for tracking cache changes .
3-6:This work does not consider issues of consistent concurrent updates to shared fine grained objects .
3-7:Cheriton and Li propose MMO [12] a hybrid web coherence protocol that combines invalidations with updates using multicast delivery channels and receiver reliable protocol, exploiting locality in a way similar to BuddyCache .
3-8:This multicast transport level solution is geared to the single writer semantics of web objects .
3-9:In contrast, BuddyCache uses application level multicast and a sender reliable coherence protocol to provide similar access latency improvements for transactional objects .
3-10:Application level multicast solution in a middle ware system was described by Pendarakis, Shi and Verma in [27] .
3-11:The schema supports small multi sender groups appropriate for collaborative applications and considers coherence issues in the presence of failures but does not support strong consistency or fine grained sharing .
3-12:Yin, Alvisi, Dahlin and Lin [32, 31] present a hierarchical WAN cache coherence scheme .
3-13:The protocol uses leases to provide fault tolerant call backs and takes advantage of nearby caches to reduce the cost of lease extensions .
3-14:The study uses simulation to investigate latency and fault tolerance issues in hierarchical avoidance based coherence scheme .
3-15:In contrast, our work uses implementation and analysis to evaluate the costs and benefits of redirection and fine grained updates in an optimistic system .
3-16:Anderson, Eastham and Vahdat in WebFS [29] present a global file system coherence protocol that allows clients to choose 27 on per file basis between receiving updates or invalidations .
3-17:Updates and invalidations are multicast on separate channels and clients subscribe to one of the channels .
3-18:The protocol exploits application specific methods e.g .
3-19:last writer wins policy for broadcast applications, to deal with concurrent updates but is limited to file systems .
3-20:Mazieres studies a bandwidth saving technique [24] to detect and avoid repeated file fragment transfers across a WAN when fragments are available in a local cache .
3-21:BuddyCache provides similar bandwidth improvements when objects are available in the group cache. .
4 BUDDYCACHE :
4-1:High network latency imposes performance penalty for transactional applications accessing shared persistent objects in wide area network environment .
4-2:This section describes the BuddyCache approach for reducing the network latency penalty in collaborative applications and explains the main design decisions .
4-3:We consider a system in which a distributed transactional object repository stores objects in highly reliable servers, perhaps outsourced in data centers connected via high bandwidth reliable networks .
4-4:Collaborating clients interconnected via a fast local network, connect via high latency, possibly satellite, links to the servers at the data centers to access shared persistent objects .
4-5:The servers provide disk storage for the persistent objects .
4-6:A persistent object is owned by a single server .
4-7:Objects may be small (order of 100 bytes for programming language objects [23]) .
4-8:To amortize the cost of disk and network transfer objects are grouped into physical pages .
4-9:To improve object access latency, clients fetch the objects from the servers and cache and access them locally .
4-10:A transactional cache coherence protocol runs at clients and servers to ensure that client caches remain consistent when objects are modified .
4-11:The performance problem facing the collaborating client group is the high latency of coordinating consistent access to the shared objects .
4-12:BuddyCache architecture is based on a request redirection server, interposed between the clients and the remote servers .
4-13:The interposed server (the redirector) runs on the same network as the collaborative group and, when possible, replaces the function of the remote servers .
4-14:If the client request can be served locally, the interaction with the server is avoided .
4-15:If the client request can not be served locally, redirector forwards it to a remote server .
4-16:Redirection approach has been used to improve the performance of web caching protocols .
4-17:BuddyCache redirector supports the correctness, availability and fault tolerance properties of transactional caching protocol [19] .
4-18:The correctness property ensures onecopy serializability of the objects committed by the client transactions .
4-19:The availability and fault tolerance properties ensure that a crashed or slow client does not disrupt any other client"s access to persistent objects .
4-20:The three types of client server interactions in a transactional caching protocol are the commit of a transaction, the fetch of an object missing in a client cache, and the exchange of cache coherence information .
4-21:BuddyCache avoids interactions with the server when a missing object, or cache coherence information needed by a client is available within the collaborating group .
4-22:The redirector always interacts with the servers at commit time because only storage servers provide transaction durability in a way that ensures committed Client Redirector Client Client Buddy Group Client Redirector Client Client Buddy Group Servers Figure 1: BuddyCache .
4-23:data remains available in the presence of client or redirector failures .
4-24:Figure 1 shows the overall BuddyCache architecture .
4-25:3.1 Cache Coherence The redirector maintains a directory of pages cached at each client to provide cooperative caching [20, 16, 13, 2, 28], redirecting a client fetch request to another client that caches the requested object .
4-26:In addition, redirector manages cache coherence .
4-27:Several efficient transactional cache coherence protocols [19] exist for persistent object storage systems .
4-28:Protocols make different choices in granularity of data transfers and granularity of cache consistency .
4-29:The current best performing protocols use page granularity transfers when clients fetch missing objects from a server and object granularity coherence to avoid false (page level) conflicts .
4-30:The transactional caching taxonomy [19] proposed by Carey, Franklin and Livny classifies the coherence protocols into two main categories according to whether a protocol avoids or detects access to stale objects in the client cache .
4-31:The BuddyCache approach could be applied to both categories with different performance costs and benefits in each category .
4-32:We chose to investigate BuddyCache in the context of OCC [3], the current best performing detection based protocol .
4-33:We chose OCC because it is simple, performs well in high latency networks, has been implemented and we had access to the implementation .
4-34:We are investigating BuddyCache with PSAA [33], the best performing avoidancebased protocol .
4-35:Below we outline the OCC protocol [3] .
4-36:The OCC protocol uses object level coherence .
4-37:When a client requests a missing object, the server transfers the containing page .
4-38:Transaction can read and update locally cached objects without server intervention .
4-39:However, before a transaction commits it must be validated; the server must make sure the validating transaction has not read a stale version of some object that was updated by a successfully committed or validated transaction .
4-40:If validation fails, the transaction is aborted .
4-41:To reduce the number and cost of aborts, 28 Helper Requester A:p Fetch pPeer fetch p Page p Redirector Figure 2: Peer fetch a server sends background object invalidation messages to clients caching the containing pages .
4-42:When clients receive invalidations they remove stale objects from the cache and send background acknowledgments to let server know about this .
4-43:Since invalidations remove stale objects from the client cache, invalidation acknowledgment indicates to the server that a client with no outstanding invalidations has read upto date objects .
4-44:An unacknowledged invalidation indicates a stale object may have been accessed in the client cache .
4-45:The validation procedure at the server aborts a client transaction if a client reads an object while an invalidation is outstanding .
4-46:The acknowledged invalidation mechanism supports object level cache coherence without object based directories or per object version numbers .
4-47:Avoiding per object overheads is very important to reduce performance penalties [3] of managing many small objects, since typical objects are small .
4-48:An important BuddyCache design goal is to maintain this benefit .
4-49:Since in BuddyCache a page can be fetched into a client cache without server intervention (as illustrated in figure 2), cache directories at the servers keep track of pages cached in each collaborating group rather than each client .
4-50:Redirector keeps track of pages cached in each client in a group .
4-51:Servers send to the redirector invalidations for pages cached in the entire group .
4-52:The redirector propagates invalidations from servers to affected clients .
4-53:When all affected clients acknowledge invalidations, redirector can propagate the group acknowledgment to the server .
4-54:3.2 Light weight Peer Update When one of the clients in the collaborative group creates or modifies shared objects, the copies cached by any other client become stale but the new data is likely to be of potential interest to the group members .
4-55:The goal in BuddyCache is to provide group members with efficient and consistent access to updates committed within the group without imposing extra overhead on other parts of the storage system .
4-56:The two possible approaches to deal with stale data are cache invalidations and cache updates .
4-57:Cache coherence studies in web systems (e.g .
4-58:[7]) DSM systems (e.g .
4-59:[5]), and transactional object systems (e.g .
4-60:[19]) compare the benefits of update and invalidation .
4-61:The studies show the Committing Client Server Redirector x2 .
4-62:Store x .
5 Update x :
5-1:.
6 Commit x :
6-1:.
7 Commit OK :
7-1:.
8 Commit OK1. Commit x :
8-1:Figure 3: Peer update .
8-2:benefits are strongly workload dependent .
8-3:In general, invalidation based coherence protocols are efficient since invalidations are small, batched and piggybacked on other messages .
8-4:Moreover, invalidation protocols match the current hardware trend for increasing client cache sizes .
8-5:Larger caches are likely to contain much more data than is actively used .
8-6:Update based protocols that propagate updates to low interest objects in a wide area network would be wasteful .
8-7:Nevertheless, invalidation based coherence protocols can perform poorly in high latency networks [12] if the object"s new value is likely to be of interest to another group member .
8-8:With an invalidation based protocol, one member"s update will invalidate another member"s cached copy, causing the latter to perform a high latency fetch of the new value from the server .
8-9:BuddyCache circumvents this well known bandwidth vs .
8-10:latency trade off imposed by update and invalidation protocols in wide area network environments .
8-11:It avoids the latency penalty of invalidations by using the redirector to retain and propagate updates committed by one client to other clients within the group .
8-12:This avoids the bandwidth penalty of updates because servers propagate invalidations to the redirectors .
8-13:As far as we know, this use of localized multicast in BuddyCache redirector is new and has not been used in earlier caching systems .
8-14:The peer update works as follows .
8-15:An update commit request from a client arriving at the redirector contains the object updates .
8-16:Redirector retains the updates and propagates the request to the coordinating server .
8-17:After the transaction commits, the coordinator server sends a commit reply to the redirector of the committing client group .
8-18:The redirector forwards the reply to the committing client, and also propagates the retained committed updates to the clients caching the modified pages (see figure 3) .
8-19:Since the groups outside the BuddyCache propagate invalidations, there is no extra overhead outside the committing group .
8-20:3.3 Solo commit In the OCC protocol, clients acknowledge server invalidations (or updates) to indicate removal of stale data .
8-21:The straightforward group acknowledgement protocol where redirector collects and propagates a collective acknowledge29 Redirector commit ok ABORT Client 1 Client 2 Server commit (P(x)) commit (P(x)) ok + inv(P(x)) inv(P(x)) commit(P(x)) commit(P(x)) ack(P(x)) ack(P(x)) Figure 4: Validation with Slow Peers ment to the server, interferes with the availability property of the transactional caching protocol [19] since a client that is slow to acknowledge an invalidation or has failed can delay a group acknowledgement and prevent another client in the group from committing a transaction .
8-22:E.g .
8-23:an engineer that commits a repeated revision to the same shared design object (and therefore holds the latest version of the object) may need to abort if the group acknowledgement has not propagated to the server .
8-24:Consider a situation depicted in figure 4 where Client1 commits a transaction T that reads the latest version of an object x on page P recently modified by Client1 .
8-25:If the commit request for T reaches the server before the collective acknowledgement from Client2 for the last modification of x arrives at the server, the OCC validation procedure considers x to be stale and aborts T (because, as explained above, an invalidation unacknowledged by a client, acts as indication to the server that the cached object value is stale at the client) .
8-26:Note that while invalidations are not required for the correctness of the OCC protocol, they are very important for the performance since they reduce the performance penalties of aborts and false sharing .
8-27:The asynchronous invalidations are an important part of the reason OCC has competitive performance with PSAA [33], the best performing avoidance based protocol [3] .
8-28:Nevertheless, since invalidations are sent and processed asynchronously, invalidation processing may be arbitrarily delayed at a client .
8-29:Lease based schemes (time out based) have been proposed to improve the availability of hierarchical callback based coherence protocols [32] but the asynchronous nature of invalidations makes the lease based approaches inappropriate for asynchronous invalidations .
8-30:The Solo commit validation protocol allows a client with up to date objects to commit a transaction even if the group acknowledgement is delayed due to slow or crashed peers .
8-31:The protocol requires clients to include extra information with the transaction read sets in the commit message, to indicate to the server the objects read by the transaction are up to date .
8-32:Object version numbers could provide a simple way to track up to date objects but, as mentioned above, maintaining per object version numbers imposes unacceptably high overheads (in disk storage, I O costs and directory size) on the entire object system when objects are small [23] .
8-33:Instead, solo commit uses coarse grain page version numbers to identify fine grain object versions .
8-34:A page version number is incremented at a server when at transaction that modifies objects on the page commits .
8-35:Updates committed by a single transaction and corresponding invalidations are therefore uniquely identified by the modified page version number .
8-36:Page version numbers are propagated to clients in fetch replies, commit replies and with invalidations, and clients include page version numbers in commit requests sent to the servers .
8-37:If a transaction fails validation due to missing group acknowledgement, the server checks page version numbers of the objects in the transaction read set and allows the transaction to commit if the client has read from the latest page version .
8-38:The page version numbers enable independent commits but page version checks only detect page level conflicts .
8-39:To detect object level conflicts and avoid the problem of false sharing we need the acknowledged invalidations .
8-40:Section 4 describes the details of the implementation of solo commit support for fine grain sharing .
8-41:3.4 Group Configuration The BuddyCache architecture supports multiple concurrent peer groups .
8-42:Potentially, it may be faster to access data cached in another peer group than to access a remote server .
8-43:In such case extending BuddyCache protocols to support multi level peer caching could be worthwhile .
8-44:We have not pursued this possibility for several reasons .
8-45:In web caching workloads, simply increasing the population of clients in a proxy cache often increases the overall cache hit rate [30] .
8-46:In BuddyCache applications, however, we expect sharing to result mainly from explicit client interaction and collaboration, suggesting that inter group fetching is unlikely to occur .
8-47:Moreover, measurements from multi level web caching systems [9] indicate that a multilevel system may not be advantageous unless the network connection between the peer groups is very fast .
8-48:We are primarily interested in environments where closely collaborating peers have fast close range connectivity, but the connection between peer groups may be slow .
8-49:As a result, we decided that support for inter group fetching in BuddyCache is not a high priority right now .
8-50:To support heterogenous resource rich and resource poor peers, the BuddyCache redirector can be configured to run either in one of the peer nodes or, when available, in a separate node within the site infrastructure .
8-51:Moreover, in a resource rich infrastructure node, the redirector can be configured as a stand by peer cache to receive pages fetched by other peers, emulating a central cache somewhat similar to a regional web proxy cache .
8-52:From the BuddyCache cache coherence protocol point of view, however, such a stand by peer cache is equivalent to a regular peer cache and therefore we do not consider this case separately in the discussion in this paper. .
9 IMPLEMENTATION :
9-1:In this section we provide the details of the BuddyCache implementation .
9-2:We have implemented BuddyCache in the Thor client server object oriented database [23] .
9-3:Thor supports high performance access to distributed objects and therefore provides a good test platform to investigate BuddyCache performance .
9-4:30 4.1 Base Storage System Thor servers provide persistent storage for objects and clients cache copies of these objects .
9-5:Applications run at the clients and interact with the system by making calls on methods of cached objects .
9-6:All method calls occur within atomic transactions .
9-7:Clients communicate with servers to fetch pages or to commit a transaction .
9-8:The servers have a disk for storing persistent objects, a stable transaction log, and volatile memory .
9-9:The disk is organized as a collection of pages which are the units of disk access .
9-10:The stable log holds commit information and object modifications for committed transactions .
9-11:The server memory contains cache directory and a recoverable modified object cache called the MOB .
9-12:The directory keeps track of which pages are cached by which clients .
9-13:The MOB holds recently modified objects that have not yet been written back to their pages on disk .
9-14:As MOB fills up, a background process propagates modified objects to the disk [21, 26] .
9-15:4.2 Base Cache Coherence Transactions are serialized using optimistic concurrency control OCC [3] described in Section 3.1 .
9-16:We provide some of the relevant OCC protocol implementation details .
9-17:The client keeps track of objects that are read and modified by its transaction; it sends this information, along with new copies of modified objects, to the servers when it tries to commit the transaction .
9-18:The servers determine whether the commit is possible, using a two phase commit protocol if the transaction used objects at multiple servers .
9-19:If the transaction commits, the new copies of modified objects are appended to the log and also inserted in the MOB .
9-20:The MOB is recoverable, i.e .
9-21:if the server crashes, the MOB is reconstructed at recovery by scanning the log .
9-22:Since objects are not locked before being used, a transaction commit can cause caches to contain obsolete objects .
9-23:Servers will abort a transaction that used obsolete objects .
9-24:However, to reduce the probability of aborts, servers notify clients when their objects become obsolete by sending them invalidation messages; a server uses its directory and the information about the committing transaction to determine what invalidation messages to send .
9-25:Invalidation messages are small because they simply identify obsolete objects .
9-26:Furthermore, they are sent in the background, batched and piggybacked on other messages .
9-27:When a client receives an invalidation message, it removes obsolete objects from its cache and aborts the current transaction if it used them .
9-28:The client continues to retain pages containing invalidated objects; these pages are now incomplete with holes in place of the invalidated objects .
9-29:Performing invalidation on an object basis means that false sharing does not cause unnecessary aborts; keeping incomplete pages in the client cache means that false sharing does not lead to unnecessary cache misses .
9-30:Clients acknowledge invalidations to indicate removal of stale data as explained in Section 3.1 .
9-31:Invalidation messages prevent some aborts, and accelerate those that must happen thus wasting less work and oﬄoading detection of aborts from servers to clients .
9-32:When a transaction aborts, its client restores the cached copies of modified objects to the state they had before the transaction started; this is possible because a client makes a copy of an object the first time it is modified by a transaction .
9-33:4.3 Redirection The redirector runs on the same local network as the peer group, in one of the peer nodes, or in a special node within the infrastructure .
9-34:It maintains a directory of pages available in the peer group and provides fast centralized fetch redirection (see figure 2) between the peer caches .
9-35:To improve performance, clients inform the redirector when they evict pages or objects by piggybacking that information on messages sent to the redirector .
9-36:To ensure up to date objects are fetched from the group cache the redirector tracks the status of the pages .
9-37:A cached page is either complete in which case it contains consistent values for all the objects, or incomplete, in which case some of the objects on a page are marked invalid .
9-38:Only complete pages are used by the peer fetch .
9-39:The protocol for maintaining page status when pages are updated and invalidated is described in Section 4.4 .
9-40:When a client request has to be processed at the servers, e.g., a complete requested page is unavailable in the peer group or a peer needs to commit a transaction, the redirector acts as a server proxy: it forwards the request to the server, and then forwards the reply back to the client .
9-41:In addition, in response to invalidations sent by a server, the redirector distributes the update or invalidation information to clients caching the modified page and, after all clients acknowledge, propagates the group acknowledgment back to the server (see figure 3) .
9-42:The redirector server protocol is, in effect, the client server protocol used in the base Thor storage system, where the combined peer group cache is playing the role of a single client cache in the base system .
9-43:4.4 Peer Update The peer update is implemented as follows .
9-44:An update commit request from a client arriving at the redirector contains the object updates .
9-45:Redirector retains the updates and propagates the request to the coordinator server .
9-46:After a transaction commits, using a two phase commit if needed, the coordinator server sends a commit reply to the redirector of the committing client group .
9-47:The redirector forwards the reply to the committing client .
9-48:It waits for the invalidations to arrive to propagate corresponding retained (committed) updates to the clients caching the modified pages (see figure 3.) Participating servers that are home to objects modified by the transaction generate object invalidations for each cache group that caches pages containing the modified objects (including the committing group) .
9-49:The invalidations are sent lazily to the redirectors to ensure that all the clients in the groups caching the modified objects get rid of the stale data .
9-50:In cache groups other than the committing group, redirectors propagates the invalidations to all the clients caching the modified pages, collect the client acknowledgments and after completing the collection, propagate collective acknowledgments back to the server .
9-51:Within the committing client group, the arriving invalidations are not propagated .
9-52:Instead, updates are sent to clients caching those objects" pages, the updates are acknowledged by the client, and the collective acknowledgment is propagated to the server .
9-53:An invalidation renders a cached page unavailable for peer fetch changing the status of a complete page p into an incomplete .
9-54:In contrast, an update of a complete page preserves the complete page status .
9-55:As shown by studies of the 31 fragment reconstruction [2], such update propagation allows to avoid the performance penalties of false sharing .
9-56:That is, when clients within a group modify different objects on the same page, the page retains its complete status and remains available for peer fetch .
9-57:Therefore, the effect of peer update is similar to eager fragment reconstruction [2] .
9-58:We have also considered the possibility of allowing a peer to fetch an incomplete page (with invalid objects marked accordingly) but decided against this possibility because of the extra complexity involved in tracking invalid objects .
9-59:4.5 Vcache The solo commit validation protocol allows clients with up to date objects to commit independently of slower (or failed) group members .
9-60:As explained in Section 3.3, the solo commit protocol allows a transaction T to pass validation if extra coherence information supplied by the client indicates that transaction T has read up to date objects .
9-61:Clients use page version numbers to provide this extra coherence information .
9-62:That is, a client includes the page version number corresponding to each object in the read object set sent in the commit request to the server .
9-63:Since a unique page version number corresponds to each committed object update, the page version number associated with an object allows the validation procedure at the server to check if the client transaction has read up to date objects .
9-64:The use of coarse grain page versions to identify object versions avoids the high penalty of maintaining persistent object versions for small objects, but requires an extra protocol at the client to maintain the mapping from a cached object to the identifying page version (ObjectToVersion) .
9-65:The main implementation issue is concerned with maintaining this mapping efficiently .
9-66:At the server side, when modifications commit, servers associate page version numbers with the invalidations .
9-67:At validation time, if an unacknowledged invalidation is pending for an object x read by a transaction T, the validation procedure checks if the version number for x in T"s read set matches the version number for highest pending invalidation for x, in which case the object value is current, otherwise T fails validation .
9-68:We note again that the page version number based checks, and the invalidation acknowledgment based checks are complimentary in the solo commit validation and both are needed .
9-69:The page version number check allows the validation to proceed before invalidation acknowledgments arrive but by itself a page version number check detects page level conflicts and is not sufficient to support fine grain coherence without the object level invalidations .
9-70:We now describe how the client manages the mapping ObjectToVersion .
9-71:The client maintains a page version number for each cached page .
9-72:The version number satisfies the following invariant V P about the state of objects on a page: if a cached page P has a version number v, then the value of an object o on a cached page P is either invalid or it reflects at least the modifications committed by transactions preceding the transaction that set P"s version number to v .
9-73:New object values and new page version numbers arrive when a client fetches a page or when a commit reply or invalidations arrive for this page .
9-74:The new object values modify the page and, therefore, the page version number needs to be updated to maintain the invariant V P .
9-75:A page version number that arrives when a client fetches a page, replaces Object Version x 8 Redirector Server 1Client 1 com(P(x,6),Q(y,9)) com(P(x,6),Q(y,9)) ok(P(x,8),Q(y,10)) ok(P(x,8),Q(y,10)) inv(Q(s,11)) inv(Q(s,11)) inv(P(r,7) inv(P(r,7) Server 2 Figure 5: Reordered Invalidations the page version number for this page .
9-76:Such an update preserves the invariant V P .
9-77:Similarly, an in sequence page version number arriving at the client in a commit or invalidation message advances the version number for the entire cached page, without violating V P .
9-78:However, invalidations or updates and their corresponding page version numbers can also arrive at the client out of sequence, in which case updating the page version number could violate V P .
9-79:For example, a commit reply for a transaction that updates object x on page P in server S1, and object y on page Q in server S2, may deliver a new version number for P from the transaction coordinator S1 before an invalidation generated for an earlier transaction that has modified object r on page P arrives from S1 (as shown in figure 5) .
9-80:The cache update protocol ensures that the value of any object o in a cached page P reflects the update or invalidation with the highest observed version number .
9-81:That is, obsolete updates or invalidations received out of sequence do not affect the value of an object .
9-82:To maintain the ObjectToVersion mapping and the invariant V P in the presence of out of sequence arrival of page version numbers, the client manages a small version number cache vcache that maintains the mapping from an object into its corresponding page version number for all reordered version number updates until a complete page version number sequence is assembled .
9-83:When the missing version numbers for the page arrive and complete a sequence, the version number for the entire page is advanced .
9-84:The ObjectToVersion mapping, including the vcache and page version numbers, is used at transaction commit time to provide version numbers for the read object set as follows .
9-85:If the read object has an entry in the vcache, its version number is equal to the highest version number in the vcache for this object .
9-86:If the object is not present in the vcache, its version number is equal the version number of its containing cached page .
9-87:Figure 6 shows the ObjectToVersion mapping in the client cache, including the page version numbers for pages and the vcache .
9-88:Client can limit vcache size as needed since re fetching a page removes all reordered page version numbers from the vcache .
9-89:However, we expect version number reordering to be uncommon and therefore expect the vcache to be very small. .
10 BUDDYCACHE FAILOVER :
10-1:A client group contains multiple client nodes and a redi32 VersionPageObject Version VCache Client Cache Client Page Cache Figure 6: ObjectToVersion map with vcache rector that can fail independently .
10-2:The goal of the failover protocol is to reconfigure the BuddyCache in the case of a node failure, so that the failure of one node does not disrupt other clients from accessing shared objects .
10-3:Moreover, the failure of the redirector should allow unaffected clients to keep their caches intact .
10-4:We have designed a failover protocols for BuddyCache but have not implemented it yet .
10-5:The appendix outlines the protocol. .
11 PERFORMANCE EVALUATION :
11-1:BuddyCache redirection supports the performance benefits of avoiding communication with the servers but introduces extra processing cost due to availability mechanisms and request forwarding .
11-2:Is the cure worse then the disease? To answer the question, we have implemented a BuddyCache prototype for the OCC protocol and conducted experiments to analyze the performance benefits and costs over a range of network latencies .
11-3:6.1 Analysis The performance benefits of peer fetch and peer update are due to avoided server interactions .
11-4:This section presents a simple analytical performance model for this benefit .
11-5:The avoided server interactions correspond to different types of client cache misses .
11-6:These can be cold misses, invalidation misses and capacity misses .
11-7:Our analysis focuses on cold misses and invalidation misses, since the benefit of avoiding capacity misses can be derived from the cold misses .
11-8:Moreover, technology trends indicate that memory and storage capacity will continue to grow and therefore a typical BuddyCache configuration is likely not to be cache limited .
11-9:The client cache misses are determined by several variables, including the workload and the cache configuration .
11-10:Our analysis tries, as much as possible, to separate these variables so they can be controlled in the validation experiments .
11-11:To study the benefit of avoiding cold misses, we consider cold cache performance in a read only workload (no invalidation misses) .
11-12:We expect peer fetch to improve the latency cost for client cold cache misses by fetching objects from nearby cache .
11-13:We evaluate how the redirection cost affects this benefit by comparing and analyzing the performance of an application running in a storage system with BuddyCache and without (called Base) .
11-14:To study the benefit of avoiding invalidation misses, we consider hot cache performance in a workload with modifications (with no cold misses) .
11-15:In hot caches we expect BuddyCache to provide two complementary benefits, both of which reduce the latency of access to shared modified objects .
11-16:Peer update lets a client access an object modified by a nearby collaborating peer without the delay imposed by invalidation only protocols .
11-17:In groups where peers share a read only interest in the modified objects, peer fetch allows a client to access a modified object as soon as a collaborating peer has it, which avoids the delay of server fetch without the high cost imposed by the update only protocols .
11-18:Technology trends indicate that both benefits will remain important in the foreseeable future .
11-19:The trend toward increase in available network bandwidth decreases the cost of the update only protocols .
11-20:However, the trend toward increasingly large caches, that are updated when cached objects are modified, makes invalidation base protocols more attractive .
11-21:To evaluate these two benefits we consider the performance of an application running without BuddyCache with an application running BuddyCache in two configurations .
11-22:One, where a peer in the group modifies the objects, and another where the objects are modified by a peer outside the group .
11-23:Peer update can also avoid invalidation misses due to false sharing, introduced when multiple peers update different objects on the same page concurrently .
11-24:We do not analyze this benefit (demonstrated by earlier work [2]) because our benchmarks do not allow us to control object layout, and also because this benefit can be derived given the cache hit rate and workload contention .
11-25:6.1.1 The Model The model considers how the time to complete an execution with and without BuddyCache is affected by invalidation misses and cold misses .
11-26:Consider k clients running concurrently accessing uniformly a shared set of N pages in BuddyCache and Base .
11-27:Let tfetch(S), tredirect(S), tcommit(S), and tcompute(S) be the time it takes a client to, respectively, fetch from server, peer fetch, commit a transaction and compute in a transaction, in a system S, where S is either a system with BuddyCache or without (Base) .
11-28:For simplicity, our model assumes the fetch and commit times are constant .
11-29:In general they may vary with the server load, e.g .
11-30:they depend on the total number of clients in the system .
11-31:The number of misses avoided by peer fetch depends on k, the number of clients in the BuddyCache, and on the client co interest in the shared data .
11-32:In a specific BuddyCache execution it is modeled by the variable r, defined as a number of fetches arriving at the redirector for a given version of page P (i.e .
11-33:until an object on the page is invalidated) .
11-34:Consider an execution with cold misses .
11-35:A client starts with a cold cache and runs read only workload until it accesses all N pages while committing l transactions .
11-36:We assume there are no capacity misses, i.e .
11-37:the client cache is large enough to hold N pages .
11-38:In BC, r cold misses for page P reach the redirector .
11-39:The first of the misses fetches P from the server, and the subsequent r − 1 misses are redirected .
11-40:Since each client accesses the entire shared set r = k .
11-41:Let Tcold(Base) and Tcold(BC) be the time it takes to complete the l transactions in Base and BC .
11-42:33 Tcold(Base) = N ∗ tfetch(Base) +(tcompute + tcommit(Base)) ∗ l (1) Tcold(BC) = N ∗ 1 k ∗ tfetch(BC) + (1 − 1 k ) ∗ tredirect +(tcompute + tcommit(BC)) ∗ l (2) Consider next an execution with invalidation misses .
11-43:A client starts with a hot cache containing the working set of N pages .
11-44:We focus on a simple case where one client (writer) runs a workload with modifications, and the other clients (readers) run a read only workload .
11-45:In a group containing the writer (BCW ), peer update eliminates all invalidation misses .
11-46:In a group containing only readers (BCR), during a steady state execution with uniform updates, a client transaction has missinv invalidation misses .
11-47:Consider the sequence of r client misses on page P that arrive at the redirector in BCR between two consequent invalidations of page P .
11-48:The first miss goes to the server, and the r − 1 subsequent misses are redirected .
11-49:Unlike with cold misses, r ≤ k because the second invalidation disables redirection for P until the next miss on P causes a server fetch .
11-50:Assuming uniform access, a client invalidation miss has a chance of 1 r to be the first miss (resulting in server fetch), and a chance of (1 − 1 r) to be redirected .
11-51:Let Tinval(Base), Tinval(BCR) and Tinval(BCW ) be the time it takes to complete a single transaction in the Base, BCR and BCW systems .
11-52:Tinval(Base) = missinv ∗ tfetch(Base) +tcompute + tcommit(Base) (3) Tinval(BCR) = missinv ∗ ( 1 r ∗ tfetch(BCR) +(1 − 1 r ) ∗ tredirect(BCR)) +tcompute + tcommit(BCR) (4) Tinval(BCW ) = tcompute + tcommit(BCW ) (5) In the experiments described below, we measure the parameters N, r, missinv, tfetch(S), tredirect(S), tcommit(S), and tcompute(S) .
11-53:We compute the completion times derived using the above model and derive the benefits .
11-54:We then validate the model by comparing the derived values to the completion times and benefits measured directly in the experiments .
11-55:6.2 Experimental Setup Before presenting our results we describe our experimental setup .
11-56:We use two systems in our experiments .
11-57:The Base system runs Thor distributed object storage system [23] with clients connecting directly to the servers .
11-58:The Buddy system runs our implementation of BuddyCache prototype in Thor, supporting peer fetch, peer update, and solo commit, but not the failover .
11-59:Our workloads are based on the multi user OO7 benchmark [8]; this benchmark is intended to capture the characteristics of many different multi user CAD CAM CASE applications, but does not model any specific application .
11-60:We use OO7 because it is a standard benchmark for measuring object storage system performance .
11-61:The OO7 database contains a tree of assembly objects with leaves pointing to three composite parts chosen randomly from among 500 such objects .
11-62:Each composite part contains a graph of atomic parts linked by connection objects; each atomic part has 3 outgoing connections .
11-63:We use a medium database that has 200 atomic parts per composite part .
11-64:The multi user database allocates for each client a private module consisting of one tree of assembly objects, and adds an extra shared module that scales proportionally to the number of clients .
11-65:We expect a typical BuddyCache configuration not to be cache limited and therefore focus on workloads where the objects in the client working set fit in the cache .
11-66:Since the goal of our study is to evaluate how effectively our techniques deal with access to shared objects, in our study we limit client access to shared data only .
11-67:This allows us to study the effect our techniques have on cold cache and cache consistency misses and isolate as much as possible the effect of cache capacity misses .
11-68:To keep the length of our experiments reasonable, we use small caches .
11-69:The OO7 benchmark generates database modules of predefined size .
11-70:In our implementation of OO7, the private module size is about 38MB .
11-71:To make sure that the entire working set fits into the cache we use a single private module and choose a cache size of 40MB for each client .
11-72:The OO7 database is generated with modules for 3 clients, only one of which is used in our experiments as we explain above .
11-73:The objects in the database are clustered in 8K pages, which are also the unit of transfer in the fetch requests .
11-74:We consider two types of transaction workloads in our analysis, read only and read write .
11-75:In OO7 benchmark, read only transactions use the T1 traversal that performs a depth first traversal of entire composite part graph .
11-76:Write transactions use the T2b traversal that is identical to T1 except that it modifies all the atomic parts in a single composite .
11-77:A single transaction includes one traversal and there is no sleep time between transactions .
11-78:Both read only and read write transactions always work with data from the same module .
11-79:Clients running read write transactions don"t modify in every transaction, instead they have a 50% probability of running read only transactions .
11-80:The database was stored by a server on a 40GB IBM 7200RPM hard drive, with a 8.5 average seek time and 40 MB sec data transfer rates .
11-81:In Base system clients connect directly to the database .
11-82:In Buddy system clients connect to the redirector that connects to the database .
11-83:We run the experiments with 1 10 clients in Base, and one or two 1 10 client groups in Buddy .
11-84:The server, the clients and the redirectors ran on a 850MHz Intel Pentium III processor based PC, 512MB of memory, and Linux Red Hat 6.2 .
11-85:They were connected by a 100Mb s Ethernet .
11-86:The server was configured with a 50MB cache (of which 6MB were used for the modified object buffer), the client had a 40MB cache .
11-87:The experiments ran in Utah experimental testbed emulab.net [1] .
11-88:34 Latency [ms] Base Buddy 3 group 5 group 3 group 5 group Fetch 1.3 1.4 2.4 2.6 Commit 2.5 5.5 2.4 5.7 Table 1: Commit and Server fetch Operation Latency [ms] PeerFetch 1.8 5.5 −AlertHelper 0.3 4.6 −CopyUnswizzle 0.24 −CrossRedirector 0.16 Table 2: Peer fetch 6.3 Basic Costs This section analyzes the basic cost of the requests in the Buddy system during the OO7 runs .
11-89:6.3.1 Redirection Fetch and commit requests in the BuddyCache cross the redirector, a cost not incurred in the Base system .
11-90:For a request redirected to the server (server fetch) the extra cost of redirection includes a local request from the client to redirector on the way to and from the server .
11-91:We evaluate this latency overhead indirectly by comparing the measured latency of the Buddy system server fetch or commit request with the measured latency of the corresponding request in the Base system .
11-92:Table 1 shows the latency for the commit and server fetch requests in the Base and Buddy system for 3 client and 5 client groups in a fast local area network .
11-93:All the numbers were computed by averaging measured request latency over 1000 requests .
11-94:The measurements show that the redirection cost of crossing the redirector in not very high even in a local area network .
11-95:The commit cost increases with the number of clients since commits are processed sequentially .
11-96:The fetch cost does not increase as much because the server cache reduces this cost .
11-97:In a large system with many groups, however, the server cache becomes less efficient .
11-98:To evaluate the overheads of the peer fetch, we measure the peer fetch latency (PeerFetch) at the requesting client and break down its component costs .
11-99:In peer fetch, the cost of the redirection includes, in addition to the local network request cost, the CPU processing latency of crossing the redirector and crossing the helper, the latter including the time to process the help request and the time to copy, and unswizzle the requested page .
11-100:We directly measured the time to copy and unswizzle the requested page at the helper, (CopyUnswizzle), and timed the crossing times using a null crossing request .
11-101:Table 2 summarizes the latencies that allows us to break down the peer fetch costs .
11-102:CrossRedirector, includes the CPU latency of crossing the redirector plus a local network round trip and is measured by timing a round trip null request issued by a client to the redirector .
11-103:AlertHelper, includes the time for the helper to notice the request plus a network roundtrip, and is measured by timing a round trip null request issued from an auxiliary client to the helper client .
11-104:The local network latency is fixed and less than 0.1 ms .
11-105:The AlertHelper latency which includes the elapsed time from the help request arrival until the start of help request processing is highly variable and therefore contributes to the high variability of the PeerFetch time .
11-106:This is because the client in Buddy system is currently single threaded and therefore only starts processing a help request when blocked waiting for a fetch or commit reply .
11-107:This overhead is not inherent to the BuddyCache architecture and could be mitigated by a multi threaded implementation in a system with pre emptive scheduling .
11-108:6.3.2 Version Cache The solo commit allows a fast client modifying an object to commit independently of a slow peer .
11-109:The solo commit mechanism introduces extra processing at the server at transaction validation time, and extra processing at the client at transaction commit time and at update or invalidation processing time .
11-110:The server side overheads are minimal and consist of a page version number update at commit time, and a version number comparison at transaction validation time .
11-111:The version cache has an entry only when invalidations or updates arrive out of order .
11-112:This may happen when a transaction accesses objects in multiple servers .
11-113:Our experiments run in a single server system and therefore, the commit time overhead of version cache management at the client does not contribute in the results presented in the section below .
11-114:To gauge these client side overheads in a multiple server system, we instrumented the version cache implementation to run with a workload trace that included reordered invalidations and timed the basic operations .
11-115:The extra client commit time processing includes a version cache lookup operation for each object read by the transaction at commit request preparation time, and a version cache insert operation for each object updated by a transaction at commit reply processing time, but only if the updated page is missing some earlier invalidations or updates .
11-116:It is important that the extra commit time costs are kept to a minimum since client is synchronously waiting for the commit completion .
11-117:The measurements show that in the worst case, when a large number of invalidations arrive out of order, and about half of the objects modified by T2a (200 objects) reside on reordered pages, the cost of updating the version cache is 0.6 ms .
11-118:The invalidation time cost are comparable, but since invalidations and updates are processed in the background this cost is less important for the overall performance .
11-119:We are currently working on optimizing the version cache implementation to further reduce these costs .
11-120:6.4 Overall Performance This section examines the performance gains seen by an application running OO7 benchmark with a BuddyCache in a wide area network .
11-121:6.4.1 Cold Misses To evaluate the performance gains from avoiding cold misses we compare the cold cache performance of OO7 benchmark running read only workload in the Buddy and Base systems .
11-122:We derive the times by timing the execution of the systems in the local area network environment and substituting 40 ms and 80 ms delays for the requests crossing the redirector and the server to estimate the performance in the wide area network .
11-123:Figures 7 and 8 show the overall time to complete 1000 cold cache transactions .
11-124:The numbers were 35 0 5 0 100 150 200 250 Base Buddy Base Buddy Base Buddy 3 Clients 5 Clients 10 Clients [ms] CPU Commit Server Fetch Peer Fetch Figure 7: Breakdown for cold read only 40ms RTT 0 5 0 100 150 200 250 300 350 400 Base Buddy Base Buddy Base Buddy 3 Clients 5 Clients 10 Clients [ms] CPU Commit Server Fetch Peer Fetch Figure 8: Breakdown for cold read only 80ms RTT obtained by averaging the overall time of each client in the group .
11-125:The results show that in a 40 ms network Buddy system reduces significantly the overall time compared to the Base system, providing a 39% improvement in a three client group, 46% improvement in the five client group and 56% improvement in the ten client case .
11-126:The overall time includes time spent performing client computation, direct fetch requests, peer fetches, and commit requests .
11-127:In the three client group, Buddy and Base incur almost the same commit cost and therefore the entire performance benefit of Buddy is due to peer fetch avoiding direct fetches .
11-128:In the five and ten client group the server fetch cost for individual client decreases because with more clients faulting in a fixed size shared module into BuddyCache, each client needs to perform less server fetches .
11-129:Figure 8 shows the overall time and cost break down in the 80 ms network .
11-130:The BuddyCache provides similar performance improvements as with the 40ms network .
11-131:Higher network latency increases the relative performance advantage provided by peer fetch relative to direct fetch but this benefit is offset by the increased commit times .
11-132:Figure 9 shows the relative latency improvement provided by BuddyCache (computed as the overall measured time difference between Buddy and Base relative to Base) as a 10% 0% 10% 20% 30% 40% 50% 60% 70% 1 5 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 100 Latency [ms] 3 Clients 3 Clients (Perf model) 5 Clients 5 Clients (Perf model) 10 Clients 10 FEs (perf model) Figure 9: Cold miss benefit 0 2 0 4 0 6 0 8 0 100 120 140 Base Buddy Reader Buddy Writer [ms] CPU Commit Server Fetch Peer Fetch Figure 10: Breakdown for hot read write 40ms RTT function of network latency, with a fixed server load .
11-133:The cost of the extra mechanism dominates BuddyCache benefit when network latency is low .
11-134:At typical Internet latencies 20ms 60ms the benefit increases with latency and levels off around 60ms with significant (up to 62% for ten clients) improvement .
11-135:Figure 9 includes both the measured improvement and the improvement derived using the analytical model.Remarkably, the analytical results predict the measured improvement very closely, albeit being somewhat higher than the empirical values .
11-136:The main reason why the simplified model works well is it captures the dominant performance component, network latency cost .
11-137:6.4.2 Invalidation Misses To evaluate the performance benefits provided by BuddyCache due to avoided invalidation misses, we compared the hot cache performance of the Base system with two different Buddy system configurations .
11-138:One of the Buddy system configurations represents a collaborating peer group modifying shared objects (Writer group), the other represents a group where the peers share a read only interest in the modified objects (Reader group) and the writer resides outside the BuddyCache group .
11-139:In each of the three systems, a single client runs a readwrite workload (writer) and three other clients run read only workload (readers) .
11-140:Buddy system with one group contain36 0 5 0 100 150 200 250 300 Base Buddy Reader Buddy Writer [ms] CPU Commit Server Fetch Peer Fetch Figure 11: Breakdown for hot read write 80ms RTT ing a single reader and another group containing two readers and one writer models the Writer group .
11-141:Buddy system with one group containing a single writer and another group running three readers models the Reader group .
11-142:In Base, one writer and three readers access the server directly .
11-143:This simple configuration is sufficient to show the impact of BuddyCache techniques .
11-144:Figures 10 and 11 show the overall time to complete 1000 hot cache OO7 read only transactions .
11-145:We obtain the numbers by running 2000 transactions to filter out cold misses and then time the next 1000 transactions .
11-146:Here again, the reported numbers are derived from the local area network experiment results .
11-147:The results show that the BuddyCache reduces significantly the completion time compared to the Base system .
11-148:In a 40 ms network, the overall time in the Writer group improves by 62% compared to Base .
11-149:This benefit is due to peer update that avoids all misses due to updates .
11-150:The overall time in the Reader group improves by 30% and is due to peer fetch that allows a client to access an invalidated object at the cost of a local fetch avoiding the delay of fetching from the server .
11-151:The latter is an important benefit because it shows that on workloads with updates, peer fetch allows an invalidation based protocol to provide some of the benefits of update based protocol .
11-152:Note that the performance benefit delivered by the peer fetch in the Reader group is approximately 50% less than the performance benefit delivered by peer update in the Writer group .
11-153:This difference is similar in 80ms network .
11-154:Figure 12 shows the relative latency improvement provided by BuddyCache in Buddy Reader and Buddy Writer configurations (computed as the overall time difference between BuddyReader and Base relative to Base, and Buddy Writer and Base relative to Base) in a hot cache experiment as a function of increasing network latency, for fixed server load .
11-155:The peer update benefit dominates overhead in Writer configuration even in low latency network (peer update incurs minimal overhead) and offers significant 44 64% improvement for entire latency range .
11-156:The figure includes both the measured improvement and the improvement derived using the analytical model .
11-157:As in cold cache experiments, here the analytical results predict the measured improvement closely .
11-158:The difference is 10% 0% 10% 20% 30% 40% 50% 60% 70% 1 5 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 100 Latency [ms] Benefits[%] Buddy Reader Buddy Reader (perf model) Buddy Writer Buddy Writer (perf model) Figure 12: Invalidation miss benefit minimal in the "writer group", and somewhat higher in the "reader group" (consistent with the results in the cold cache experiments) .
11-159:As in cold cache case, the reason why the simplified analytical model works well is because it captures the costs of network latency, the dominant performance cost. .
12 CONCLUSION :
12-1:Collaborative applications provide a shared work environment for groups of networked clients collaborating on a common task .
12-2:They require strong consistency for shared persistent data and efficient access to fine grained objects .
12-3:These properties are difficult to provide in wide area network because of high network latency .
12-4:This paper described BuddyCache, a new transactional cooperative caching [20, 16, 13, 2, 28] technique that improves the latency of access to shared persistent objects for collaborative strong consistency applications in high latency network environments .
12-5:The technique improves performance yet provides strong correctness and availability properties in the presence of node failures and slow clients .
12-6:BuddyCache uses redirection to fetch missing objects directly from group members caches, and to support peer update, a new lightweight application level multicast technique that gives group members consistent access to the new data committed within the collaborating group without imposing extra overhead outside the group .
12-7:Redirection, however, can interfere with object availability .
12-8:Solo commit, is a new validation technique that allows a client in a group to commit independently of slow or failed peers .
12-9:It provides fine grained validation using inexpensive coarse grain version information .
12-10:We have designed and implemented BuddyCache prototype in Thor distributed transactional object storage system [23] and evaluated the benefits and costs of the system over a range of network latencies .
12-11:Analytical results, supported by the system measurements using the multi user 007 benchmark indicate, that for typical Internet latencies BuddyCache provides significant performance benefits, e.g .
12-12:for latencies ranging from 40 to 80 milliseconds round trip time, clients using the BuddyCache can reduce by up to 50% the latency of access to shared objects compared to the clients accessing the repository directly .
12-13:The main contributions of the paper are: 37 fine grain strong consistency access in high latency environments, strong performance gains over the base system, evaluation of the costs and benefits of the new techniques capturing the dominant performance cost, high network latency. .
13-1:We are grateful to Jay Lepreau and the staff of Utah experimental testbed emulab.net [1], especially Leigh Stoller, for hosting the experiments and the help with the testbed
13-2:We also thank Jeff Chase, Maurice Herlihy, Butler Lampson and the OOPSLA reviewers for the useful comments that improved this paper.
14-1:"emulab.net", the Utah Network Emulation Facility
14-2:http:  www.emulab.net
14-3:A
14-4:Adya, M
14-5:Castro, B
14-6:Liskov, U
14-7:Maheshwari, and L
14-8:Shrira
14-9:Fragment Reconstruction: Providing Global Cache Coherence in a Transactional Storage System
14-10:Proceedings of the International Conference on Distributed Computing Systems, May 1997
14-11:A
14-12:Adya, R
14-13:Gruber, B
14-14:Liskov, and U
14-15:Maheshwari
14-16:Efficient optimistic concurrencty control using loosely synchronized clocks
14-17:In Proceedings of the ACM SIGMOD International Conference on Management of Data, May 1995
14-18:C
14-19:Amza, A.L
14-20:Cox, S
14-21:Dwarkadas, P
14-22:Keleher, H
14-23:Lu,
picture:
