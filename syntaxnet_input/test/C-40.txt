Edge Indexing in a Grid for Highly Dynamic Virtual 
content:
1 ABSTRACT :
1-1:Newly emerging game based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real time .
1-2:They are filled with autonomous, mutable virtual content which is continuously augmented by the users .
1-3:To make the systems highly scalable and dynamically extensible, they are usually built on a client server based grid subspace division where the virtual worlds are partitioned into manageable sub worlds .
1-4:In each sub world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium .
1-5:In such systems, the determination of the set of objects that are visible from a user"s viewpoint is one of the primary factors that affect server throughput and scalability .
1-6:Specifically, performing real time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub millions of active users are moving and interacting .
1-7:We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query .
1-8:Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments .
1-9:The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real time visibility determination .
1-10:We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization .
1-11:We expect our approach to lay the groundwork for next generation virtual frameworks that may merge into existing web based services in the near future .
1-12:Categories and Subject Descriptors: C.2.4 [Computer Communication Networks]: Distributed Systems Client server, Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next generation virtual environments .
1-13:Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real time rendering constraints at the client console side .
1-14:To enable a virtual landscape in next generation environments that is seamless, endless, and limitless, Marshall et al .
1-15:[1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability .
1-16:In this paper, we mainly focus on the first two requirements .
1-17:Dynamic extensibility allows regular game users to deploy their own created content .
1-18:This is a powerful concept, but unfortunately, user created content tends to create imbalances among the existing scene complexity, causing system wide performance problems .
1-19:Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers .
1-20:Another important requirement is scalability .
1-21:Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world .
1-22:By carefully partitioning the world into multiple sub worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported .
1-23:Typically, the maximum number of users in the same world managed by a single server or a server cluster is limited to several thousands, assuming a rather stationary world [2, 3] .
1-24:Second Life [4] is the first successfully deployed MMOG system that meets both requirements .
1-25:To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid like manner and 2 Originally, these requirements were specified for their dedicated platform .
1-26:But we acknowledge that these requirements are also valid for new virtual environments .
1-27:402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds .
1-28:employs a client server based 3D object streaming model [5] .
1-29:In this model, a server continuously transmits both update events and geometry data to every connected user .
1-30:As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space .
1-31:One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user .
1-32:The traditional visibility determination approach, however, has an object popping problem .
1-33:For example, a house outside a user"s visible range is not drawn at time t, illustrated in Figure 1(a) .
1-34:As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b) .
1-35:If Δ is small, or the house is large enough to collide with the user, it will disrupt the user"s navigational experience .
1-36:The visibility calculation for each user not only needs to be accurate, but also fast .
1-37:This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds .
1-38:To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing) .
1-39:Our two novel methods represent the main contributions of this work .
1-40:The organization of this paper is as follows .
1-41:Section 2 presents related work .
1-42:Section 3 describes our new view method .
1-43:In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real time visibility computations .
1-44:We also discuss its optimization issues .
1-45:Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments .
1-46:Finally, we conclude and address future research directions in Section 7. .
2 RELATED WORK :
2-1:Visibility determination has been widely explored in the field of 3D graphics .
2-2:Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline .
2-3:View frustum culling, back face culling, and occlusion culling are some of the well known visibility culling techniques [6] .
2-4:However, these algorithms assume that all the candidate visible objects have been stored locally .
2-5:If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases .
2-6:Teller et al .
2-7:described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a user"s navigational path [5] .
2-8:Funkhouser et al .
2-9:showed that multi resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7] .
2-10:However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments .
2-11:On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities .
2-12:In the graphics area, there has been little work on supporting real time visibility computations for a massive number of moving objects and users .
2-13:Here we recognize that such graphics related issues have a very close similarity to spatial database problems .
2-14:Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments .
2-15:To support frequent updates, two partitioning policies have been studied in depth: (1) R tree based spatial indexing, and (2) grid based spatial indexing .
2-16:The R tree is a well known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles .
2-17:The grid based partitioning model is a special case of fixed partitioning .
2-18:Recently, it has been re discovered since it can be efficient in highly dynamic environments .
2-19:Many studies have reported that the R tree and its variants (R+ tree, R∗ tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12] .
2-20:A bottom up update strategy proposed for R trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism .
2-21:Instead of traversing a tree from the root node for frequent update requests (top down approach), it directly accesses the leaf node of the object to be updated via an object hash table .
2-22:Q Index [13, 11] is one of the earlier work that re discovers the usefulness of grid based space partitioning for emerging moving object environments .
2-23:In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely .
2-24:The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast moving objects are indexed in a Quadtree and quasi stationary objects are stored in an R∗ tree .
2-25:SINA [10] was proposed to provide efficient query evaluations for any combination of stationary moving objects and stationary moving queries .
2-26:Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently .
2-27:Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al .
2-28:[12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects .
2-29:As long as any object resides in this region, all the query results are guaranteed to be valid in the system .
2-30:If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re evaluated on the fly .
2-31:Our indexing method is very similar to the above approaches .
2-32:The major difference is that we are more concentrating on real time visibility determination while others assume loose timing constraints. .
3 OBJECT INITIATED VIEW MODEL :
3-1:In this section we illustrate how the object popping problem can be associated with a typical view decision model .
3-2:We then propose our own model, and finally we discuss its strengths and limitations .
3-3:To begin with, we define the terminologies commonly used throughout this paper .
3-4:Entities in a virtual space can be categorized into three types 403 based on their role autonomous entities, spectator entities, and avatars .
3-5:The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities .
3-6:The spectator entity corresponds to a player"s viewpoint, but is invisible to other entities .
3-7:It has no shape and is represented only by a point location .
3-8:It is designed to allow a game participant to see from a third person viewpoint .
3-9:It functions similar to a camera control in the 3D graphics field .
3-10:It also has a higher degree of mobility than other entities .
3-11:The avatar represents a normal game user who can freely navigate in the space and interact with other entities .
3-12:It possesses both features: its own viewpoint and visibility .
3-13:For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity .
3-14:The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence .
3-15:It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility .
3-16:Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other .
3-17:To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest whose center is the location of an entity .
3-18:Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area .
3-19:However, we employ a squareshaped AOI at the expense of accuracy because the square shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world .
3-20:The traditional view model, which we call user initiated view model, assumes that a user entity has an AOI while an object entity does not .
3-21:As the user navigates, she continuously searches for all the entities within her AOI .
3-22:Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model .
3-23:However, the user initiated model has a serious object popping problem during navigation .
3-24:Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t .
3-25:In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t .
3-26:Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely .
3-27:A large AOI, however, may lead to a significant system degradation .
3-28:To overcome the object popping problem, we propose a new view model which we call object initiated view model .
3-29:All object entities have their own AOI centered at their current location while all spectator entities have no AOI .
3-30:Every user entity recognizes the objects whose AOIs cover its point location .
3-31:The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes .
3-32:A huge object may have a farther visible range than a small one; an object has a broader visible range during day time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure .
3-33:One of the potential arguments against the object initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user initiated view .
3-34:We agree E2 E1 A S Client S Client A Sub world Server Figure 2: Target system in a 4 × 4 grid partition .
3-35:that existing spatial indexing methods are inefficient in supporting our view model .
3-36:To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4 .
3-37:Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real time .
3-38:For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .
3-39:Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image .
3-40:In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. .
4 4.2 Abstraction :
4-1:In Section 4.1 we introduce our target application model .
4-2:Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4 .
4-3:Several optimization issues for edge indexing follow in Section 4.5 .
4-4:4.1 Target Application Our target application assumes both 3D object streaming and sub world hosting .
4-5:The sub world hosting is a collaborative virtual environment where every server hosts one sub world, thus constructing a single world .
4-6:Second Life is the classic example of such an approach .
4-7:A virtual space is partitioned into equal sized sub worlds .
4-8:The sample sub world separated with bold dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A .
4-9:As mentioned in Section 3, all object entities (E1, E2, A) have their own square shaped AOI .
4-10:Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure) .
4-11:The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R .
4-12:Every sub world is managed by its dedicated server machine .
4-13:Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities .
4-14:For efficient management of moving entities, a server further divides its sub world into smaller partitions, called grid cells .
4-15:Figure 2 shows the 4 × 4 grid enclosed by the dashed lines .
4-16:Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells .
4-17:Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress .
4-18:404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2 .
4-19:There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world .
4-20:livery of the indices stored on the cell it is located in .
4-21:This retrieval process is interchangeably called a user (or query) evaluation .
4-22:Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities that is, how many entities per sub world are indexed and how quickly index updates are recognized and retrieved .
4-23:Efficient delivery of retrieved real geometry data is out of the scope of this paper .
4-24:4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell .
4-25:In our application, we use three types of tokens: Inclusion Token indicates that its entity overlaps with or is covered by the given cell .
4-26:Appearance Token denotes that its entity is an IT for the given cell, but not for the previously adjacent cell .
4-27:Disappearance Token is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell .
4-28:We also define two data structures for storing and retrieving the tokens: a node and an edge .
4-29:A node is a data structure that stores ITs of a cell .
4-30:Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region .
4-31:An edge is another data structure for two adjacent cells that stores their ATs or DTs .
4-32:If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge .
4-33:The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j .
4-34:The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two table edge indexing) in terms of memory utilization and processing time .
4-35:In this analysis, we assume that node and edge structures are implemented with hash tables .
4-36:For hash table manipulations we assume three memory access functions: token insertion, token removal, and token scan .
4-37:Their processing costs are denoted by Ta, Td, and Ts, respectively .
4-38:A token scan operation reads the tokens in a hash bucket sequentially .
4-39:It is extensively used during cell evaluations .
4-40:Ts and Td are a function of the number of tokens in the bucket while Ta is constant .
4-41:For the purpose of analysis, we define two random variables .
4-42:One variable, denoted by mo, represents the side length of the AOI of an entity o .
4-43:The side lengths are uniformly distributed in the range of [mmin, mmax] .
4-44:The average value of mo is denoted by ydirectional maximum distance of a moving entity during a time interval .
4-45:The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v] .
4-46:For a simple calculation, both random variables are expressed as the number of cell units .
4-47:Table 1 summarizes the symbolic notations and their meaning .
4-48:5.1 Memory Requirements Let the token size be denoted by s .
4-49:Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities .
4-50:Single table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities .
4-51:Two table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects .
4-52:Table 2 summarizes these results .
4-53:In our target apTable 2: Memory requirements of different indexing methods .
4-54:indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single table edge s · |Uq| 2s(m + 1)|U| two table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing .
4-55:Different grid cell partitioning with edge methods will lead to different memory requirements .
4-56:For example, here are two grids: a M × M grid and a 2M × 2M grid .
4-57:The memory requirement for the user entities is unchanged because it depends only on the total number of user entities .
4-58:The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid .
4-59:Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens .
4-60:5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations .
4-61:For a fair comparison of the different methods, we only analyze the run time complexity of moving objects and moving users .
4-62:5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance .
4-63:Similar to edge indexing, node indexing has two update policies: full update and incremental update .
4-64:Full update, implemented in Q Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes .
4-65:The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period .
4-66:In this analysis, we only consider incremental node indexing .
4-67:To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5 .
4-68:We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O .
4-69:As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0) .
4-70:If an object resides in the same cell, there will be no update .
4-71:If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v .
4-72:Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v .
4-73:Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · + 4 · (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) .
4-74:407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q .
4-75:indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single table edge indexing with full update |Q| |O| · 2(m + 1) single table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0) .
4-76:The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed .
4-77:Roughly speaking, its worst case processing cost is the same as Tedgefull per update .
4-78:Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3 .
4-79:In this table, it is evident that while the update cost of the worst case edge indexing (single table edge indexing with full update policy) depends only on m, that of the best case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m .
4-80:For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs .
4-81:2(m + 1)) .
4-82:However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2) .
4-83:Another interesting result is that two table edge indexing depends only on the token insertion cost, Ta .
4-84:Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods .
4-85:The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v) .
4-86:The average side length of object AOIs is 10% of the side length of a given 2 D map .
4-87:greater than Ta because Td requires at least one token lookup operation .
4-88:After the lookup, Td executes the reverse operation of Ta .
4-89:Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets .
4-90:From this observation, we can infer that full update of single table edge indexing takes at least twice as long as the update for two table edge indexing .
4-91:Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI .
4-92:In this figure we assume that the average side length of the AOI is 0.1 (or 10 %) .
4-93:The node indexing method, however, depends not only on the side length but also on the reachable distance .
4-94:Thus the entity update in node indexing is much heavier than the full update for edge indexing .
4-95:As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible .
4-96:5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node .
4-97:Therefore, it would take |Q|×Ts to scan all user entities .
4-98:If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts .
4-99:If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts .
4-100:The runtime complexity of the single table cell evaluation can 408 Table 4: Summary of cell evaluation cost .
4-101:indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single table edge Ts · (|Q| + |O| · 2(m + 1)) two table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1) .
4-102:In this analysis, we do not consider any data delivery overhead after a cell evaluation .
4-103:Note that in single table edge indexing we need to scan all the tokens for cell evaluations .
4-104:Two table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation .
4-105:Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation .
4-106:Table 4 shows the expected complexities of different cell evaluation scenarios .
4-107:If previously computed result sets are re used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|) .
4-108:However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method .
4-109:5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations .
4-110:In this section we focus on evaluating the performance difference between single table edge indexing and two table edge indexing .
4-111:The total elapsed time of full update based single table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two table edge indexing, even though it represents a minor optimization of single table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement .
4-112:First of all, Td is very predictable and a more lightweight procedure than Td .
4-113:All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant .
4-114:In addition, twotable indexing is guaranteed to outperform single table full update edge indexing .
4-115:Another novelty of the two table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform .
4-116:Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m .
4-117:While Ta, Ts and Td are system specific parameters, |O|, |Q|, and m are all application specific .
4-118:The latter can be configured by the former and any given real time constraint T .
4-119:Thus, the system throughput how many moving objects and users are supported by the given system is obtained from Equation 9 .
4-120:Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second .
4-121:Every avatar can navigate in the sub world freely and the same number of remotely connected clients receive the latest update events continuously. .
5 EVALUATION :
5-1:This section presents two simulation setups and their performance results .
5-2:Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity .
5-3:Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model .
5-4:6.1 JustificationofObject initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15] .
5-5:P is the ratio of relevant, retrieved items to all retrieved items .
5-6:A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client .
5-7:A higher P value means a higher network traffic load than required .
5-8:R is the ratio of relevant, retrieved items to all relevant items .
5-9:A lower R value means that more objects that should be recognized are ignored .
5-10:From the R measure, we can quantitatively estimate the occurrence of object popping .
5-11:In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15] .
5-12:The E measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R .
5-13:If β is equal to 1, P and R are equally important .
5-14:If β is less than 1, P becomes more important .
5-15:Otherwise, R will affect the E measure significantly .
5-16:A lower E measure value implies that the tested view model has a higher quality .
5-17:The best E measure value is zero, where the best values for P and R are both ones .
5-18:6.1.2 Simulation Setup We tested four query processing schemes, which use either a user initiated or an object initiated view model: • User initiated visibility computation RQ OP: Region Query Object Point • Object oriented visibility computation PQ OR: Point Query Object Region RQ OR: Region Query Object Region ACQ OR: Approximate Cell Query Object Region RQ OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI .
5-19:PQ OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R} .
5-20:RQ OR, an imaginary computation scheme, is the combination of RQ OP and PQ OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅} .
5-21:Lastly, ACQ OR, an approximate visibility computation model, is a special scheme designed for grid based space partitioning, which is our choice of cell evaluation methodology for edge indexing .
5-22:If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes .
5-23:Scheme P R RQ OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell .
5-24:Of course, it exhibits similar properties as RQ OR while the result set of its query is not a subset of the RQ OR query result .
5-25:It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well .
5-26:Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1) .
5-27:The populated entities are uniformly located in the unit space .
5-28:The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space .
5-29:The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E measure values (shown in Table 5) .
5-30:6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ OP .
5-31:We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range .
5-32:A smaller side length leads to higher accuracy but lower comprehensiveness .
5-33:For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5% .
5-34:Thus, every object retrieved by RQ OP is guaranteed to be all rendered at the client .
5-35:But RQ OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered .
5-36:Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects .
5-37:To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation .
5-38:E measure Distribution: Figure 8 reveals two trends .
5-39:First, the precision values of RQ OP lie in between those of ACQ OR (100 × 100 grid) and RQ OR .
5-40:Second, the tendency curve of the Precision to E measure plot of RQ OR shows resemblance to that of ACQ OR .
5-41:It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ OR inherits the properties of RQ OR .
5-42:Effect of Different Grid Size: Figure 9 shows the statistical difference of E measure values of seven different grid partitioning schemes (using ACQ OR) and one RQ OP model .
5-43:We use a boxand whisker plot to show both median values and the variances of E measure distributions and the outliers of each scheme .
5-44:We also draw the median value of the RQ OP E measures (green line) for comparison purposes .
5-45:While the ACQ OR schemes have some outliers, their E measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI .
5-46:As expected, fine grained grid partitioning showed a smaller E measure value .
5-47:The RQ OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths .
5-48:As the R measure becomes more important, the query quality of ACQ OR is improved more evidently than that of RQOP .
5-49:From Figure 9, the 20×20 grid scheme had a better E measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1) .
5-50:indexing Update Time Evaluation Time Total Single tableF ull 3.48 0.82 4.30 Single tableIncr 2.08 0.80 2.88 Two table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15) .
5-51:indexing Update Time Evaluation Time Total Single tableF ull 3.65 0.77 4.42 Single tableIncr 3.49 0.74 4.23 Two table 1.75 0.93 2.68 value in a prioritized environment than in an equal prioritized environment .
5-52:As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ OP .
5-53:6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation .
5-54:To estimate the degree of real time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell .
5-55:We also experimented with different grid partitioning policies and compared them with exhaustive search solutions .
5-56:6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64 bit 900MHz Itanium processor with 8 GBs of memory .
5-57:We implemented a generalized hash table mechanism to store node and edge structures .
5-58:6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v .
5-59:The moving speed of entities was also uniformly assigned between 0 and v .
5-60:In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two table approach surpasses the performance of single table schemes, mainly due to the lack of token lookup during an update .
5-61:However, the two table method showed a slightly higher evaluation time than the two single table methods because of its sequential token removal .
5-62:Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co exist .
5-63:Compared with the results shown in Table 6, the two table approach produced similar performance numbers regardless of the underlying moving environments .
5-64:However, the performance gain obtained by the incremental policy of the single table is decreased compared with that in the slowly moving environment .
5-65:Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput .
5-66:In this section, we evaluate the performance results of three different visibility computation models: two computation driven exhaustive search methods; and one two table edge indexing method with different grid sizes .
5-67:410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ OP .
5-68:Figure 8: E measure value as a function of Precision value P when β = 1 .
5-69:Figure 9: E measure value as a function of ACQ QR grid partitioning scheme when β = 2 .
5-70:10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes .
5-71:Exhaustive search methods do not maintain any intermediate results .
5-72:They simply compute whether a given user point is inside a given object AOI .
5-73:They can tolerate unpredictable behavior of object movement .
5-74:In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination .
5-75:Figure 10 reveals the performance difference between the exhaustive solutions and the two table methods, a difference of up to two orders of magnitude .
5-76:As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI .
5-77:Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally .
5-78:Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. .
6-1:To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object initiated view model, and its efficient indexing method, edge indexing
6-2:Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity
6-3:Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge level not at node level in a grid partitioned sub world and was validated through quantitative analyses and simulations
6-4:However, for now our edge indexing still retains a higher complexity, even in a two dimensional domain
6-5:Currently, we are developing another edge indexing method to make the indexing complexity constant
6-6:Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi resolutional geometry data
6-7:We expect that our edge indexing can contribute to successful deployment of next generation gaming environments.
7-1:D
7-2:Marshall, D
7-3:Delaney, S
7-4:McLoone, and T
7-5:Ward, Challeges in modern distributed interactive application design, Tech
7-6:Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col
7-7:Kildare, Ireland, 2004
7-8:Kuan Ta Chen, Polly Huang, Chun Ying Huang, and Chin Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV"05
7-9:2005, pp
7-10:19 24, ACM Press
7-11:Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames "05, Oct 2005
7-12:Philip Rosedale and Cory Ondrejka, Enabling player created online worlds with grid computing and streaming, Gamastutra Magazine, http:  www.gamasutra.com resource guide 20030916 rosedale 01.shtml, September 2003
7-13:Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput
7-14:Graph
7-15:Forum, vol
7-16:20, no
7-17:3, 2001
7-18:Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real Time Applications, 1998
7-19:Thomas A
7-20:Funkhouser and Carlo H
7-21:Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH "93, New York, NY, USA, 1993, pp
7-22:247 254, ACM Press
7-23:Jussi Myllymaki and James Kaufman, High performance spatial indexing for location based services, in WWW "03, New York, NY, USA, 2003, pp
7-24:112 117, ACM Press
7-25:M
7-26:Lee, W
7-27:Hsu, C
7-28:Jensen, B
7-29:Cui, and K
7-30:Teo, Supporting frequent updates in r trees: A bottom up approach, in VLDB, pages 608 619, 2003, 2003
7-31:Mohamed F
7-32:Mokbel, Xiaopeing Xiong, and Walid G
7-33:Aref, Sina: scalable incremental processing of continuous queries in spatio temporal databases, in ACM SIGMOD "04
7-34:2004, pp
7-35:623 634, ACM Press
7-36:Dmitri V
7-37:Kalashnikov, Sunil Prabhakar, and Susanne E
7-38:Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib
7-39:Parallel Databases, vol
7-40:15, no
7-41:2, pp
7-42:117 135, 2004
7-43:Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005
7-44:S
7-45:Prabhakar, Y
7-46:Xia, D
7-47:Kalashnikov, W
7-48:Aref, and S
7-49:Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol
7-50:51, no
7-51:10, pp
7-52:1124 1140, Oct
7-53:2002
7-54:Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA "03, Washington, DC, USA, 2003, p
7-55:175, IEEE Computer Society
7-56:C
7-57:J
7-58:Van Rijsbergen, Information Retrieval, 2nd edition, Dept
7-59:of Computer Science, University of Glasgow, 1979
7-60:411
picture:
