Fast Generation of Result Snippets in Web Search 
content:
1 ABSTRACT :
1-1:The presentation of query biased document snippets as part of results pages presented by search engines has become an expectation of search engine users .
1-2:In this paper we explore the algorithms and data structures required as part of a search engine to allow efficient generation of query biased snippets .
1-3:We begin by proposing and analysing a document compression method that reduces snippet generation time by 58% over a baseline using the zlib compression library .
1-4:These experiments reveal that finding documents on secondary storage dominates the total cost of generating snippets, and so caching documents in RAM is essential for a fast snippet generation process .
1-5:Using simulation, we examine snippet generation performance for different size RAM caches .
1-6:Finally we propose and analyse document reordering and compaction, revealing a scheme that increases the number of document cache hits with only a marginal affect on snippet quality .
1-7:This scheme effectively doubles the number of documents that can fit in a fixed size cache .
1-8:H.3.3 [Information Storage and Retrieval]: Information .
2 INTRODUCTION :
2-1:Each result in search results list delivered by current WWW search engines such as search.yahoo.com, google.com and search.msn.com typically contains the title and URL of the actual document, links to live and cached versions of the document and sometimes an indication of file size and type .
2-2:In addition, one or more snippets are usually presented, giving the searcher a sneak preview of the document contents .
2-3:Snippets are short fragments of text extracted from the document content (or its metadata) .
2-4:They may be static (for example, always show the first 50 words of the document, or the content of its description metadata, or a description taken from a directory site such as dmoz.org) or query biased [20] .
2-5:A query biased snippet is one selectively extracted on the basis of its relation to the searcher"s query .
2-6:The addition of informative snippets to search results may substantially increase their value to searchers .
2-7:Accurate snippets allow the searcher to make good decisions about which results are worth accessing and which can be ignored .
2-8:In the best case, snippets may obviate the need to open any documents by directly providing the answer to the searcher"s real information need, such as the contact details of a person or an organization .
2-9:Generation of query biased snippets by Web search engines indexing of the order of ten billion web pages and handling hundreds of millions of search queries per day imposes a very significant computational load (remembering that each search typically generates ten snippets) .
2-10:The simpleminded approach of keeping a copy of each document in a file and generating snippets by opening and scanning files, works when query rates are low and collections are small, but does not scale to the degree required .
2-11:The overhead of opening and reading ten files per query on top of accessing the index structure to locate them, would be manifestly excessive under heavy query load .
2-12:Even storing ten billion files and the corresponding hundreds of terabytes of data is beyond the reach of traditional filesystems .
2-13:Special purpose filesystems have been built to address these problems [6] .
2-14:Note that the utility of snippets is by no means restricted to whole of Web search applications .
2-15:Efficient generation of snippets is also important at the scale of whole of government search services such as www.firstgov.gov (c .
2-16:25 million pages) and govsearch.australia.gov.au (c .
2-17:5 million pages) and within large enterprises such as IBM [2] (c .
2-18:50 million pages) .
2-19:Snippets may be even more useful in database or filesystem search applications in which no useful URL or title information is present .
2-20:We present a new algorithm and compact single file structure designed for rapid generation of high quality snippets and compare its space time performance against an obvious baseline based on the zlib compressor on various data sets .
2-21:We report the proportion of time spent for disk seeks, disk reads and cpu processing; demonstrating that the time for locating each document (seek time) dominates, as expected .
2-22:As the time to process a document in RAM is small in comparison to locating and reading the document into memory, it may seem that compression is not required .
2-23:However, this is only true if there is no caching of documents in RAM .
2-24:Controlling the RAM of physical systems for experimentation is difficult, hence we use simulation to show that caching documents dramatically improves the performance of snippet generation .
2-25:In turn, the more documents can be compressed, the more can fit in cache, and hence the more disk seeks can be avoided: the classic data compression tradeoff that is exploited in inverted file structures and computing ranked document lists [24] .
2-26:As hitting the document cache is important, we examine document compaction, as opposed to compression, schemes by imposing an a priori ordering of sentences within a document, and then only allowing leading sentences into cache for each document .
2-27:This leads to further time savings, with only marginal impact on the quality of the snippets returned. .
3 RELATED WORK :
3-1:Snippet generation is a special type of extractive document summarization, in which sentences, or sentence fragments, are selected for inclusion in the summary on the basis of the degree to which they match the search query .
3-2:This process was given the name of query biased summarization by Tombros and Sanderson [20] The reader is referred to Mani [13] and to Radev et al .
3-3:[16] for overviews of the very many different applications of summarization and for the equally diverse methods for producing summaries .
3-4:Early Web search engines presented query independent snippets consisting of the first k bytes of the result document .
3-5:Generating these is clearly much simpler and much less computationally expensive than processing documents to extract query biased summaries, as there is no need to search the document for text fragments containing query terms .
3-6:To our knowledge, Google was the first whole ofWeb search engine to provide query biased summaries, but summarization is listed by Brin and Page [1] only under the heading of future work .
3-7:Most of the experimental work using query biased summarization has focused on comparing their value to searchers relative to other types of summary [20, 21], rather than efficient generation of summaries .
3-8:Despite the importance of efficient summary generation in Web search, few algorithms appear in the literature .
3-9:Silber and McKoy [19] describe a linear time lexical chaining algorithm for use in generic summaries, but offer no empirical data for the performance of their algorithm .
3-10:White et al [21] report some experimental timings of their WebDocSum system, but the snippet generation algorithms themselves are not isolated, so it is difficult to infer snippet generation time comparable to the times we report in this paper. .
4 SEARCH ENGINE ARCHITECTURES :
4-1:A search engine must perform a variety of activities, and is comprised of many sub systems, as depicted by the boxes in Figure 1 .
4-2:Note that there may be several other sub systems such as the Advertising Engine or the Parsing Engine that could easily be added to the diagram, but we have concentrated on the sub systems that are relevant to snippet generation .
4-3:Depending on the number of documents that the search engine indexes, the data and processes for each Ranking Engine Crawling Engine Indexing Engine Engine Lexicon Meta Data Engine Engine Snippet Term&Doc#s Snippetperdoc WEB Query Engine Query Results Page Term#s Doc#s Invertedlists Docs perdoc Title,URL,etc Doc#s Document meta data Terms Querystring Term#s Figure 1: An abstraction of some of the sub systems in a search engine .
4-4:Depending on the number of documents indexed, each sub system could reside on a single machine, be distributed across thousands of machines, or a combination of both .
4-5:sub system could be distributed over many machines, or all occupy a single server and filesystem, competing with each other for resources .
4-6:Similarly, it may be more efficient to combine some sub systems in an implementation of the diagram .
4-7:For example, the meta data such as document title and URL requires minimal computation apart from highlighting query words, but we note that disk seeking is likely to be minimized if title, URL and fixed summary information is stored contiguously with the text from which query biased summaries are extracted .
4-8:Here we ignore the fixed text and consider only the generation of query biased summaries: we concentrate on the Snippet Engine .
4-9:In addition to data and programs operating on that data, each sub system also has its own memory management scheme .
4-10:The memory management system may simply be the memory hierarchy provided by the operating system used on machines in the sub system, or it may be explicitly coded to optimise the processes in the sub system .
4-11:There are many papers on caching in search engines (see [3] and references therein for a current summary), but it seems reasonable that there is a query cache in the Query Engine that stores precomputed final result pages for very popular queries .
4-12:When one of the popular queries is issued, the result page is fetched straight from the query cache .
4-13:If the issued query is not in the query cache, then the Query Engine uses the four sub systems in turn to assemble a results page .
4-14:term, using them to get a ranked list of documents .
4-15:query term numbers to generate snippets .
4-16:each document to construct the results page .
4-17:IN A document broken into one sentence per line, and a sequence of query terms .
4-18:1 For each line of the text, L = [w1, w2, .
4-19:.
4-20:.
4-21:, wm] 2 Let h be 1 if L is a heading, 0 otherwise .
4-22:3 Let be 2 if L is the first line of a document, 1 if it is the second line, 0 otherwise .
4-23:4 Let c be the number of wi that are query terms, counting repetitions .
4-24:5 Let d be the number of distinct query terms that match some wi .
4-25:6 Identify the longest contiguous run of query terms in L, say wj .
4-26:.
4-27:.
4-28:wj+k .
4-29:7 Use a weighted combination of c, d, k, h and to derive a score s .
4-30:8 Insert L into a max heap using s as the key .
4-31:OUT Remove the number of sentences required from the heap to form the summary .
4-32:Figure 2: Simple sentence ranker that operates on raw text with one sentence per line. .
5 THE SNIPPET ENGINE :
5-1:For each document identifier passed to the Snippet Engine, the engine must generate text, preferably containing query terms, that attempts to summarize that document .
5-2:Previous work on summarization identifies the sentence as the minimal unit for extraction and presentation to the user [12] .
5-3:Accordingly, we also assume a web snippet extraction process will extract sentences from documents .
5-4:In order to construct a snippet, all sentences in a document should be ranked against the query, and the top two or three returned as the snippet .
5-5:The scoring of sentences against queries has been explored in several papers [7, 12, 18, 20, 21], with different features of sentences deemed important .
5-6:Based on these observations, Figure 2, shows the general algorithm for scoring sentences in relevant documents, with the highest scoring sentences making the snippet for each document .
5-7:The final score of a sentence, assigned in Step 7, can be derived in many different ways .
5-8:In order to avoid bias towards any particular scoring mechanism, we compare sentence quality later in the paper using the individual components of the score, rather than an arbitrary combination of the components .
5-9:4.1 Parsing Web Documents Unlike well edited text collections that are often the target for summarization systems, Web data is often poorly structured, poorly punctuated, and contains a lot of data that do not form part of valid sentences that would be candidates for parts of snippets .
5-10:We assume that the documents passed to the Snippet Engine by the Indexing Engine have all HTML tags and JavaScript removed, and that each document is reduced to a series of word tokens separated by non word tokens .
5-11:We define a word token as a sequence of alphanumeric characters, while a non word is a sequence of non alphanumeric characters such as whitespace and the other punctuation symbols .
5-12:Both are limited to a maximum of 50 characters .
5-13:Adjacent, repeating characters are removed from the punctuation .
5-14:Included in the punctuation set is a special end of sentence marker which replaces the usual three sentence terminators ?!. .
5-15:Often these explicit punctuation characters are missing, and so HTML tags such as <br> and <p> are assumed to terminate sentences .
5-16:In addition, a sentence must contain at least five words and no more than twenty words, with longer or shorter sentences being broken and joined as required to meet these criteria [10] .
5-17:Unterminated HTML tags that is, tags with an open brace, but no close brace cause all text from the open brace to the next open brace to be discarded .
5-18:A major problem in summarizing web pages is the presence of large amounts of promotional and navigational material (navbars) visually above and to the left of the actual page content .
5-19:For example, The most wonderful company on earth .
5-20:Products .
5-21:Service .
5-22:About us .
5-23:Contact us .
5-24:Try before you buy .
5-25:Similar, but often not identical, navigational material is typically presented on every page within a site .
5-26:This material tends to lower the quality of summaries and slow down summary generation .
5-27:In our experiments we did not use any particular heuristics for removing navigational information as the test collection in use (wt100g) pre dates the widespread take up of the current style of web publishing .
5-28:In wt100g, the average web page size is more than half the current Web average [11] .
5-29:Anecdotally, the increase is due to inclusion of sophisticated navigational and interface elements and the JavaScript functions to support them .
5-30:Having defined the format of documents that are presented to the Snippet Engine, we now define our Compressed Token System document storage scheme, and the baseline system used for comparison .
5-31:4.2 Baseline Snippet Engine An obvious document representation scheme is to simply compress each document with a well known adaptive compressor, and then decompress the document as required [1], using a string matching algorithm to effect the algorithm in Figure 2 .
5-32:Accordingly, we implemented such a system, using zlib [4] with default parameters to compress every document after it has been parsed as in Section 4.1 .
5-33:Each document is stored in a single file .
5-34:While manageable for our small test collections or small enterprises with millions of documents, a full Web search engine may require multiple documents to inhabit single files, or a special purpose filesystem [6] .
5-35:For snippet generation, the required documents are decompressed one at a time, and a linear search for provided query terms is employed .
5-36:The search is optimized for our specific task, which is restricted to matching whole words and the sentence terminating token, rather than general pattern matching .
5-37:4.3 The CTS Snippet Engine Several optimizations over the baseline are possible .
5-38:The first is to employ a semi static compression method over the entire document collection, which will allow faster decompression with minimal compression loss [24] .
5-39:Using a semistatic approach involves mapping words and non words produced by the parser to single integer tokens, with frequent symbols receiving small integers, and then choosing a coding scheme that assigns small numbers a small number of bits .
5-40:Words and non words strictly alternate in the compressed file, which always begins with a word .
5-41:In this instance we simply assign each symbol its ordinal number in a list of symbols sorted by frequency .
5-42:We use the vbyte coding scheme to code the word tokens [22] .
5-43:The set of non words is limited to the 64 most common punctuation sequences in the collection itself, and are encoded with a flat 6 bit binary code .
5-44:The remaining 2 bits of each punctuation symbol are used to store capitalization information .
5-45:The process of computing the semi static model is complicated by the fact that the number of words and non words appearing in large web collections is high .
5-46:If we stored all words and non words appearing in the collection, and their associated frequency, many gigabytes of RAM or a B tree or similar on disk structure would be required [23] .
5-47:Moffat et al .
5-48:[14] have examined schemes for pruning models during compression using large alphabets, and conclude that rarely occurring terms need not reside in the model .
5-49:Rather, rare terms are spelt out in the final compressed file, using a special word token (escape symbol), to signal their occurrence .
5-50:During the first pass of encoding, two move to front queues are kept; one for words and one for non words .
5-51:Whenever the available memory is consumed and a new symbol is discovered in the collection, an existing symbol is discarded from the end of the queue .
5-52:In our implementation, we enforce the stricter condition on eviction that, where possible, the evicted symbol should have a frequency of one .
5-53:If there is no symbol with frequency one in the last half of the queue, then we evict symbols of frequency two, and so on until enough space is available in the model for the new symbol .
5-54:The second pass of encoding replaces each word with its vbyte encoded number, or the escape symbol and an ASCII representation of the word if it is not in the model .
5-55:Similarly each non word sequence is replaced with its codeword, or the codeword for a single space character if it is not in the model .
5-56:We note that this lossless compression of non words is acceptable when the documents are used for snippet generation, but may not be acceptable for a document database .
5-57:We assume that a separate sub system would hold cached documents for other purposes where exact punctuation is important .
5-58:While this semi static scheme should allow faster decompression than the baseline, it also readily allows direct matching of query terms as compressed integers in the compressed file .
5-59:That is, sentences can be scored without having to decompress a document, and only the sentences returned as part of a snippet need to be decoded .
5-60:The CTS system stores all documents contiguously in one file, and an auxiliary table of 64 bit integers indicating the start offset of each document in the file .
5-61:Further, it must have access to the reverse mapping of term numbers, allowing those words not spelt out in the document to be recovered and returned to the Query Engine as strings .
5-62:The first of these data structures can be readily partitioned and distributed if the Snippet Engine occupies multiple machines; the second, however, is not so easily partitioned, as any document on a remote machine might require access to the whole integer to string mapping .
5-63:This is the second reason for employing the model pruning step during construction of the semi static code: it limits the size of the reverse mapping table that should be present on every machine implementing the Snippet Engine .
5-64:4.4 Experimental assessment of CTS All experiments reported in this paper were run on a Sun Fire V210 Server running Solaris 10 .
5-65:The machine consists of dual 1.34 GHz UltraSPARC IIIi processors and 4GB of wt10g wt50g wt100g No .
5-66:Docs .
5-67:(×106 ) 1.7 10.1 18.5 Raw Text 10, 522 56, 684 102, 833 Baseline(zlib) 2, 568 (24%) 10, 940 (19%) 19, 252 (19%) CTS 2, 722 (26%) 12, 010 (21%) 22, 269 (22%) Table 1: Total storage space (Mb) for documents for the three test collections both compressed, and uncompressed .
5-68:0 20 40 60 0.00.20.40.60.8 Queries grouped in 100"s Time(seconds) 0 20 40 60 0.00.20.40.60.8 Queries grouped in 100"s Time(seconds) 0 20 40 60 0.00.20.40.60.8 Queries grouped in 100"s Time(seconds) Baseline CTS with caching CTS without caching Figure 3: Time to generate snippets for 10 documents per query, averaged over buckets of 100 queries, for the first 7000 Excite queries on wt10g .
5-69:RAM .
5-70:All source code was compiled using gcc4.1.1 with O9 optimisation .
5-71:Timings were run on an otherwise unoccupied machine and were averaged over 10 runs, with memory flushed between runs to eliminate any caching of data files .
5-72:In the absence of evidence to the contrary, we assume that it is important to model realistic query arrival sequences and the distribution of query repetitions for our experiments .
5-73:Consequently, test collections which lack real query logs, such as TREC ad hoc and .GOV2 were not considered suitable .
5-74:Obtaining extensive query logs and associated result doc ids for a corresponding large collection is not easy .
5-75:We have used two collections (wt10g and wt100g) from the TREC Web Track [8] coupled with queries from Excite logs from the same (c .
5-76:1997) period .
5-77:Further, we also made use of a medium sized collection wt50g, obtained by randomly sampling half of the documents from wt100g .
5-78:The first two rows of Table 1 give the number of documents and the size in Mb of these collections .
5-79:The final two rows of Table 1 show the size of the resulting document sets after compression with the baseline and CTS schemes .
5-80:As expected, CTS admits a small compression loss over zlib, but both substantially reduce the size of the text to about 20% of the original, uncompressed size .
5-81:Note that the figures for CTS do not include the reverse mapping from integer token to string that is required to produce the final snippets as that occupies RAM .
5-82:It is 1024 Mb in these experiments .
5-83:The Zettair search engine [25] was used to produce a list of documents to summarize for each query .
5-84:For the majority of the experiments the Okapi BM25 scoring scheme was used to determine document rankings .
5-85:For the static caching experiments reported in Section 5, the score of each document wt10g wt50g wt100g Baseline 75 157 183 CTS 38 70 77 Reduction in time 49% 56% 58% Table 2: Average time (msec) for the final 7000 queries in the Excite logs using the baseline and CTS systems on the 3 test collections .
5-86:is a 50:50 weighted average of the BM25 score (normalized by the top scoring document for each query) and a score for each document independent of any query .
5-87:This is to simulate effects of ranking algorithms like PageRank [1] on the distribution of document requests to the Snippet Engine .
5-88:In our case we used the normalized Access Count [5] computed from the top 20 documents returned to the first 1 million queries from the Excite log to determine the query independent score component .
5-89:Points on Figure 3 indicate the mean running time to generate 10 snippets for each query, averaged in groups of 100 queries, for the first 7000 queries in the Excite query log .
5-90:Only the data for wt10g is shown, but the other collections showed similar patterns .
5-91:The x axis indicates the group of 100 queries; for example, 20 indicates the queries 2001 to 2100 .
5-92:Clearly there is a caching effect, with times dropping substantially after the first 1000 or so queries are processed .
5-93:All of this is due to the operating system caching disk blocks and perhaps pre fetching data ahead of specific read requests .
5-94:This is evident because the baseline system has no large internal data structures to take advantage of non disk based caching, it simply opens and processes files, and the speed up is evident for the baseline system .
5-95:Part of this gain is due to the spatial locality of disk references generated by the query stream: repeated queries will already have their document files cached in memory; and similarly different queries that return the same documents will benefit from document caching .
5-96:But when the log is processed after removing all but the first request for each document, the pronounced speed up is still evident as more queries are processed (not shown in figure) .
5-97:This suggests that the operating system (or the disk itself) is reading and buffering a larger amount of data than the amount requested and that this brings benefit often enough to make an appreciable difference in snippet generation times .
5-98:This is confirmed by the curve labeled CTS without caching, which was generated after mounting the filesystem with a no caching option (directio in Solaris) .
5-99:With disk caching turned off, the average time to generate snippets varies little .
5-100:The time to generate ten snippets for a query, averaged over the final 7000 queries in the Excite log as caching effects have dissipated, are shown in Table 2 .
5-101:Once the system has stabilized, CTS is over 50% faster than the Baseline system .
5-102:This is primarily due to CTS matching single integers for most query words, rather than comparing strings in the baseline system .
5-103:Table 3 shows a break down of the average time to generate ten snippets over the final 7000 queries of the Excite log on the wt50g collection when entire documents are processed, and when only the first half of each document is processed .
5-104:As can be seen, the majority of time spent generating a snippet is in locating the document on disk (Seek): 64% for whole documents, and 75% for half documents .
5-105:Even if the amount of processing a document must % of doc processed Seek Read Score & Decode 100% 45 4 21 50% 45 4 11 Table 3: Time to generate 10 snippets for a single query (msec) for the wt50g collection averaged over the final 7000 Excite queries when either all of each document is processed (100%) or just the first half of each document (50%) .
5-106:undergo is halved, as in the second row of the Table, there is only a 14% reduction in the total time required to generate a snippet .
5-107:As locating documents in secondary storage occupies such a large proportion of snippet generation time, it seems logical to try and reduce its impact through caching. .
6 DOCUMENT CACHING :
6-1:In Section 3 we observed that the Snippet Engine would have its own RAM in proportion to the size of the document collection .
6-2:For example, on a whole of Web search engine, the Snippet Engine would be distributed over many workstations, each with at least 4 Gb of RAM .
6-3:In a small enterprise, the Snippet Engine may be sharing RAM with all other sub systems on a single workstation, hence only have 100 Mb available .
6-4:In this section we use simulation to measure the number of cache hits in the Snippet Engine as memory size varies .
6-5:We compare two caching policies: a static cache, where the cache is loaded with as many documents as it can hold before the system begins answering queries, and then never changes; and a least recently used cache, which starts out as for the static cache, but whenever a document is accessed it moves to the front of a queue, and if a document is fetched from disk, the last item in the queue is evicted .
6-6:Note that documents are first loaded into the caches in order of decreasing query independent score, which is computed as described in Section 4.4 .
6-7:The simulations also assume a query cache exists for the top Q most frequent queries, and that these queries are never processed by the Snippet Engine .
6-8:All queries passed into the simulations are from the second half of the Excite query log (the first half being used to compute query independent scores), and are stemmed, stopped, and have their terms sorted alphabetically .
6-9:This final alteration simply allows queries such as red dog and dog red to return the same documents, as would be the case in a search engine where explicit phrase operators would be required in the query to enforce term order and proximity .
6-10:Figure 4 shows the percentage of document access that hit cache using the two caching schemes, with Q either 0 or 10,000, on 535,276 Excite queries on wt100g .
6-11:The xaxis shows the percentage of documents that are held in the cache, so 1.0% corresponds to about 185,000 documents .
6-12:From this figure it is clear that caching even a small percentage of the documents has a large impact on reducing seek time for snippet generation .
6-13:With 1% of documents cached, about 222 Mb for the wt100g collection, around 80% of disk seeks are avoided .
6-14:The static cache performs surprisingly well (squares in Figure 4), but is outperformed by the LRU cache (circles) .
6-15:In an actual implementation of LRU, however, there may be fragmentation of the cache as documents are swapped in and out .
6-16:The reason for the large impact of the document cache is 0.0 0.5 1.0 1.5 2.0 2.5 3.0 020406080100 Cache size (% of collection) %ofaccessesascachehits LRU Q=0 LRU Q=10,000 Static Q=0 Static Q=10,000 Figure 4: Percentage of the time that the Snippet Engine does not have to go to disk in order to generate a snippet plotted against the size of the document cache as a percentage of all documents in the collection .
6-17:Results are from a simulation on wt100g with 535,276 Excite queries .
6-18:that, for a particular collection, some documents are much more likely to appear in results lists than others .
6-19:This effect occurs partly because of the approximately Zipfian query frequency distribution, and partly because most Web search engines employ ranking methods which combine query based scores with static (a priori) scores determined from factors such as link graph measures, URL features, spam scores and so on [17] .
6-20:Documents with high static scores are much more likely to be retrieved than others .
6-21:In addition to the document cache, the RAM of the Snippet Engine must also hold the CTS decoding table that maps integers to strings, which is capped by a parameter at compression time (1 Gb in our experiments here) .
6-22:This is more than compensated for by the reduced size of each document, allowing more documents into the document cache .
6-23:For example, using CTS reduces the average document size from 5.7 Kb to 1.2 Kb (as shown in Table 1), so a 2 Gb RAM could hold 368,442 uncompressed documents (2% of the collection), or 850,691 documents plus a 1 Gb decompression table (5% of the collection) .
6-24:In fact, further experimentation with the model size reveals that the model can in fact be very small and still CTS gives good compression and fast scoring times .
6-25:This is evidenced in Figure 5, where the compressed size of wt50g is shown in the solid symbols .
6-26:Note that when no compression is used (Model Size is 0Mb), the collection is only 31 Gb as HTML markup, JavaScript, and repeated punctuation has been discarded as described in Section 4.1 .
6-27:With a 5 Mb model, the collection size drops by more than half to 14 Gb, and increasing the model size to 750 Mb only elicits a 2 Gb drop in the collection size .
6-28:Figure 5 also shows the average time to score and decode a a snippet (excluding seek time) with the different model sizes (open symbols) .
6-29:Again, there is a large speed up when a 5 Mb model is used, but little 0 200 400 600 15202530 Model Size (Mb) CollectionSize(Gb)orTime(msec) Size (Gb) Time (msec) Figure 5: Collection size of the wt50g collection when compressed with CTS using different memory limits on the model, and the average time to generate single snippet excluding seek time on 20000 Excite queries using those models .
6-30:improvement with larger models .
6-31:Similar results hold for the wt100g collection, where a model of about 10 Mb offers substantial space and time savings over no model at all, but returns diminish as the model size increases .
6-32:Apart from compression, there is another approach to reducing the size of each document in the cache: do not store the full document in cache .
6-33:Rather store sentences that are likely to be used in snippets in the cache, and if during snippet generation on a cached document the sentence scores do not reach a certain threshold, then retrieve the whole document from disk .
6-34:This raises questions on how to choose sentences from documents to put in cache, and which to leave on disk, which we address in the next section. .
7 SENTENCE REORDERING :
7-1:Sentences within each document can be re ordered so that sentences that are very likely to appear in snippets are at the front of the document, hence processed first at query time, while less likely sentences are relegated to the rear of the document .
7-2:Then, during query time, if k sentences with a score exceeding some threshold are found before the entire document is processed, the remainder of the document is ignored .
7-3:Further, to improve caching, only the head of each document can be stored in the cache, with the tail residing on disk .
7-4:Note that we assume that the search engine is to provide cached copies of a document that is, the exact text of the document as it was indexed then this would be serviced by another sub system in Figure 1, and not from the altered copy we store in the Snippet Engine .
7-5:We now introduce four sentence reordering approaches .
7-6:document usually best describe the document content [12] .
7-7:Thus simply processing a document in order should yield a quality snippet .
7-8:Unfortunately, however, web documents are often not well authored, with little editorial or professional writing skills brought to bear on the creation of a work of literary merit .
7-9:More importantly, perhaps, is that we are producing query biased snippets, and there is no guarantee that query terms will appear in sentences towards the front of a document .
7-10:of a significant sentence as containing a cluster of significant terms [12], a concept found to work well by Tombros and Sanderson [20] .
7-11:Let fd,t be the frequency of term t in document d, then term t is determined to be significant if fd,t ≥ 8 < : 7 − 0.1 × (25 − sd), if sd < 25 7, if 25 ≤ sd ≤ 40 7 + 0.1 × (sd − 40), otherwise, where sd is the number of sentences in document d .
7-12:A bracketed section is defined as a group of terms where the leftmost and rightmost terms are significant terms, and no significant terms in the bracketed section are divided by more than four non significant terms .
7-13:The score of a bracketed section is the square of the number of significant words falling in the section, divided by the total number of words in the entire sentence .
7-14:The a priori score for a sentence is computed as the maximum of all scores for the bracketed sections of the sentence .
7-15:We then sort the sentences by this score .
7-16:and a small number of queries make up a large volume of total searches [9] .
7-17:In order to take advantage of this bias, sentences that contain many past query terms should be promoted to the front of a document, while sentences that contain few query terms should be demoted .
7-18:In this scheme, the sentences are sorted by the number of sentence terms that occur in the query log .
7-19:To ensure that long sentences do not dominate over shorter qualitative sentences the score assigned to each sentence is divided by the number of terms in that sentence giving each sentence a score between 0 and 1 .
7-20:but repeated terms in the sentence are only counted once .
7-21:By re ordering sentences using schemes ST, QLt or QLu, we aim to terminate snippet generation earlier than if Natural Order is used, but still produce sentences with the same number of unique query terms (d in Figure 2), total number of query terms (c), the same positional score (h+ ) and the same maximum span (k) .
7-22:Accordingly, we conducted experiments comparing the methods, the first 80% of the Excite query log was used to reorder sentences when required, and the final 20% for testing .
7-23:Figure 6 shows the differences in snippet scoring components using each of the three methods over the Natural Order method .
7-24:It is clear that sorting sentences using the Significant Terms method leads to the smallest change in the sentence scoring components .
7-25:The greatest change over all methods is in the sentence position (h + ) component of the score, which is to be expected as their is no guarantee that leading and heading sentences are processed at all after sentences are re ordered .
7-26:The second most affected component is the number of distinct query terms in a returned sentence, but if only the first 50% of the document is processed with the ST method, there is a drop of only 8% in the number of distinct query terms found in snippets .
7-27:Depending how these various components are weighted to compute an overall snippet score, one can argue that there is little overall affect on scores when processing only half the document using the ST method .
7-28:Span (k) Term Count (c) Sentence Position (h + l) Distinct Terms (d) 40% 50% 60% 70% ST QLt QLu ST QLt QLu ST QLt QLu ST QLt QLu ST QLt QLu RelativedifferencetoNaturalOrder Documents size used 90% 80% 70% 60% 50% 0% 10% 20% 30% Figure 6: Relative difference in the snippet score components compared to Natural Ordered documents when the amount of documents processed is reduced, and the sentences in the document are reordered using Query Logs (QLt, QLu) or Significant Terms (ST). .
8-1:In this paper we have described the algorithms and compression scheme that would make a good Snippet Engine sub system for generating text snippets of the type shown on the results pages of well known Web search engines
8-2:Our experiments not only show that our scheme is over 50% faster than the obvious baseline, but also reveal some very important aspects of the snippet generation problem
8-3:Primarily, caching documents avoids seek costs to secondary memory for each document that is to be summarized, and is vital for fast snippet generation
8-4:Our caching simulations show that if as little as 1% of the documents can be cached in RAM as part of the Snippet Engine, possibly distributed over many machines, then around 75% of seeks can be avoided
8-5:Our second major result is that keeping only half of each document in RAM, effectively doubling the cache size, has little affect on the quality of the final snippets generated from those half documents, provided that the sentences that are kept in memory are chosen using the Significant Term algorithm of Luhn [12]
8-6:Both our document compression and compaction schemes dramatically reduce the time taken to generate snippets
8-7:Note that these results are generated using a 100Gb subset of the Web, and the Excite query log gathered from the same period as that subset was created
8-8:We are assuming, as there is no evidence to the contrary, that this collection and log is representative of search engine input in other domains
8-9:In particular, we can scale our results to examine what resources would be required, using our scheme, to provide a Snippet Engine for the entire World Wide Web
8-10:We will assume that the Snippet Engine is distributed across M machines, and that there are N web pages in the collection to be indexed and served by the search engine
8-11:We also assume a balanced load for each machine, so each machine serves about N M documents, which is easily achieved in practice
8-12:Each machine, therefore, requires RAM to hold the following
8-13:• The CTS model, which should be 1 1000 of the size of the uncompressed collection (using results in Figure 5 and Williams et al
8-14:[23])
8-15:Assuming an average uncompressed document size of 8 Kb [11], this would require N M × 8.192 bytes of memory
8-16:• A cache of 1% of all N M documents
8-17:Each document requires 2 Kb when compressed with CTS (Table 1), and only half of each document is required using ST sentence reordering, requiring a total of N M ×0.01× 1024 bytes
8-18:• The offset array that gives the start position of each document in the single, compressed file: 8 bytes per N M documents
8-19:The total amount of RAM required by a single machine, therefore, would be N M(8.192 + 10.24 + 8) bytes
8-20:Assuming that each machine has 8 Gb of RAM, and that there are 20 billion pages to index on the Web, a total of M = 62 machines would be required for the Snippet Engine
8-21:Of course in practice, more machines may be required to manage the distributed system, to provide backup services for failed machines, and other networking services
8-22:These machines would also need access to 37 Tb of disk to store the compressed document representations that were not in cache
8-23:In this work we have deliberately avoided committing to one particular scoring method for sentences in documents
8-24:Rather, we have reported accuracy results in terms of the four components that have been previously shown to be important in determining useful snippets [20]
8-25:The CTS method can incorporate any new metrics that may arise in the future that are calculated on whole words
8-26:The document compaction techniques using sentence re ordering, however, remove the spatial relationship between sentences, and so if a scoring technique relies on the position of a sentence within a document, the aggressive compaction techniques reported here cannot be used
8-27:A variation on the semi static compression approach we have adopted in this work has been used successfully in previous search engine design [24], but there are alternate compression schemes that allow direct matching in compressed text (see Navarro and M¨akinen [15] for a recent survey.) As seek time dominates the snippet generation process, we have not focused on this portion of the snippet generation in detail in this paper
8-28:We will explore alternate compression schemes in future work
8-29:Acknowledgments This work was supported in part by ARC Discovery Project DP0558916 (AT)
8-30:Thanks to Nick Lester and Justin Zobel for valuable discussions.
9-1:S
9-2:Brin and L
9-3:Page
9-4:The anatomy of a large scale hypertextual Web search engine
9-5:In WWW7, pages 107 117, 1998
9-6:R
9-7:Fagin, Ravi K., K
9-8:S
9-9:McCurley, J
9-10:Novak, D
9-11:Sivakumar, J
9-12:A
9-13:Tomlin, and D
9-14:P
9-15:Williamson
9-16:Searching the workplace web
9-17:In WWW2003, Budapest, Hungary, May 2003
9-18:T
9-19:Fagni, R
9-20:Perego, F
9-21:Silvestri, and S
9-22:Orlando
9-23:Boosting the performance of web search engines: Caching and prefetching query results by exploiting historical usage data
9-24:ACM Trans
9-25:Inf
9-26:Syst., 24(1):51 78, 2006
9-27:J L Gailly and M
9-28:Adler
9-29:Zlib Compression Library
9-30:www.zlib.net
9-31:Accessed January 2007
9-32:S
9-33:Garcia, H.E
9-34:Williams, and A
9-35:Cannane
9-36:Access ordered indexes
9-37:In V
9-38:Estivill Castro, editor, Proc
9-39:Australasian Computer Science Conference, pages 7 14, Dunedin, New Zealand, 2004
9-40:S
9-41:Ghemawat, H
9-42:Gobioff, and S
9-43:Leung
9-44:The google file system
9-45:In SOSP "03: Proc
9-46:of the 19th ACM Symposium on Operating Systems Principles, pages 29 43, New York, NY, USA, 2003
9-47:ACM Press
9-48:J
9-49:Goldstein, M
9-50:Kantrowitz, V
9-51:Mittal, and J
9-52:Carbonell
9-53:Summarizing text documents: sentence selection and evaluation metrics
9-54:In SIGIR99, pages 121 128, 1999
9-55:D
9-56:Hawking, Nick C., and Paul Thistlewaite
9-57:Overview of TREC 7 Very Large Collection Track
9-58:In Proc
9-59:of TREC 7, pages 91 104, November 1998
9-60:B
9-61:J
9-62:Jansen, A
9-63:Spink, and J
9-64:Pedersen
9-65:A temporal comparison of altavista web searching
9-66:J
9-67:Am
9-68:Soc
9-69:Inf
9-70:Sci
9-71:Tech
9-72:(JASIST), 56(6):559 570, April 2005
9-73:J
9-74:Kupiec, J
9-75:Pedersen, and F
9-76:Chen
9-77:A trainable document summarizer
9-78:In SIGIR95, pages 68 73, 1995
9-79:S
9-80:Lawrence and C.L
9-81:Giles
9-82:Accessibility of information on the web
9-83:Nature, 400:107 109, July 1999
9-84:H.P
9-85:Luhn
9-86:The automatic creation of literature abstracts
9-87:IBM Journal, pages 159 165, April 1958
9-88:I
9-89:Mani
9-90:Automatic Summarization, volume 3 of Natural Language Processing
9-91:John Benjamins Publishing Company, Amsterdam Philadelphia, 2001
9-92:A
9-93:Moffat, J
9-94:Zobel, and N
9-95:Sharman
9-96:Text compression for dynamic document databases
9-97:Knowledge and Data Engineering, 9(2):302 313, 1997
9-98:G
9-99:Navarro and V
9-100:M¨akinen
9-101:Compressed full text indexes
9-102:ACM Computing Surveys, 2007
9-103:To appear
9-104:D
9-105:R
9-106:Radev, E
9-107:Hovy, and K
9-108:McKeown
9-109:Introduction to the special issue on summarization
9-110:Comput
9-111:Linguist., 28(4):399 408, 2002
9-112:M
9-113:Richardson, A
9-114:Prakash, and E
9-115:Brill
9-116:Beyond pagerank: machine learning for static ranking
9-117:In WWW06, pages 707 715, 2006
9-118:T
9-119:Sakai and K
9-120:Sparck Jones
9-121:Generic summaries for indexing in information retrieval
9-122:In SIGIR01, pages 190 198, 2001
9-123:H
9-124:G
9-125:Silber and K
9-126:F
9-127:McCoy
9-128:Efficiently computed lexical chains as an intermediate representation for automatic text summarization
9-129:Comput
9-130:Linguist., 28(4):487 496, 2002
9-131:A
9-132:Tombros and M
9-133:Sanderson
9-134:Advantages of query biased summaries in information retrieval
9-135:In SIGIR98, pages 2 10, Melbourne, Aust., August 1998
9-136:R
9-137:W
9-138:White, I
9-139:Ruthven, and J
9-140:M
9-141:Jose
9-142:Finding relevant documents using top ranking sentences: an evaluation of two alternative schemes
9-143:In SIGIR02, pages 57 64, 2002
9-144:H
9-145:E
9-146:Williams and J
9-147:Zobel
9-148:Compressing integers for fast file access
9-149:Comp
9-150:J., 42(3):193 201, 1999
9-151:H.E
9-152:Williams and J
9-153:Zobel
9-154:Searchable words on the Web
9-155:International Journal on Digital Libraries, 5(2):99 105, April 2005
9-156:I
9-157:H
9-158:Witten, A
9-159:Moffat, and T
9-160:C
9-161:Bell
9-162:Managing Gigabytes: Compressing and Indexing Documents and Images
9-163:Morgan Kaufmann Publishing, San Francisco, second edition, May 1999
9-164:The Zettair Search Engine
9-165:www.seg.rmit.edu.au zettair
9-166:Accessed January 2007
picture:
