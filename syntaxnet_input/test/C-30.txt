Bullet: High Bandwidth Data Dissemination 
content:
1 ABSTRACT :
1-1:In recent years, overlay networks have become an effective alternative to IP multicast for efficient point to multipoint communication across the Internet .
1-2:Typically, nodes self organize with the goal of forming an efficient overlay tree, one that meets performance targets without placing undue burden on the underlying network .
1-3:In this paper, we target high bandwidth data distribution from a single source to a large number of receivers .
1-4:Applications include large file transfers and real time multimedia streaming .
1-5:For these applications, we argue that an overlay mesh, rather than a tree, can deliver fundamentally higher bandwidth and reliability relative to typical tree structures .
1-6:This paper presents Bullet, a scalable and distributed algorithm that enables nodes spread across the Internet to self organize into a high bandwidth overlay mesh .
1-7:We construct Bullet around the insight that data should be distributed in a disjoint manner to strategic points in the network .
1-8:Individual Bullet receivers are then responsible for locating and retrieving the data from multiple points in parallel .
1-9:Key contributions of this work include: i) an algorithm that sends data to different points in the overlay such that any data object is equally likely to appear at any node, ii) a scalable and decentralized algorithm that allows nodes to locate and recover missing data items, and iii) a complete implementation and evaluation of Bullet running across the Internet and in a large scale emulation environment reveals up to a factor two bandwidth improvements under a variety of circumstances .
1-10:In addition, we find that, relative to tree based solutions, Bullet reduces the need to perform expensive bandwidth probing .
1-11:In a tree, it is critical that a node"s parent delivers a high rate of application data to each child .
1-12:In Bullet however, nodes simultaneously receive data from multiple sources in parallel, making it less important to locate any single source capable of sustaining a high transmission rate .
1-13:C.2.4 [Computer Communication Networks]: Distributed .
2 INTRODUCTION :
2-1:In this paper, we consider the following general problem .
2-2:Given a sender and a large set of interested receivers spread across the Internet, how can we maximize the amount of bandwidth delivered to receivers? Our problem domain includes software or video distribution and real time multimedia streaming .
2-3:Traditionally, native IP multicast has been the preferred method for delivering content to a set of receivers in a scalable fashion .
2-4:However, a number of considerations, including scale, reliability, and congestion control, have limited the wide scale deployment of IP multicast .
2-5:Even if all these problems were to be addressed, IP multicast does not consider bandwidth when constructing its distribution tree .
2-6:More recently, overlays have emerged as a promising alternative to multicast for network efficient point to multipoint data delivery .
2-7:Typical overlay structures attempt to mimic the structure of multicast routing trees .
2-8:In network layer multicast however, interior nodes consist of high speed routers with limited processing power and extensibility .
2-9:Overlays, on the other hand, use programmable (and hence extensible) end hosts as interior nodes in the overlay tree, with these hosts acting as repeaters to multiple children down the tree .
2-10:Overlays have shown tremendous promise for multicast style applications .
2-11:However, we argue that a tree structure has fundamental limitations both for high bandwidth multicast and for high reliability .
2-12:One difficulty with trees is that bandwidth is guaranteed to be monotonically decreasing moving down the tree .
2-13:Any loss high up the tree will reduce the bandwidth available to receivers lower down the tree .
2-14:A number of techniques have been proposed to recover from losses and hence improve the available bandwidth in an overlay tree [2, 6] .
2-15:However, fundamentally, the bandwidth available to any host is limited by the bandwidth available from that node"s single parent in the tree .
2-16:Thus, our work operates on the premise that the model for high bandwidth multicast data dissemination should be re examined .
2-17:Rather than sending identical copies of the same data stream to all nodes in a tree and designing a scalable mechanism for recovering from loss, we propose that participants in a multicast overlay cooperate to strategically 282 transmit disjoint data sets to various points in the network .
2-18:Here, the sender splits data into sequential blocks .
2-19:Blocks are further subdivided into individual objects which are in turn transmitted to different points in the network .
2-20:Nodes still receive a set of objects from their parents, but they are then responsible for locating peers that hold missing data objects .
2-21:We use a distributed algorithm that aims to make the availability of data items uniformly spread across all overlay participants .
2-22:In this way, we avoid the problem of locating the last object, which may only be available at a few nodes .
2-23:One hypothesis of this work is that, relative to a tree, this model will result in higher bandwidth leveraging the bandwidth from simultaneous parallel downloads from multiple sources rather than a single parent and higher reliability retrieving data from multiple peers reduces the potential damage from a single node failure .
2-24:To illustrate Bullet"s behavior, consider a simple three node overlay with a root R and two children A and B .
2-25:R has 1 Mbps of available (TCP friendly) bandwidth to each of A and B .
2-26:However, there is also 1 Mbps of available bandwidth between A and B .
2-27:In this example, Bullet would transmit a disjoint set of data at 1 Mbps to each of A and B .
2-28:A and B would then each independently discover the availability of disjoint data at the remote peer and begin streaming data to one another, effectively achieving a retrieval rate of 2 Mbps .
2-29:On the other hand, any overlay tree is restricted to delivering at most 1 Mbps even with a scalable technique for recovering lost data .
2-30:Any solution for achieving the above model must maintain a number of properties .
2-31:First, it must be TCP friendly [15] .
2-32:No flow should consume more than its fair share of the bottleneck bandwidth and each flow must respond to congestion signals (losses) by reducing its transmission rate .
2-33:Second, it must impose low control overhead .
2-34:There are many possible sources of such overhead, including probing for available bandwidth between nodes, locating appropriate nodes to peer with for data retrieval and redundantly receiving the same data objects from multiple sources .
2-35:Third, the algorithm should be decentralized and scalable to thousands of participants .
2-36:No node should be required to learn or maintain global knowledge, for instance global group membership or the set of data objects currently available at all nodes .
2-37:Finally, the approach must be robust to individual failures .
2-38:For example, the failure of a single node should result only in a temporary reduction in the bandwidth delivered to a small subset of participants; no single failure should result in the complete loss of data for any significant fraction of nodes, as might be the case for a single node failure high up in a multicast overlay tree .
2-39:In this context, this paper presents the design and evaluation of Bullet, an algorithm for constructing an overlay mesh that attempts to maintain the above properties .
2-40:Bullet nodes begin by self organizing into an overlay tree, which can be constructed by any of a number of existing techniques [1, 18, 21, 24, 34] .
2-41:Each Bullet node, starting with the root of the underlying tree, then transmits a disjoint set of data to each of its children, with the goal of maintaining uniform representativeness of each data item across all participants .
2-42:The level of disjointness is determined by the bandwidth available to each of its children .
2-43:Bullet then employs a scalable and efficient algorithm to enable nodes to quickly locate multiple peers capable of transmitting missing data items to the node .
2-44:Thus, Bullet layers a high bandwidth mesh on top of an arbitrary overlay tree .
2-45:Depending on the type of data being transmitted, Bullet can optionally employ a variety of encoding schemes, for instance Erasure codes [7, 26, 25] or Multiple Description Coding [17], to efficiently disseminate data, adapt to variable bandwidth, and recover from losses .
2-46:Finally, we use TFRC [15] to transfer data both down the overlay tree and among peers .
2-47:This ensures that the entire overlay behaves in a congestion friendly manner, adjusting its transmission rate on a per connection basis based on prevailing network conditions .
2-48:One important benefit of our approach is that the bandwidth delivered by the Bullet mesh is somewhat independent of the bandwidth available through the underlying overlay tree .
2-49:One significant limitation to building high bandwidth overlay trees is the overhead associated with the tree construction protocol .
2-50:In these trees, it is critical that each participant locates a parent via probing with a high level of available bandwidth because it receives data from only a single source (its parent) .
2-51:Thus, even once the tree is constructed, nodes must continue their probing to adapt to dynamically changing network conditions .
2-52:While bandwidth probing is an active area of research [20, 35], accurate results generally require the transfer of a large amount of data to gain confidence in the results .
2-53:Our approach with Bullet allows receivers to obtain high bandwidth in aggregate using individual transfers from peers spread across the system .
2-54:Thus, in Bullet, the bandwidth available from any individual peer is much less important than in any bandwidthoptimized tree .
2-55:Further, all the bandwidth that would normally be consumed probing for bandwidth can be reallocated to streaming data across the Bullet mesh .
2-56:We have completed a prototype of Bullet running on top of a number of overlay trees .
2-57:Our evaluation of a 1000 node overlay running across a wide variety of emulated 20,000 node network topologies shows that Bullet can deliver up to twice the bandwidth of a bandwidth optimized tree (using an oﬄine algorithm and global network topology information), all while remaining TCP friendly .
2-58:We also deployed our prototype across the PlanetLab [31] wide area testbed .
2-59:For these live Internet runs, we find that Bullet can deliver comparable bandwidth performance improvements .
2-60:In both cases, the overhead of maintaining the Bullet mesh and locating the appropriate disjoint data is limited to 30 Kbps per node, acceptable for our target high bandwidth, large scale scenarios .
2-61:The remainder of this paper is organized as follows .
2-62:Section 2 presents Bullet"s system components including RanSub, informed content delivery, and TFRC .
2-63:Section 3 then details Bullet, an efficient data distribution system for bandwidth intensive applications .
2-64:Section 4 evaluates Bullet"s performance for a variety of network topologies, and compares it to existing multicast techniques .
2-65:Section 5 places our work in the context of related efforts and Section 6 presents our conclusions. .
3 SYSTEM COMPONENTS :
3-1:Our approach to high bandwidth data dissemination centers around the techniques depicted in Figure 1 .
3-2:First, we split the target data stream into blocks which are further subdivided into individual (typically packet sized) objects .
3-3:Depending on the requirements of the target applications, objects may be encoded [17, 26] to make data recovery more efficient .
3-4:Next, we purposefully disseminate disjoint objects 283 S A C Original data stream: 1 2 3 4 5 6 B 1 2 3 5 1 3 4 6 2 4 5 6 TFRC to determine available BW D E 1 2 5 1 3 4 Figure 1: High level view of Bullet"s operation .
3-5:to different clients at a rate determined by the available bandwidth to each client .
3-6:We use the equation based TFRC protocol to communicate among all nodes in the overlay in a congestion responsive and TCP friendly manner .
3-7:Given the above techniques, data is spread across the overlay tree at a rate commensurate with the available bandwidth in the overlay tree .
3-8:Our overall goal however is to deliver more bandwidth than would otherwise be available through any tree .
3-9:Thus, at this point, nodes require a scalable technique for locating and retrieving disjoint data from their peers .
3-10:In essence, these perpendicular links across the overlay form a mesh to augment the bandwidth available through the tree .
3-11:In Figure 1, node D only has sufficient bandwidth to receive 3 objects per time unit from its parent .
3-12:However, it is able to locate two peers, C and E, who are able to transmit missing data objects, in this example increasing delivered bandwidth from 3 objects per time unit to 6 data objects per time unit .
3-13:Locating appropriate remote peers cannot require global state or global communication .
3-14:Thus, we propose the periodic dissemination of changing, uniformly random subsets of global state to each overlay node once per configurable time period .
3-15:This random subset contains summary tickets of the objects available at a subset of the nodes in the system .
3-16:Each node uses this information to request data objects from remote nodes that have significant divergence in object membership .
3-17:It then attempts to establish a number of these peering relationships with the goals of minimizing overlap in the objects received from each peer and maximizing the total useful bandwidth delivered to it .
3-18:In the remainder of this section, we provide brief background on each of the techniques that we employ as fundamental building blocks for our work .
3-19:Section 3 then presents the details of the entire Bullet architecture .
3-20:2.1 Data Encoding Depending on the type of data being distributed through the system, a number of data encoding schemes can improve system efficiency .
3-21:For instance, if multimedia data is being distributed to a set of heterogeneous receivers with variable bandwidth, MDC [17] allows receivers obtaining different subsets of the data to still maintain a usable multimedia stream .
3-22:For dissemination of a large file among a set of receivers, Erasure codes enable receivers not to focus on retrieving every transmitted data packet .
3-23:Rather, after obtaining a threshold minimum number of packets, receivers are able to decode the original data stream .
3-24:Of course, Bullet is amenable to a variety of other encoding schemes or even the null encoding scheme, where the original data stream is transmitted best effort through the system .
3-25:In this paper, we focus on the benefits of a special class of erasure correcting codes used to implement the digital fountain [7] approach .
3-26:Redundant Tornado [26] codes are created by performing XOR operations on a selected number of original data packets, and then transmitted along with the original data packets .
3-27:Tornado codes require any (1+ )k correctly received packets to reconstruct the original k data packets, with the typically low reception overhead ( ) of 0.03 − 0.05 .
3-28:In return, they provide significantly faster encoding and decoding times .
3-29:Additionally, the decoding algorithm can run in real time, and the reconstruction process can start as soon as sufficiently many packets have arrived .
3-30:Tornado codes require a predetermined stretch factor (n k, where n is the total number of encoded packets), and their encoding time is proportional to n .
3-31:LT codes [25] remove these two limitations, while maintaining a low reception overhead of 0.05 .
3-32:2.2 RanSub To address the challenge of locating disjoint content within the system, we use RanSub [24], a scalable approach to distributing changing, uniform random subsets of global state to all nodes of an overlay tree .
3-33:RanSub assumes the presence of some scalable mechanism for efficiently building and maintaining the underlying tree .
3-34:A number of such techniques are described in [1, 18, 21, 24, 34] .
3-35:RanSub distributes random subsets of participating nodes throughout the tree using collect and distribute messages .
3-36:Collect messages start at the leaves and propagate up the tree, leaving state at each node along the path to the root .
3-37:Distribute messages start at the root and travel down the tree, using the information left at the nodes during the previous collect round to distribute uniformly random subsets to all participants .
3-38:Using the collect and distribute messages, RanSub distributes a random subset of participants to each node once per epoch .
3-39:The lower bound on the length of an epoch is determined by the time it takes to propagate data up then back down the tree, or roughly twice the height of the tree .
3-40:For appropriately constructed trees, the minimum epoch length will grow with the logarithm of the number of participants, though this is not required for correctness .
3-41:As part of the distribute message, each participant sends a uniformly random subset of remote nodes, called a distribute set, down to its children .
3-42:The contents of the distribute set are constructed using the collect set gathered during the previous collect phase .
3-43:During this phase, each participant sends a collect set consisting of a random subset of its descendant nodes up the tree to the root along with an estimate of its total number of descendants .
3-44:After the root receives all collect sets and the collect phase completes, the distribute phase begins again in a new epoch .
3-45:One of the key features of RanSub is the Compact operation .
3-46:This is the process used to ensure that membership in a collect set propagated by a node to its parent is both random and uniformly representative of all members of the sub tree rooted at that node .
3-47:Compact takes multiple fixedsize subsets and the total population represented by each subset as input, and generates a new fixed size subset .
3-48:The 284 A CSC={Cs}, CSD={Ds} CSF={Fs}, CSG={Gs} CSB={Bs,Cs,Ds}, CSE={Es,Fs,Gs} B C E D GF B C A E D GF DSE={As,Bs,Cs, Ds} DSB={As,Es,Fs,Gs} DSG={As,Bs,Cs, Ds,Es,Fs} DSD={As,Bs, Cs,Es,Fs,Gs} DSF={As,Bs,Cs, Ds,Es,Gs} DSC={As,Bs, Ds,Es,Fs,Gs} Figure 2: This example shows the two phases of the RanSub protocol that occur in one epoch .
3-49:The collect phase is shown on the left, where the collect sets are traveling up the overlay to the root .
3-50:The distribute phase on the right shows the distribute sets traveling down the overlay to the leaf nodes .
3-51:members of the resulting set are uniformly random representatives of the input subset members .
3-52:RanSub offers several ways of constructing distribute sets .
3-53:For our system, we choose the RanSub nondescendants option .
3-54:In this case, each node receives a random subset consisting of all nodes excluding its descendants .
3-55:This is appropriate for our download structure where descendants are expected to have less content than an ancestor node in most cases .
3-56:A parent creates RanSub nondescendants distribute sets for each child by compacting collect sets from that child"s siblings and its own distribute set .
3-57:The result is a distribute set that contains a random subset representing all nodes in the tree except for those rooted at that particular child .
3-58:We depict an example of RanSub"s collect distribute process in Figure 2 .
3-59:In the figure, AS stands for node A"s state .
3-60:2.3 Informed Content Delivery Techniques Assuming we can enable a node to locate a peer with disjoint content using RanSub, we need a method for reconciling the differences in the data .
3-61:Additionally, we require a bandwidth efficient method with low computational overhead .
3-62:We chose to implement the approximate reconciliation techniques proposed in [6] for these tasks in Bullet .
3-63:To describe the content, nodes maintain working sets .
3-64:The working set contains sequence numbers of packets that have been successfully received by each node over some period of time .
3-65:We need the ability to quickly discern the resemblance between working sets from two nodes and decide whether a fine grained reconciliation is beneficial .
3-66:Summary tickets, or min wise sketches [5], serve this purpose .
3-67:The main idea is to create a summary ticket that is an unbiased random sample of the working set .
3-68:A summary ticket is a small fixed size array .
3-69:Each entry in this array is maintained by a specific permutation function .
3-70:The goal is to have each entry populated by the element with the smallest permuted value .
3-71:To insert a new element into the summary ticket, we apply the permutation functions in order and update array values as appropriate .
3-72:The permutation function can be thought of as a specialized hash function .
3-73:The choice of permutation functions is important as the quality of the summary ticket depends directly on the randomness properties of the permutation functions .
3-74:Since we require them to have a low computational overhead, we use simple permutation functions, such as Pj(x) = (ax+b)mod|U|, where U is the universe size (dependant on the data encoding scheme) .
3-75:To compute the resemblance between two working sets, we compute the number of summary ticket entries that have the same value, and divide it by the total number of entries in the summary tickets .
3-76:Figure 3 shows the way the permutation functions are used to populate the summary ticket .
3-77:12 10 2 27 7 2 18 19 40 1 Workingset 14 42 17 33 38 15 12 P1 33 29 28 44 57 15 P2 22 28 45 61 14 51 Pn… … Summary ticket minminmin 10 2 Figure 3: Example showing a sample summary ticket being constructed from the working set .
3-78:To perform approximate fine grain reconciliation, a peer A sends its digest to peer B and expects to receive packets not described in the digest .
3-79:For this purpose, we use a Bloom filter [4], a bit array of size m with k independent associated hash functions .
3-80:An element s from the set of received keys S = {so, s2, .
3-81:.
3-82:.
3-83:, sn−1} is inserted into the filter by computing the hash values h0, h1, .
3-84:.
3-85:.
3-86:, hk−1 of s and setting the bits in the array that correspond to the hashed 285 values .
3-87:To check whether an element x is in the Bloom filter, we hash it using the hash functions and check whether all positions in the bit array are set .
3-88:If at least one is not set, we know that the Bloom filter does not contain x .
3-89:When using Bloom filters, the insertion of different elements might cause all the positions in the bit array corresponding to an element that is not in the set to be nonzero .
3-90:In this case, we have a false positive .
3-91:Therefore, it is possible that peer B will not send a packet to peer A even though A is missing it .
3-92:On the other hand, a node will never send a packet that is described in the Bloom filter, i.e .
3-93:there are no false negatives .
3-94:The probability of getting a false positive pf on the membership query can be expressed as a function of the ratio m n and the number of hash functions k: pf = (1 − e−kn m )k .
3-95:We can therefore choose the size of the Bloom filter and the number of hash functions that will yield a desired false positive ratio .
3-96:2.4 TCP Friendly Rate Control Although most traffic in the Internet today is best served by TCP, applications that require a smooth sending rate and that have a higher tolerance for loss often find TCP"s reaction to a single dropped packet to be unnecessarily severe .
3-97:TCP Friendly Rate Control, or TFRC, targets unicast streaming multimedia applications with a need for less drastic responses to single packet losses [15] .
3-98:TCP halves the sending rate as soon as one packet loss is detected .
3-99:Alternatively, TFRC is an equation based congestion control protocol that is based on loss events, which consist of multiple packets being dropped within one round trip time .
3-100:Unlike TCP, the goal of TFRC is not to find and use all available bandwidth, but instead to maintain a relatively steady sending rate while still being responsive to congestion .
3-101:To guarantee fairness with TCP, TFRC uses the response function that describes the steady state sending rate of TCP to determine the transmission rate in TFRC .
3-102:The formula of the TCP response function [27] used in TFRC to describe the sending rate is: T = s R Õ2p 3 +tRT O(3 Õ3p 8 )p(1+32p2) This is the expression for the sending rate T in bytes second, as a function of the round trip time R in seconds, loss event rate p, packet size s in bytes, and TCP retransmit value tRT O in seconds .
3-103:TFRC senders and receivers must cooperate to achieve a smooth transmission rate .
3-104:The sender is responsible for computing the weighted round trip time estimate R between sender and receiver, as well as determining a reasonable retransmit timeout value tRT O .
3-105:In most cases, using the simple formula tRT O = 4R provides the necessary fairness with TCP .
3-106:The sender is also responsible for adjusting the sending rate T in response to new values of the loss event rate p reported by the receiver .
3-107:The sender obtains a new measure for the loss event rate each time a feedback packet is received from the receiver .
3-108:Until the first loss is reported, the sender doubles its transmission rate each time it receives feedback just as TCP does during slow start .
3-109:The main role of the receiver is to send feedback to the sender once per round trip time and to calculate the loss event rate included in the feedback packets .
3-110:To obtain the loss event rate, the receiver maintains a loss interval array that contains values for the last eight loss intervals .
3-111:A loss interval is defined as the number of packets received correctly between two loss events .
3-112:The array is continually updated as losses are detected .
3-113:A weighted average is computed based on the sum of the loss interval values, and the inverse of the sum is the reported loss event rate, p .
3-114:When implementing Bullet, we used an unreliable version of TFRC .
3-115:We wanted a transport protocol that was congestion aware and TCP friendly .
3-116:Lost packets were more easily recovered from other sources rather than waiting for a retransmission from the initial sender .
3-117:Hence, we eliminate retransmissions from TFRC .
3-118:Further, TFRC does not aggressively seek newly available bandwidth like TCP, a desirable trait in an overlay tree where there might be multiple competing flows sharing the same links .
3-119:For example, if a leaf node in the tree tried to aggressively seek out new bandwidth, it could create congestion all the way up to the root of the tree .
3-120:By using TFRC we were able to avoid these scenarios. .
4 BULLET :
4-1:Bullet is an efficient data distribution system for bandwidth intensive applications .
4-2:While many current overlay network distribution algorithms use a distribution tree to deliver data from the tree"s root to all other nodes, Bullet layers a mesh on top of an original overlay tree to increase overall bandwidth to all nodes in the tree .
4-3:Hence, each node receives a parent stream from its parent in the tree and some number of perpendicular streams from chosen peers in the overlay .
4-4:This has significant bandwidth impact when a single node in the overlay is unable to deliver adequate bandwidth to a receiving node .
4-5:Bullet requires an underlying overlay tree for RanSub to deliver random subsets of participants"s state to nodes in the overlay, informing them of a set of nodes that may be good candidates for retrieving data not available from any of the node"s current peers and parent .
4-6:While we also use the underlying tree for baseline streaming, this is not critical to Bullet"s ability to efficiently deliver data to nodes in the overlay .
4-7:As a result, Bullet is capable of functioning on top of essentially any overlay tree .
4-8:In our experiments, we have run Bullet over random and bandwidth optimized trees created oﬄine (with global topological knowledge) .
4-9:Bullet registers itself with the underlying overlay tree so that it is informed when the overlay changes as nodes come and go or make performance transformations in the overlay .
4-10:As with streaming overlays trees, Bullet can use standard transports such as TCP and UDP as well as our implementation of TFRC .
4-11:For the remainder of this paper, we assume the use of TFRC since we primarily target streaming highbandwidth content and we do not require reliable or in order delivery .
4-12:For simplicity, we assume that packets originate at the root of the tree and are tagged with increasing sequence numbers .
4-13:Each node receiving a packet will optionally forward it to each of its children, depending on a number of factors relating to the child"s bandwidth and its relative position in the tree .
4-14:3.1 Finding Overlay Peers RanSub periodically delivers subsets of uniformly random selected nodes to each participant in the overlay .
4-15:Bullet receivers use these lists to locate remote peers able to transmit missing data items with good bandwidth .
4-16:RanSub messages contain a set of summary tickets that include a small (120 286 bytes) summary of the data that each node contains .
4-17:RanSub delivers subsets of these summary tickets to nodes every configurable epoch (5 seconds by default) .
4-18:Each node in the tree maintains a working set of the packets it has received thus far, indexed by sequence numbers .
4-19:Nodes associate each working set with a Bloom filter that maintains a summary of the packets received thus far .
4-20:Since the Bloom filter does not exceed a specific size (m) and we would like to limit the rate of false positives, Bullet periodically cleans up the Bloom filter by removing lower sequence numbers from it .
4-21:This allows us to keep the Bloom filter population n from growing at an unbounded rate .
4-22:The net effect is that a node will attempt to recover packets for a finite amount of time depending on the packet arrival rate .
4-23:Similarly, Bullet removes older items that are not needed for data reconstruction from its working set and summary ticket .
4-24:We use the collect and distribute phases of RanSub to carry Bullet summary tickets up and down the tree .
4-25:In our current implementation, we use a set size of 10 summary tickets, allowing each collect and distribute to fit well within the size of a non fragmented IP packet .
4-26:Though Bullet supports larger set sizes, we expect this parameter to be tunable to specific applications" needs .
4-27:In practice, our default size of 10 yields favorable results for a variety of overlays and network topologies .
4-28:In essence, during an epoch a node receives a summarized partial view of the system"s state at that time .
4-29:Upon receiving a random subset each epoch, a Bullet node may choose to peer with the node having the lowest similarity ratio when compared to its own summary ticket .
4-30:This is done only when the node has sufficient space in its sender list to accept another sender (senders with lackluster performance are removed from the current sender list as described in section 3.4) .
4-31:Once a node has chosen the best node it sends it a peering request containing the requesting node"s Bloom filter .
4-32:Such a request is accepted by the potential sender if it has sufficient space in its receiver list for the incoming receiver .
4-33:Otherwise, the send request is rejected (space is periodically created in the receiver lists as further described in section 3.4) .
4-34:3.2 Recovering Data From Peers Assuming it has space for the new peer, a recipient of the peering request installs the received Bloom filter and will periodically transmit keys not present in the Bloom filter to the requesting node .
4-35:The requesting node will refresh its installed Bloom filters at each of its sending peers periodically .
4-36:Along with the fresh filter, a receiving node will also assign a portion of the sequence space to each of its senders .
4-37:In this way, a node is able the reduce the likelihood that two peers simultaneously transmit the same key to it, wasting network resources .
4-38:A node divides the sequence space in its current working set among each of its senders uniformly .
4-39:As illustrated in Figure 4, a Bullet receiver views the data space as a matrix of packet sequences containing s rows, where s is its current number of sending peers .
4-40:A receiver periodically (every 5 seconds by default) updates each sender with its current Bloom filter and the range of sequences covered in its Bloom filter .
4-41:This identifies the range of packets that the receiver is currently interested in recovering .
4-42:Over time, this range shifts as depicted in Figure 4 b) .
4-43:In addition, the receiving node assigns to each sender a row from the matrix, labeled mod .
4-44:A sender will forward packets to b) Mod = 3 00000000000000000000000000000000001111111111111111111111111111111111 7 1 2 8 a) Senders = 7Mod = 2 Low High Time 00000000000000000000000000000000001111111111111111111111111111111111 Figure 4: A Bullet receiver views data as a matrix of sequenced packets with rows equal to the number of peer senders it currently has .
4-45:It requests data within the range (Low, High) of sequence numbers based on what it has received .
4-46:a) The receiver requests a specific row in the sequence matrix from each sender .
4-47:b) As it receives more data, the range of sequences advances and the receiver requests different rows from senders .
4-48:the receiver that have a sequence number x such that x modulo s equals the mod number .
4-49:In this fashion, receivers register to receive disjoint data from their sending peers .
4-50:By specifying ranges and matrix rows, a receiver is unlikely to receive duplicate data items, which would result in wasted bandwidth .
4-51:A duplicate packet, however, may be received when a parent recovers a packet from one of its peers and relays the packet to its children (and descendants) .
4-52:In this case, a descendant would receive the packet out of order and may have already recovered it from one of its peers .
4-53:In practice, this wasteful reception of duplicate packets is tolerable; less than 10% of all received packets are duplicates in our experiments .
4-54:3.3 Making Data Disjoint We now provide details of Bullet"s mechanisms to increase the ease by which nodes can find disjoint data not provided by parents .
4-55:We operate on the premise that the main challenge in recovering lost data packets transmitted over an overlay distribution tree lies in finding the peer node housing the data to recover .
4-56:Many systems take a hierarchical approach to this problem, propagating repair requests up the distribution tree until the request can be satisfied .
4-57:This ultimately leads to scalability issues at higher levels in the hierarchy particularly when overlay links are bandwidthconstrained .
4-58:On the other hand, Bullet attempts to recover lost data from any non descendant node, not just ancestors, thereby increasing overall system scalability .
4-59:In traditional overlay distribution trees, packets are lost by the transmission transport and or the network .
4-60:Nodes attempt to stream data as fast as possible to each child and have essentially no control over which portions of the data stream are dropped by the transport or network .
4-61:As a result, the streaming subsystem has no control over how many nodes in the system will ultimately receive a particular portion of the data .
4-62:If few nodes receive a particular range of packets, recovering these pieces of data becomes more difficult, requiring increased communication costs, and leading to scalability problems .
4-63:In contrast, Bullet nodes are aware of the bandwidth achievable to each of its children using the underlying transport .
4-64:If 287 a child is unable to receive the streaming rate that the parent receives, the parent consciously decides which portion of the data stream to forward to the constrained child .
4-65:In addition, because nodes recover data from participants chosen uniformly at random from the set of non descendants, it is advantageous to make each transmitted packet recoverable from approximately the same number of participant nodes .
4-66:That is, given a randomly chosen subset of peer nodes, it is with the same probability that each node has a particular data packet .
4-67:While not explicitly proven here, we believe that this approach maximizes the probability that a lost data packet can be recovered, regardless of which packet is lost .
4-68:To this end, Bullet distributes incoming packets among one or more children in hopes that the expected number of nodes receiving each packet is approximately the same .
4-69:A node p maintains for each child, i, a limiting and sending factor, lfi and sfi .
4-70:These factors determine the proportion of p"s received data rate that it will forward to each child .
4-71:The sending factor sfi is the portion of the parent stream (rate) that each child should own based on the number of descendants the child has .
4-72:The more descendants a child has, the larger the portion of received data it should own .
4-73:The limiting factor lfi represents the proportion of the parent rate beyond the sending factor that each child can handle .
4-74:For example, a child with one descendant, but high bandwidth would have a low sending factor, but a very high limiting factor .
4-75:Though the child is responsible for owning a small portion of the received data, it actually can receive a large portion of it .
4-76:Because RanSub collects descendant counts di for each child i, Bullet simply makes a call into RanSub when sending data to determine the current sending factors of its children .
4-77:For each child i out of k total, we set the sending factor to be: sfi = diÈk j=1 dj .
4-78:In addition, a node tracks the data successfully transmitted via the transport .
4-79:That is, Bullet data transport sockets are non blocking; successful transmissions are send attempts that are accepted by the non blocking transport .
4-80:If the transport would block on a send (i.e., transmission of the packet would exceed the TCP friendly fair share of network resources), the send fails and is counted as an unsuccessful send attempt .
4-81:When a data packet is received by a parent, it calculates the proportion of the total data stream that has been sent to each child, thus far, in this epoch .
4-82:It then assigns ownership of the current packet to the child with sending proportion farthest away from its sfi as illustrated in Figure 5 .
4-83:Having chosen the target of a particular packet, the parent attempts to forward the packet to the child .
4-84:If the send is not successful, the node must find an alternate child to own the packet .
4-85:This occurs when a child"s bandwidth is not adequate to fulfill its responsibilities based on its descendants (sfi) .
4-86:To compensate, the node attempts to deterministically find a child that can own the packet (as evidenced by its transport accepting the packet) .
4-87:The net result is that children with more than adequate bandwidth will own more of their share of packets than those with inadequate bandwidth .
4-88:In the event that no child can accept a packet, it must be dropped, corresponding to the case where the sum of all children bandwidths is inadequate to serve the received foreach child in children { if ( (child >sent total_sent) < child >sending_factor) target_child = child; } if (!senddata( target_child >addr, msg, size, key)) { send succeeded target_child >sent++; target_child >child_filter.insert(got_key); sent_packet = 1; } foreach child in children { should_send = 0; if (!sent_packet) transfer ownership should_send = 1; else test for available bandwidth if ( key % (1.0 child >limiting_factor) == 0 ) should_send = 1; if (should_send) { if (!senddata( child >addr, msg, size, key)) { if (!sent_packet) i received ownership child >sent++; else increase(child >limiting_factor); child >child_filter.insert(got_key); sent_packet = 1; } else send failed if (sent_packet) was for extra bw decrease(child >limiting_factor); } } Figure 5: Pseudo code for Bullet"s disjoint data send routine stream .
4-89:While making data more difficult to recover, Bullet still allows for recovery of such data to its children .
4-90:The sending node will cache the data packet and serve it to its requesting peers .
4-91:This process allows its children to potentially recover the packet from one of their own peers, to whom additional bandwidth may be available .
4-92:Once a packet has been successfully sent to the owning child, the node attempts to send the packet to all other children depending on the limiting factors lfi .
4-93:For each child i, a node attempts to forward the packet deterministically if the packet"s sequence modulo 1 lfi is zero .
4-94:Essentially, this identifies which lfi fraction of packets of the received data stream should be forwarded to each child to make use of the available bandwidth to each .
4-95:If the packet transmission is successful, lfi is increased such that one more packet is to be sent per epoch .
4-96:If the transmission fails, lfi is decreased by the same amount .
4-97:This allows children limiting factors to be continuously adjusted in response to changing network conditions .
4-98:It is important to realize that by maintaining limiting factors, we are essentially using feedback from children (by observing transport behavior) to determine the best data to stop sending during times when a child cannot handle the entire parent stream .
4-99:In one extreme, if the sum of children bandwidths is not enough to receive the entire parent stream, each child will receive a completely disjoint data stream of packets it owns .
4-100:In the other extreme, if each 288 child has ample bandwidth, it will receive the entire parent stream as each lfi would settle on 1.0 .
4-101:In the general case, our owning strategy attempts to make data disjoint among children subtrees with the guiding premise that, as much as possible, the expected number of nodes receiving a packet is the same across all packets .
4-102:3.4 Improving the Bullet Mesh Bullet allows a maximum number of peering relationships .
4-103:That is, a node can have up to a certain number of receivers and a certain number of senders (each defaults to 10 in our implementation) .
4-104:A number of considerations can make the current peering relationships sub optimal at any given time: i) the probabilistic nature of RanSub means that a node may not have been exposed to a sufficiently appropriate peer, ii) receivers greedily choose peers, and iii) network conditions are constantly changing .
4-105:For example, a sender node may wind up being unable to provide a node with very much useful (non duplicate) data .
4-106:In such a case, it would be advantageous to remove that sender as a peer and find some other peer that offers better utility .
4-107:Each node periodically (every few RanSub epochs) evaluates the bandwidth performance it is receiving from its sending peers .
4-108:A node will drop a peer if it is sending too many duplicate packets when compared to the total number of packets received .
4-109:This threshold is set to 50% by default .
4-110:If no such wasteful sender is found, a node will drop the sender that is delivering the least amount of useful data to it .
4-111:It will replace this sender with some other sending peer candidate, essentially reserving a trial slot in its sender list .
4-112:In this way, we are assured of keeping the best senders seen so far and will eliminate senders whose performance deteriorates with changing network conditions .
4-113:Likewise, a Bullet sender will periodically evaluate its receivers .
4-114:Each receiver updates senders of the total received bandwidth .
4-115:The sender, knowing the amount of data it has sent to each receiver, can determine which receiver is benefiting the least by peering with this sender .
4-116:This corresponds to the one receiver acquiring the least portion of its bandwidth through this sender .
4-117:The sender drops this receiver, creating an empty slot for some other trial receiver .
4-118:This is similar to the concept of weans presented in [24]. .
5 EVALUATION :
5-1:We have evaluated Bullet"s performance in real Internet environments as well as the ModelNet [37] IP emulation framework .
5-2:While the bulk of our experiments use ModelNet, we also report on our experience with Bullet on the PlanetLab Internet testbed [31] .
5-3:In addition, we have implemented a number of underlying overlay network trees upon which Bullet can execute .
5-4:Because Bullet performs well over a randomly created overlay tree, we present results with Bullet running over such a tree compared against an oﬄine greedy bottleneck bandwidth tree algorithm using global topological information described in Section 4.1 .
5-5:All of our implementations leverage a common development infrastructure called MACEDON [33] that allows for the specification of overlay algorithms in a simple domainspecific language .
5-6:It enables the reuse of the majority of common functionality in these distributed systems, including probing infrastructures, thread management, message passing, and debugging environment .
5-7:As a result, we believe that our comparisons qualitatively show algorithmic differences rather than implementation intricacies .
5-8:Our implementation of the core Bullet logic is under 1000 lines of code in this infrastructure .
5-9:Our ModelNet experiments make use of 50 2Ghz Pentium4"s running Linux 2.4.20 and interconnected with 100 Mbps and 1 Gbps Ethernet switches .
5-10:For the majority of these experiments, we multiplex one thousand instances (overlay participants) of our overlay applications across the 50 Linux nodes (20 per machine) .
5-11:In ModelNet, packet transmissions are routed through emulators responsible for accurately emulating the hop by hop delay, bandwidth, and congestion of a network topology .
5-12:In our evaluations, we used four 1.4Ghz Pentium III"s running FreeBSD 4.7 as emulators .
5-13:This platform supports approximately 2 3 Gbps of aggregate simultaneous communication among end hosts .
5-14:For most of our ModelNet experiments, we use 20,000 node INET generated topologies [10] .
5-15:We randomly assign our participant nodes to act as clients connected to one degree stub nodes in the topology .
5-16:We randomly select one of these participants to act as the source of the data stream .
5-17:Propagation delays in the network topology are calculated based on the relative placement of the network nodes in the plane by INET .
5-18:Based on the classification in [8], we classify network links as being Client Stub, Stub Stub, TransitStub, and Transit Transit depending on their location in the network .
5-19:We restrict topological bandwidth by setting the bandwidth for each link depending on its type .
5-20:Each type of link has an associated bandwidth range from which the bandwidth is chosen uniformly at random .
5-21:By changing these ranges, we vary bandwidth constraints in our topologies .
5-22:For our experiments, we created three different ranges corresponding to low, medium, and high bandwidths relative to our typical streaming rates of 600 1000 Kbps as specified in Table 1 .
5-23:While the presented ModelNet results are restricted to two topologies with varying bandwidth constraints, the results of experiments with additional topologies all show qualitatively similar behavior .
5-24:We do not implement any particular coding scheme for our experiments .
5-25:Rather, we assume that either each sequence number directly specifies a particular data block and the block offset for each packet, or we are distributing data within the same block for LT Codes, e.g., when distributing a file .
5-26:4.1 Offline Bottleneck Bandwidth Tree One of our goals is to determine Bullet"s performance relative to the best possible bandwidth optimized tree for a given network topology .
5-27:This allows us to quantify the possible improvements of an overlay mesh constructed using Bullet relative to the best possible tree .
5-28:While we have not yet proven this, we believe that this problem is NP hard .
5-29:Thus, in this section we present a simple greedy oﬄine algorithm to determine the connectivity of a tree likely to deliver a high level of bandwidth .
5-30:In practice, we are not aware of any scalable online algorithms that are able to deliver the bandwidth of an oﬄine algorithm .
5-31:At the same time, trees constructed by our algorithm tend to be long and skinny making them less resilient to failures and inappropriate for delay sensitive applications (such as multimedia streaming) .
5-32:In addition to any performance comparisons, a Bullet mesh has much lower depth than the bottleneck tree and is more resilient to failure, as discussed in Section 4.6 .
5-33:289 Topology classification Client Stub Stub Stub Transit Stub Transit Transit Low bandwidth 300 600 500 1000 1000 2000 2000 4000 Medium bandwidth 800 2800 1000 4000 1000 4000 5000 10000 High bandwidth 1600 5600 2000 8000 2000 8000 10000 20000 Table 1: Bandwidth ranges for link types used in our topologies expressed in Kbps .
5-34:Specifically, we consider the following problem: given complete knowledge of the topology (individual link latencies, bandwidth, and packet loss rates), what is the overlay tree that will deliver the highest bandwidth to a set of predetermined overlay nodes? We assume that the throughput of the slowest overlay link (the bottleneck link) determines the throughput of the entire tree .
5-35:We are, therefore, trying to find the directed overlay tree with the maximum bottleneck link .
5-36:Accordingly, we refer to this problem as the overlay maximum bottleneck tree .
5-37:In a simplified case, assuming that congestion only exists on access links and there are no lossy links, there exists an optimal algorithm [23] .
5-38:In the more general case of contention on any physical link, and when the system is allowed to choose the routing path between the two endpoints, this problem is known to be NP hard [12], even in the absence of link losses .
5-39:For the purposes of this paper, our goal is to determine a good overlay streaming tree that provides each overlay participant with substantial bandwidth, while avoiding overlay links with high end to end loss rates .
5-40:We make the following assumptions: is fixed .
5-41:This closely models the existing overlay network model with IP for unicast routing .
5-42:connections to transfer data point to point .
5-43:throughput of a TCP friendly flow using a steady state formula [27] .
5-44:each flow can achieve throughput of at most c n , where c is the physical capacity of the link .
5-45:Given these assumptions, we concentrate on estimating the throughput available between two participants in the overlay .
5-46:We start by calculating the throughput using the steady state formula .
5-47:We then route the flow in the network, and consider the physical links one at a time .
5-48:On each physical link, we compute the fair share for each of the competing flows .
5-49:The throughput of an overlay link is then approximated by the minimum of the fair shares along the routing path, and the formula rate .
5-50:If some flow does not require the same share of the bottleneck link as other competing flows (i.e., its throughput might be limited by losses elsewhere in the network), then the other flows might end up with a greater share than the one we compute .
5-51:We do not account for this, as the major goal of this estimate is simply to avoid lossy and highly congested physical links .
5-52:More formally, we define the problem as follows: Overlay Maximum Bottleneck Tree .
5-53:Given a physical network represented as a graph G = (V, E), set of overlay participants P ⊂ V , source node (s ∈ P), bandwidth B : E → R+ , loss rate L : E → [0, 1], propagation delay D : E → R+ of each link, set of possible overlay links O = {(v, w) | v, w ∈ P, v = w}, routing table RT : O × E → {0, 1}, find the overlay tree T = {o | o ∈ O} (|T| = |P| − 1, ∀v ∈ P there exists a path ov = s ❀ v) that maximizes min o|o∈T (min(f(o), min e|e∈o b(e) |{p | p ∈ T, e ∈ p}| )) where f(o) is the TCP steady state sending rate, computed from round trip time d(o) = Èe∈o d(e) + Èe∈o d(e) (given overlay link o = (v, w), o = (w, v)), and loss rate l(o) = 1 − Ée∈o (1 − l(e)) .
5-54:We write e ∈ o to express that link e is included in the o"s routing path (RT(o, e) = 1) .
5-55:Assuming that we can estimate the throughput of a flow, we proceed to formulate a greedy OMBT algorithm .
5-56:This algorithm is non optimal, but a similar approach was found to perform well [12] .
5-57:Our algorithm is similar to the Widest Path Heuristic [12], and more generally to Prim"s MST algorithm [32] .
5-58:During its execution, we maintain the set of nodes already in the tree, and the set of remaining nodes .
5-59:To grow the tree, we consider all the overlay links leading from the nodes in the tree to the remaining nodes .
5-60:We greedily pick the node with the highest throughput overlay link .
5-61:Using this overlay link might cause us to route traffic over physical links traversed by some other tree flows .
5-62:Since we do not re examine the throughput of nodes that are already in the tree, they might end up being connected to the tree with slower overlay links than initially estimated .
5-63:However, by attaching the node with the highest residual bandwidth at every step, we hope to lessen the effects of after the fact physical link sharing .
5-64:With the synthetic topologies we use for our emulation environment, we have not found this inaccuracy to severely impact the quality of the tree .
5-65:4.2 Bullet vs .
5-66:Streaming We have implemented a simple streaming application that is capable of streaming data over any specified tree .
5-67:In our implementation, we are able to stream data through overlay trees using UDP, TFRC, or TCP .
5-68:Figure 6 shows average bandwidth that each of 1000 nodes receives via this streaming as time progresses on the x axis .
5-69:In this example, we use TFRC to stream 600 Kbps over our oﬄine bottleneck bandwidth tree and a random tree (other random trees exhibit qualitatively similar behavior) .
5-70:In these experiments, streaming begins 100 seconds into each run .
5-71:While the random tree delivers an achieved bandwidth of under 100 Kbps, our oﬄine algorithm overlay delivers approximately 400 Kbps of data .
5-72:For this experiment, bandwidths were set to the medium range from Table 1 .
5-73:We believe that any degree constrained online bandwidth overlay tree algorithm would exhibit similar (or lower) behavior to our bandwidth290 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bottleneck bandwidth tree Random tree Figure 6: Achieved bandwidth over time for TFRC streaming over the bottleneck bandwidth tree and a random tree .
5-74:optimized overlay .
5-75:Hence, Bullet"s goal is to overcome this bandwidth limit by allowing for the perpendicular reception of data and by utilizing disjoint data flows in an attempt to match or exceed the performance of our oﬄine algorithm .
5-76:To evaluate Bullet"s ability to exceed the bandwidth achievable via tree distribution overlays, we compare Bullet running over a random overlay tree to the streaming behavior shown in Figure 6 .
5-77:Figure 7 shows the average bandwidth received by each node (labeled Useful total) with standard deviation .
5-78:The graph also plots the total amount of data received and the amount of data a node receives from its parent .
5-79:For this topology and bandwidth setting, Bullet was able to achieve an average bandwidth of 500 Kbps, fives times that achieved by the random tree and more than 25% higher than the oﬄine bottleneck bandwidth algorithm .
5-80:Further, the total bandwidth (including redundant data) received by each node is only slightly higher than the useful content, meaning that Bullet is able to achieve high bandwidth while wasting little network resources .
5-81:Bullet"s use of TFRC in this example ensures that the overlay is TCP friendly throughout .
5-82:The average per node control overhead is approximately 30 Kbps .
5-83:By tracing certain packets as they move through the system, we are able to acquire link stress estimates of our system .
5-84:Though the link stress can be different for each packet since each can take a different path through the overlay mesh, we average link stress due to each traced packet .
5-85:For this experiment, Bullet has an average link stress of approximately 1.5 with an absolute maximum link stress of 22 .
5-86:The standard deviation in most of our runs is fairly high because of the limited bandwidth randomly assigned to some Client Stub and Stub Stub links .
5-87:We feel that this is consistent with real Internet behavior where clients have widely varying network connectivity .
5-88:A time slice is shown in Figure 8 that plots the CDF of instantaneous bandwidths that each node receives .
5-89:The graph shows that few client nodes receive inadequate bandwidth even though they are bandwidth constrained .
5-90:The distribution rises sharply starting at approximately 500 Kbps .
5-91:The vast majority of nodes receive a stream of 500 600 Kbps .
5-92:We have evaluated Bullet under a number of bandwidth constraints to determine how Bullet performs relative to the 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 7: Achieved bandwidth over time for Bullet over a random tree .
5-93:0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600 700 800 Percentageofnodes Bandwidth(Kbps) Figure 8: CDF of instantaneous achieved bandwidth at time 430 seconds .
5-94:available bandwidth of the underlying topology .
5-95:Table 1 describes representative bandwidth settings for our streaming rate of 600 Kbps .
5-96:The intent of these settings is to show a scenario where more than enough bandwidth is available to achieve a target rate even with traditional tree streaming, an example of where it is slightly not sufficient, and one in which the available bandwidth is quite restricted .
5-97:Figure 9 shows achieved bandwidths for Bullet and the bottleneck bandwidth tree over time generated from topologies with bandwidths in each range .
5-98:In all of our experiments, Bullet outperforms the bottleneck bandwidth tree by a factor of up to 100%, depending on how much bandwidth is constrained in the underlying topology .
5-99:In one extreme, having more than ample bandwidth, Bullet and the bottleneck bandwidth tree are both able to stream at the requested rate (600 Kbps in our example) .
5-100:In the other extreme, heavily constrained topologies allow Bullet to achieve twice the bandwidth achievable via the bottleneck bandwidth tree .
5-101:For all other topologies, Bullet"s benefits are somewhere in between .
5-102:In our example, Bullet running over our medium constrained bandwidth topology is able to outperform the bottleneck bandwidth tree by a factor of 25% .
5-103:Further, we stress that we believe it would 291 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet High Bandwidth Bottleneck tree High Bandwidth Bullet Medium Bandwidth Bottleneck tree Medium Bandwidth Bullet Low Bandwidth Bottleneck tree Low Bandwidth Figure 9: Achieved bandwidth for Bullet and bottleneck tree over time for high, medium, and low bandwidth topologies .
5-104:be extremely difficult for any online tree based algorithm to exceed the bandwidth achievable by our oﬄine bottleneck algorithm that makes use of global topological information .
5-105:For instance, we built a simple bandwidth optimizing overlay tree construction based on Overcast [21] .
5-106:The resulting dynamically constructed trees never achieved more than 75% of the bandwidth of our own oﬄine algorithm .
5-107:4.3 Creating Disjoint Data Bullet"s ability to deliver high bandwidth levels to nodes depends on its disjoint transmission strategy .
5-108:That is, when bandwidth to a child is limited, Bullet attempts to send the correct portions of data so that recovery of the lost data is facilitated .
5-109:A Bullet parent sends different data to its children in hopes that each data item will be readily available to nodes spread throughout its subtree .
5-110:It does so by assigning ownership of data objects to children in a manner that makes the expected number of nodes holding a particular data object equal for all data objects it transmits .
5-111:Figure 10 shows the resulting bandwidth over time for the non disjoint strategy in which a node (and more importantly, the root of the tree) attempts to send all data to each of its children (subject to independent losses at individual child links) .
5-112:Because the children transports throttle the sending rate at each parent, some data is inherently sent disjointly (by chance) .
5-113:By not explicitly choosing which data to send its child, this approach deprives Bullet of 25% of its bandwidth capability, when compared to the case when our disjoint strategy is enabled in Figure 7 .
5-114:4.4 Epidemic Approaches In this section, we explore how Bullet compares to data dissemination approaches that use some form of epidemic routing .
5-115:We implemented a form of gossiping, where a node forwards non duplicate packets to a randomly chosen number of nodes in its local view .
5-116:This technique does not use a tree for dissemination, and is similar to lpbcast [14] (recently improved to incorporate retrieval of data objects [13]) .
5-117:We do not disseminate packets every T seconds; instead we forward them as soon as they arrive .
5-118:0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 450 500 Bandwidth(Kbps) Time (s) Raw total Useful total From parent Figure 10: Achieved bandwidth over time using nondisjoint data transmission .
5-119:We also implemented a pbcast like [2] approach for retrieving data missing from a data distribution tree .
5-120:The idea here is that nodes are expected to obtain most of their data from their parent .
5-121:Nodes then attempt to retrieve any missing data items through gossiping with random peers .
5-122:Instead of using gossiping with a fixed number of rounds for each packet, we use anti entropy with a FIFO Bloom filter to attempt to locate peers that hold any locally missing data items .
5-123:To make our evaluation conservative, we assume that nodes employing gossip and anti entropy recovery are able to maintain full group membership .
5-124:While this might be difficult in practice, we assume that RanSub [24] could also be applied to these ideas, specifically in the case of anti entropy recovery that employs an underlying tree .
5-125:Further, we also allow both techniques to reuse other aspects of our implementation: Bloom filters, TFRC transport, etc .
5-126:To reduce the number of duplicate packets, we use less peers in each round (5) than Bullet (10) .
5-127:For our configuration, we experimentally found that 5 peers results in the best performance with the lowest overhead .
5-128:In our experiments, increasing the number of peers did not improve the average bandwidth achieved throughout the system .
5-129:To allow TFRC enough time to ramp up to the appropriate TCP friendly sending rate, we set the epoch length for anti entropy recovery to 20 seconds .
5-130:For these experiments, we use a 5000 node INET topology with no explicit physical link losses .
5-131:We set link bandwidths according to the medium range from Table 1, and randomly assign 100 overlay participants .
5-132:The randomly chosen root either streams at 900 Kbps (over a random tree for Bullet and greedy bottleneck tree for anti entropy recovery), or sends packets at that rate to randomly chosen nodes for gossiping .
5-133:Figure 11 shows the resulting bandwidth over time achieved by Bullet and the two epidemic approaches .
5-134:As expected, Bullet comes close to providing the target bandwidth to all participants, achieving approximately 60 percent more then gossiping and streaming with anti entropy .
5-135:The two epidemic techniques send an excessive number of duplicates, effectively reducing the useful bandwidth provided to each node .
5-136:More importantly, both approaches assign equal significance to other peers, regardless of the available band292 0 500 1000 1500 2000 0 50 100 150 200 250 300 Bandwidth(Kbps) Time (s) Push gossiping raw Streaming w AE raw Bullet raw Bullet useful Push gossiping useful Streaming w AE useful Figure 11: Achieved bandwidth over time for Bullet and epidemic approaches .
5-137:width and the similarity ratio .
5-138:Bullet, on the other hand, establishes long term connections with peers that provide good bandwidth and disjoint content, and avoids most of the duplicates by requesting disjoint data from each node"s peers .
5-139:4.5 Bullet on a Lossy Network To evaluate Bullet"s performance under more lossy network conditions, we have modified our 20,000 node topologies used in our previous experiments to include random packet losses .
5-140:ModelNet allows the specification of a packet loss rate in the description of a network link .
5-141:Our goal by modifying these loss rates is to simulate queuing behavior when the network is under load due to background network traffic .
5-142:To effect this behavior, we first modify all non transit links in each topology to have a packet loss rate chosen uniformly random from [0, 0.003] resulting in a maximum loss rate of 0.3% .
5-143:Transit links are likewise modified, but with a maximum loss rate of 0.1% .
5-144:Similar to the approach in [28], we randomly designated 5% of the links in the topologies as overloaded and set their loss rates uniformly random from [0.05, 0.1] resulting in a maximum packet loss rate of 10% .
5-145:Figure 12 shows achieved bandwidths for streaming over Bullet and using our greedy oﬄine bottleneck bandwidth tree .
5-146:Because losses adversely affect the bandwidth achievable over TCP friendly transport and since bandwidths are strictly monotonically decreasing over a streaming tree, treebased algorithms perform considerably worse than Bullet when used on a lossy network .
5-147:In all cases, Bullet delivers at least twice as much bandwidth than the bottleneck bandwidth tree .
5-148:Additionally, losses in the low bandwidth topology essentially keep the bottleneck bandwidth tree from delivering any data, an artifact that is avoided by Bullet .
5-149:4.6 Performance Under Failure In this section, we discuss Bullet"s behavior in the face of node failure .
5-150:In contrast to streaming distribution trees that must quickly detect and make tree transformations to overcome failure, Bullet"s failure resilience rests on its ability to maintain a higher level of achieved bandwidth by virtue of perpendicular (peer) streaming .
5-151:While all nodes under a failed node in a distribution tree will experience a temporary 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bullet High Bandwidth Bullet Medium Bandwidth Bottleneck tree High Bandwidth Bottleneck tree Medium Bandwidth Bullet Low Bandwidth Bottleneck tree Low Bandwidth Figure 12: Achieved bandwidths for Bullet and bottleneck bandwidth tree over a lossy network topology .
5-152:disruption in service, Bullet nodes are able compensate for this by receiving data from peers throughout the outage .
5-153:Because Bullet, and, more importantly, RanSub makes use of an underlying tree overlay, part of Bullet"s failure recovery properties will depend on the failure recovery behavior of the underlying tree .
5-154:For the purposes of this discussion, we simply assume the worst case scenario where an underlying tree has no failure recovery .
5-155:In our failure experiments, we fail one of root"s children (with 110 of the total 1000 nodes as descendants) 250 seconds after data streaming is started .
5-156:By failing one of root"s children, we are able to show Bullet"s worst case performance under a single node failure .
5-157:In our first scenario, we disable failure detection in RanSub so that after a failure occurs, Bullet nodes request data only from their current peers .
5-158:That is, at this point, RanSub stops functioning and no new peer relationships are created for the remainder of the run .
5-159:Figure 13 shows Bullet"s achieved bandwidth over time for this case .
5-160:While the average achieved rate drops from 500 Kbps to 350 Kbps, most nodes (including the descendants of the failed root child) are able to recover a large portion of the data rate .
5-161:Next, we enable RanSub failure detection that recognizes a node"s failure when a RanSub epoch has lasted longer than the predetermined maximum (5 seconds for this test) .
5-162:In this case, the root simply initiates the next distribute phase upon RanSub timeout .
5-163:The net result is that nodes that are not descendants of the failed node will continue to receive updated random subsets allowing them to peer with appropriate nodes reflecting the new network conditions .
5-164:As shown in Figure 14, the failure causes a negligible disruption in performance .
5-165:With RanSub failure detection enabled, nodes quickly learn of other nodes from which to receive data .
5-166:Once such recovery completes, the descendants of the failed node use their already established peer relationships to compensate for their ancestor"s failure .
5-167:Hence, because Bullet is an overlay mesh, its reliability characteristics far exceed that of typical overlay distribution trees .
5-168:4.7 PlanetLab This section contains results from the deployment of Bullet over the PlanetLab [31] wide area network testbed .
5-169:For 293 0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 13: Bandwidth over time with a worst case node failure and no RanSub recovery .
5-170:0 200 400 600 800 1000 0 50 100 150 200 250 300 350 400 Bandwidth(Kbps) Time (s) Bandwidth received Useful total From parent Figure 14: Bandwidth over time with a worst case node failure and RanSub recovery enabled .
5-171:our first experiment, we chose 47 nodes for our deployment, with no two machines being deployed at the same site .
5-172:Since there is currently ample bandwidth available throughout the PlanetLab overlay (a characteristic not necessarily representative of the Internet at large), we designed this experiment to show that Bullet can achieve higher bandwidth than an overlay tree when the source is constrained, for instance in cases of congestion on its outbound access link, or of overload by a flash crowd .
5-173:We did this by choosing a root in Europe connected to PlanetLab with fairly low bandwidth .
5-174:The node we selected was in Italy (cs.unibo.it) and we had 10 other overlay nodes in Europe .
5-175:Without global knowledge of the topology in PlanetLab (and the Internet), we are, of course, unable to produce our greedy bottleneck bandwidth tree for comparison .
5-176:We ran Bullet over a random overlay tree for 300 seconds while attempting to stream at a rate of 1.5 Mbps .
5-177:We waited 50 seconds before starting to stream data to allow nodes to successfully join the tree .
5-178:We compare the performance of Bullet to data streaming over multiple handcrafted trees .
5-179:Figure 15 shows our results for two such trees .
5-180:The good tree has all nodes in Europe located high in the tree, close to the root .
5-181:We used pathload [20] to measure the 0 200 400 600 800 1000 1200 0 50 100 150 200 250 Bandwidth(Kbps) Time (s) Bullet Good Tree Worst Tree Figure 15: Achieved bandwidth over time for Bullet and TFRC streaming over different trees on PlanetLab with a root in Europe .
5-182:available bandwidth between the root and all other nodes .
5-183:Nodes with high bandwidth measurements were placed close to the root .
5-184:In this case, we are able to achieve a bandwidth of approximately 300 Kbps .
5-185:The worst tree was created by setting the root"s children to be the three nodes with the worst bandwidth characteristics from the root as measured by pathload .
5-186:All subsequent levels in the tree were set in this fashion .
5-187:For comparison, we replaced all nodes in Europe from our topology with nodes in the US, creating a topology that only included US nodes with high bandwidth characteristics .
5-188:As expected, Bullet was able to achieve the full 1.5 Mbps rate in this case .
5-189:A well constructed tree over this highbandwidth topology yielded slightly lower than 1.5 Mbps, verifying that our approach does not sacrifice performance under high bandwidth conditions and improves performance under constrained bandwidth scenarios. .
6 RELATED WORK :
6-1:Snoeren et al .
6-2:[36] use an overlay mesh to achieve reliable and timely delivery of mission critical data .
6-3:In this system, every node chooses n parents from which to receive duplicate packet streams .
6-4:Since its foremost emphasis is reliability, the system does not attempt to improve the bandwidth delivered to the overlay participants by sending disjoint data at each level .
6-5:Further, during recovery from parent failure, it limits an overlay router"s choice of parents to nodes with a level number that is less than its own level number .
6-6:The power of perpendicular downloads is perhaps best illustrated by Kazaa [22], the popular peer to peer file swapping network .
6-7:Kazaa nodes are organized into a scalable, hierarchical structure .
6-8:Individual users search for desired content in the structure and proceed to simultaneously download potentially disjoint pieces from nodes that already have it .
6-9:Since Kazaa does not address the multicast communication model, a large fraction of users downloading the same file would consume more bandwidth than nodes organized into the Bullet overlay structure .
6-10:Kazaa does not use erasure coding; therefore it may take considerable time to locate the last few bytes .
6-11:294 BitTorrent [3] is another example of a file distribution system currently deployed on the Internet .
6-12:It utilizes trackers that direct downloaders to random subsets of machines that already have portions of the file .
6-13:The tracker poses a scalability limit, as it continuously updates the systemwide distribution of the file .
6-14:Lowering the tracker communication rate could hurt the overall system performance, as information might be out of date .
6-15:Further, BitTorrent does not employ any strategy to disseminate data to different regions of the network, potentially making it more difficult to recover data depending on client access patterns .
6-16:Similar to Bullet, BitTorrent incorporates the notion of choking at each node with the goal of identifying receivers that benefit the most by downloading from that particular source .
6-17:FastReplica [11] addresses the problem of reliable and efficient file distribution in content distribution networks (CDNs) .
6-18:In the basic algorithm, nodes are organized into groups of fixed size (n), with full group membership information at each node .
6-19:To distribute the file, a node splits it into n equal sized portions, sends the portions to other group members, and instructs them to download the missing pieces in parallel from other group members .
6-20:Since only a fixed portion of the file is transmitted along each of the overlay links, the impact of congestion is smaller than in the case of tree distribution .
6-21:However, since it treats all paths equally, FastReplica does not take full advantage of highbandwidth overlay links in the system .
6-22:Since it requires file store and forward logic at each level of the hierarchy necessary for scaling the system, it may not be applicable to high bandwidth streaming .
6-23:There are numerous protocols that aim to add reliability to IP multicast .
6-24:In Scalable Reliable Multicast [16], nodes multicast retransmission requests for missed packets .
6-25:Two techniques attempt to improve the scalability of this approach: probabilistic choice of retransmission timeouts, and organization of receivers into hierarchical local recovery groups .
6-26:However, it is difficult to find appropriate timer values and local scoping settings (via the TTL field) for a wide range of topologies, number of receivers, etc .
6-27:even when adaptive techniques are used .
6-28:One recent study [2] shows that SRM may have significant overhead due to retransmission requests .
6-29:Bullet is closely related to efforts that use epidemic data propagation techniques to recover from losses in the nonreliable IP multicast tree .
6-30:In pbcast [2], a node has global group membership, and periodically chooses a random subset of peers to send a digest of its received packets .
6-31:A node that receives the digest responds to the sender with the missing packets in a last in, first out fashion .
6-32:Lbpcast [14] addresses pbcast"s scalability issues (associated with global knowledge) by constructing, in a decentralized fashion, a partial group membership view at each node .
6-33:The average size of the views is engineered to allow a message to reach all participants with high probability .
6-34:Since lbpcast does not require an underlying tree for data distribution and relies on the push gossiping model, its network overhead can be quite high .
6-35:Compared to the reliable multicast efforts, Bullet behaves favorably in terms of the network overhead because nodes do not blindly request retransmissions from their peers .
6-36:Instead, Bullet uses the summary views it obtains through RanSub to guide its actions toward nodes with disjoint content .
6-37:Further, a Bullet node splits the retransmission load between all of its peers .
6-38:We note that pbcast nodes contain a mechanism to rate limit retransmitted packets and to send different packets in response to the same digest .
6-39:However, this does not guarantee that packets received in parallel from multiple peers will not be duplicates .
6-40:More importantly, the multicast recovery methods are limited by the bandwidth through the tree, while Bullet strives to provide more bandwidth to all receivers by making data deliberately disjoint throughout the tree .
6-41:Narada [19] builds a delay optimized mesh interconnecting all participating nodes and actively measures the available bandwidth on overlay links .
6-42:It then runs a standard routing protocol on top of the overlay mesh to construct forwarding trees using each node as a possible source .
6-43:Narada nodes maintain global knowledge about all group participants, limiting system scalability to several tens of nodes .
6-44:Further, the bandwidth available through a Narada tree is still limited to the bandwidth available from each parent .
6-45:On the other hand, the fundamental goal of Bullet is to increase bandwidth through download of disjoint data from multiple peers .
6-46:Overcast [21] is an example of a bandwidth efficient overlay tree construction algorithm .
6-47:In this system, all nodes join at the root and migrate down to the point in the tree where they are still able to maintain some minimum level of bandwidth .
6-48:Bullet is expected to be more resilient to node departures than any tree, including Overcast .
6-49:Instead of a node waiting to get the data it missed from a new parent, a node can start getting data from its perpendicular peers .
6-50:This transition is seamless, as the node that is disconnected from its parent will start demanding more missing packets from its peers during the standard round of refreshing its filters .
6-51:Overcast convergence time is limited by probes to immediate siblings and ancestors .
6-52:Bullet is able to provide approximately a target bandwidth without having a fully converged tree .
6-53:In parallel to our own work, SplitStream [9] also has the goal of achieving high bandwidth data dissemination .
6-54:It operates by splitting the multicast stream into k stripes, transmitting each stripe along a separate multicast tree built using Scribe [34] .
6-55:The key design goal of the tree construction mechanism is to have each node be an intermediate node in at most one tree (while observing both inbound and outbound node bandwidth constraints), thereby reducing the impact of a single node"s sudden departure on the rest of the system .
6-56:The join procedure can potentially sacrifice the interior node disjointness achieved by Scribe .
6-57:Perhaps more importantly, SplitStream assumes that there is enough available bandwidth to carry each stripe on every link of the tree, including the links between the data source and the roots of individual stripe trees independently chosen by Scribe .
6-58:To some extent, Bullet and SplitStream are complementary .
6-59:For instance, Bullet could run on each of the stripes to maximize the bandwidth delivered to each node along each stripe .
6-60:CoopNet [29] considers live content streaming in a peerto peer environment, subject to high node churn .
6-61:Consequently, the system favors resilience over network efficiency .
6-62:It uses a centralized approach for constructing either random or deterministic node disjoint (similar to SplitStream) trees, and it includes an MDC [17] adaptation framework based on scalable receiver feedback that attempts to maximize the signal to noise ratio perceived by receivers .
6-63:In the case of on demand streaming, CoopNet [30] addresses 295 the flash crowd problem at the central server by redirecting incoming clients to a fixed number of nodes that have previously retrieved portions of the same content .
6-64:Compared to CoopNet, Bullet provides nodes with a uniformly random subset of the system wide distribution of the file. .
7-1:Typically, high bandwidth overlay data streaming takes place over a distribution tree
7-2:In this paper, we argue that, in fact, an overlay mesh is able to deliver fundamentally higher bandwidth
7-3:Of course, a number of difficult challenges must be overcome to ensure that nodes in the mesh do not repeatedly receive the same data from peers
7-4:This paper presents the design and implementation of Bullet, a scalable and efficient overlay construction algorithm that overcomes this challenge to deliver significant bandwidth improvements relative to traditional tree structures
7-5:Specifically, this paper makes the following contributions: • We present the design and analysis of Bullet, an overlay construction algorithm that creates a mesh over any distribution tree and allows overlay participants to achieve a higher bandwidth throughput than traditional data streaming
7-6:As a related benefit, we eliminate the overhead required to probe for available bandwidth in traditional distributed tree construction techniques
7-7:• We provide a technique for recovering missing data from peers in a scalable and efficient manner
7-8:RanSub periodically disseminates summaries of data sets received by a changing, uniformly random subset of global participants
7-9:• We propose a mechanism for making data disjoint and then distributing it in a uniform way that makes the probability of finding a peer containing missing data equal for all nodes
7-10:• A large scale evaluation of 1000 overlay participants running in an emulated 20,000 node network topology, as well as experimentation on top of the PlanetLab Internet testbed, shows that Bullet running over a random tree can achieve twice the throughput of streaming over a traditional bandwidth tree
7-11:Acknowledgments We would like to thank David Becker for his invaluable help with our ModelNet experiments and Ken Yocum for his help with ModelNet emulation optimizations
7-12:In addition, we thank our shepherd Barbara Liskov and our anonymous reviewers who provided excellent feedback.
8-1:Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy
8-2:Scalable Application Layer Multicast
8-3:In Proceedings of ACM SIGCOMM, August 2002
8-4:Kenneth Birman, Mark Hayden, Oznur Ozkasap, Zhen Xiao, Mihai Budiu, and Yaron Minsky
8-5:Bimodal Multicast
8-6:ACM Transaction on Computer Systems, 17(2), May 1999
8-7:Bittorrent
8-8:http:  bitconjurer.org BitTorrent
8-9:Burton Bloom
8-10:Space Time Trade offs in Hash Coding with Allowable Errors
8-11:Communication of ACM, 13(7):422 426, July 1970
8-12:Andrei Broder
8-13:On the Resemblance and Containment of Documents
8-14:In Proceedings of Compression and Complexity of Sequences (SEQUENCES"97), 1997
8-15:John W
8-16:Byers, Jeffrey Considine, Michael Mitzenmacher, and Stanislav Rost
8-17:Informed Content Delivery Across Adaptive Overlay Networks
8-18:In Proceedings of ACM SIGCOMM, August 2002
8-19:John W
8-20:Byers, Michael Luby, Michael Mitzenmacher, and Ashutosh Rege
8-21:A Digital Fountain Approach to Reliable Distribution of Bulk Data
8-22:In SIGCOMM, pages 56 67, 1998
8-23:Ken Calvert, Matt Doar, and Ellen W
8-24:Zegura
8-25:Modeling Internet Topology
8-26:IEEE Communications Magazine, June 1997
8-27:Miguel Castro, Peter Druschel, Anne Marie Kermarrec, Animesh Nandi, Antony Rowstron, and Atul Singh
8-28:Splitstream: High bandwidth Content Distribution in Cooperative Environments
8-29:In Proceedings of the 19th ACM Symposium on Operating System Principles, October 2003
8-30:Hyunseok Chang, Ramesh Govindan, Sugih Jamin, Scott Shenker, and Walter Willinger
8-31:Towards Capturing Representative AS Level Internet Topologies
8-32:In Proceedings of ACM SIGMETRICS, June 2002
8-33:Ludmila Cherkasova and Jangwon Lee
8-34:FastReplica: Efficient Large File Distribution within Content Delivery Networks
8-35:In 4th USENIX Symposium on Internet Technologies and Systems, March 2003
8-36:Reuven Cohen and Gideon Kaempfer
8-37:A Unicast based Approach for Streaming Multicast
8-38:In INFOCOM, pages 440 448, 2001
8-39:Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne Marie Kermarrec, and Petr Kouznetsov
8-40:Lightweight Probabilistic Broadcast
8-41:To appear in ACM Transactions on Computer Systems
8-42:Patrick Eugster, Sidath Handurukande, Rachid Guerraoui, Anne Marie Kermarrec, and Petr Kouznetsov
8-43:Lightweight Probabilistic Broadcast
8-44:In Proceedings of The International Conference on Dependable Systems and Networks (DSN), 2001
8-45:Sally Floyd, Mark Handley, Jitendra Padhye, and Jorg Widmer
8-46:Equation based congestion control for unicast applications
8-47:In SIGCOMM 2000, pages 43 56, Stockholm, Sweden, August 2000
8-48:Sally Floyd, Van Jacobson, Ching Gung Liu, Steven McCanne, and Lixia Zhang
8-49:A Reliable Multicast Framework for Light weight Sessions and Application Level Framing
8-50:IEEE ACM Transactions on Networking, 5(6):784 803, 1997
8-51:Vivek K Goyal
8-52:Multiple Description Coding: Compression Meets the Network
8-53:IEEE Signal Processing Mag., pages 74 93, May 2001
8-54:Yang hua Chu, Sanjay Rao, and Hui Zhang
8-55:A Case For End System Multicast
8-56:In Proceedings of the ACM Sigmetrics 2000 International Conference on Measurement and Modeling of Computer Systems, June 2000
8-57:Yang hua Chu, Sanjay G
8-58:Rao, Srinivasan Seshan, and Hui Zhang
8-59:Enabling Conferencing Applications on the Internet using an Overlay Multicast Architecture
8-60:In Proceedings of ACM SIGCOMM, August 2001
8-61:Manish Jain and Constantinos Dovrolis
8-62:End to end Available Bandwidth: Measurement Methodology, Dynamics, and Relation with TCP Throughput
8-63:In Proceedings of SIGCOMM 2002, New York, August 19 23 2002
8-64:John Jannotti, David K
8-65:Gifford, Kirk L
8-66:Johnson, M
8-67:Frans Kaashoek, and Jr
8-68:James W
8-69:O"Toole
8-70:Overcast: Reliable Multicasting with an Overlay Network
8-71:In Proceedings of Operating Systems Design and Implementation (OSDI), October 2000
8-72:Kazaa media desktop
8-73:http:  www.kazaa.com
8-74:Min Sik Kim, Simon S
8-75:Lam, and Dong Young Lee
8-76:296 Optimal Distribution Tree for Internet Streaming Media
8-77:Technical Report TR 02 48, Department of Computer Sciences, University of Texas at Austin, September 2002
8-78:Dejan Kosti´c, Adolfo Rodriguez, Jeannie Albrecht, Abhijeet Bhirud, and Amin Vahdat
8-79:Using Random Subsets to Build Scalable Network Services
8-80:In Proceedings of the USENIX Symposium on Internet Technologies and Systems, March 2003
8-81:Michael Luby
8-82:LT Codes
8-83:In In The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002
8-84:Michael G
8-85:Luby, Michael Mitzenmacher, M
8-86:Amin Shokrollahi, Daniel A
8-87:Spielman, and Volker Stemann
8-88:Practical Loss Resilient Codes
8-89:In Proceedings of the 29th Annual ACM Symposium on the Theory of Computing (STOC "97), pages 150 159, New York, May 1997
8-90:Association for Computing Machinery
8-91:Jitedra Padhye, Victor Firoiu, Don Towsley, and Jim Krusoe
8-92:Modeling TCP Throughput: A Simple Model and its Empirical Validation
8-93:In ACM SIGCOMM "98 conference on Applications, technologies, architectures, and protocols for computer communication, pages 303 314, Vancouver, CA, 1998
8-94:Venkata N
8-95:Padmanabhan, Lili Qiu, and Helen J
8-96:Wang
8-97:Server based Inference of Internet Link Lossiness
8-98:In Proceedings of the IEEE Infocom, San Francisco, CA, USA, 2003
8-99:Venkata N
8-100:Padmanabhan, Helen J
8-101:Wang, and Philip A
8-102:Chou
8-103:Resilient Peer to Peer Streaming
8-104:In Proceedings of the 11th ICNP, Atlanta, Georgia, USA, 2003
8-105:Venkata N
8-106:Padmanabhan, Helen J
8-107:Wang, Philip A
8-108:Chou, and Kunwadee Sripanidkulchai
8-109:Distributing Streaming Media Content Using Cooperative Networking
8-110:In ACM IEEE NOSSDAV, 2002
8-111:Larry Peterson, Tom Anderson, David Culler, and Timothy Roscoe
8-112:A Blueprint for Introducing Disruptive Technology into the Internet
8-113:In Proceedings of ACM HotNets I, October 2002
8-114:R
8-115:C
8-116:Prim
8-117:Shortest Connection Networks and Some Generalizations
8-118:In Bell Systems Technical Journal, pages 1389 1401, November 1957
8-119:Adolfo Rodriguez, Sooraj Bhat, Charles Killian, Dejan Kosti´c, and Amin Vahdat
8-120:MACEDON: Methodology for Automatically Creating, Evaluating, and Designing Overlay Networks
8-121:Technical Report CS 2003 09, Duke University, July 2003
8-122:Antony Rowstron, Anne Marie Kermarrec, Miguel Castro, and Peter Druschel
8-123:SCRIBE: The Design of a Large scale Event Notification Infrastructure
8-124:In Third International Workshop on Networked Group Communication, November 2001
8-125:Stefan Savage
8-126:Sting: A TCP based Network Measurement Tool
8-127:In Proceedings of the 2nd USENIX Symposium on Internet Technologies and Systems (USITS 99), pages 71 80, Berkeley, CA, October 11 14 1999
8-128:USENIX Association
8-129:Alex C
8-130:Snoeren, Kenneth Conley, and David K
8-131:Gifford
8-132:Mesh Based Content Routing Using XML
8-133:In Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP "01), October 2001
8-134:Amin Vahdat, Ken Yocum, Kevin Walsh, Priya Mahadevan, Dejan Kosti´c, Jeff Chase, and David Becker
8-135:Scalability and Accuracy in a Large Scale Network Emulator
8-136:In Proceedings of the 5th Symposium on Operating Systems Design and Implementation (OSDI), December 2002
8-137:297
picture:
