Encryption-Enforced Access Control in Dynamic 
content:
1 ABSTRACT :
1-1:Publish subscribe systems provide an efficient, event based, wide area distributed communications infrastructure .
1-2:Large scale publish subscribe systems are likely to employ components of the event transport network owned by cooperating, but independent organisations .
1-3:As the number of participants in the network increases, security becomes an increasing concern .
1-4:This paper extends previous work to present and evaluate a secure multi domain publish subscribe infrastructure that supports and enforces fine grained access control over the individual attributes of event types .
1-5:Key refresh allows us to ensure forward and backward security when event brokers join and leave the network .
1-6:We demonstrate that the time and space overheads can be minimised by careful consideration of encryption techniques, and by the use of caching to decrease unnecessary decryptions .
1-7:We show that our approach has a smaller overall communication overhead than existing approaches for achieving the same degree of control over security in publish subscribe networks .
1-8:C.2.4 [Computer Communication Networks]: .
2 INTRODUCTION :
2-1:Publish subscribe is well suited as a communication mechanism for building Internet scale distributed event driven applications .
2-2:Much of its capacity for scale in the number of participants comes from its decoupling of publishers and subscribers by placing an asynchronous event delivery service between them .
2-3:In truly Internet scale publish subscribe systems, the event delivery service will include a large set of interconnected broker nodes spanning a wide geographic (and thus network) area .
2-4:However, publish subscribe systems that do span a wide geographic area are likely to also span multiple administrative domains, be they independent administrative domains inside a single organisation, multiple independent organisations, or a combination of the two .
2-5:While the communication capabilities of publish subscribe systems are well proved, spanning multiple administrative domains is likely to require addressing security considerations .
2-6:As security and access control are almost the antithesis of decoupling, relatively little publish subscribe research has focused on security so far .
2-7:Our overall research aim is to develop Internet scale publish subscribe networks that provide secure, efficient delivery of events, fault tolerance and self healing in the delivery infrastructure, and a convenient event interface .
2-8:In [12] Pesonen et al .
2-9:propose a multi domain, capabilitybased access control architecture for publish subscribe systems .
2-10:The architecture provides a mechanism for authorising event clients to publish and subscribe to event types .
2-11:The privileges of the client are checked by the local broker that the client connects to in order to access the publish subscribe system .
2-12:The approach implements access control at the edge of the broker network and assumes that all brokers can be trusted to enforce the access control policies correctly .
2-13:Any malicious, compromised or unauthorised broker is free to read and write any events that pass through it on their way from the publishers to the subscribers .
2-14:This might be acceptable in a relatively small system deployed inside a single organisation, but it is not appropriate in a multi domain environment in which organisations share a common infrastructure .
2-15:We propose enforcing access control within the broker network by encrypting event content, and that policy dictate controls over the necessary encryption keys .
2-16:With encrypted event content only those brokers that are authorised to ac104 cess the encryption keys are able to access the event content (i.e .
2-17:publish, subscribe to, or filter) .
2-18:We effectively move the enforcement of access control from the brokers to the encryption key managers .
2-19:We expect that access control would need to be enforced in a multi domain publish subscribe system when multiple organisations form a shared publish subscribe system yet run multiple independent applications .
2-20:Access control might also be needed when a single organisation consists of multiple sub domains that deliver confidential data over the organisation wide publish subscribe system .
2-21:Both cases require access control because event delivery in a dynamic publish subscribe infrastructure based on a shared broker network may well lead to events being routed through unauthorised domains along their paths from publishers to subscribers .
2-22:There are two particular benefits to sharing the publish subscribe infrastructure, both of which relate to the broker network .
2-23:First, sharing brokers will create a physically larger network that will provide greater geographic reach .
2-24:Second, increasing the inter connectivity of brokers will allow the publish subscribe system to provide higher faulttolerance .
2-25:Figure 1 shows the multi domain publish subscribe network we use as an example throughout this paper .
2-26:It is based on the United Kingdom Police Forces, and we show three particular sub domains: Metropolitan Police Domain .
2-27:This domain contains a set of CCTV cameras that publish information about the movements of vehicles around the London area .
2-28:We have included Detective Smith as a subscriber in this domain .
2-29:Congestion Charge Service Domain .
2-30:The charges that are levied on the vehicles that have passed through the London Congestion Charge zone each day are issued by systems within this domain .
2-31:The source numberplate recognition data comes from the cameras in the Metropolitan Police Domain .
2-32:The fact that the CCS are only authorised to read a subset of the vehicle event data will exercise some of the key features of the enforceable publish subscribe system access control presented in this paper .
2-33:PITO Domain .
2-34:The Police Information Technology Organisation is the centre from which Police data standards are managed .
2-35:It is the event type owner in this particular scenario .
2-36:Encryption protects the confidentiality of events should they be transported through unauthorised domains .
2-37:However encrypting whole events means unauthorised brokers cannot make efficient routing decisions .
2-38:Our approach is to apply encryption to the individual attributes of events .
2-39:This way our multi domain access control policy works at a finer granularity publishers and subscribers may be authorised access to a subset of the available attributes .
2-40:In cases where non encrypted events are used for routing, we can reduce the total number of events sent through the system without revealing the values of sensitive attributes .
2-41:In our example scenario, the Congestion Charge Service would only be authorised to read the numberplate field of vehicle sightings the location attribute would not be decrypted .
2-42:We thus preserve the privacy of motorists while still allowing the CCS to do its job using the shared publish subscribe infrastructure .
2-43:Let us assume that a Metropolitan Police Service detective is investigating a crime and she is interested in sightings of a specific vehicle .
2-44:The detective gets a court order that authorises her to subscribe to numberplate events of the specific numberplate related to her case .
2-45:Current publish subscribe access control systems enforce security at the edge of the broker network where clients connect to it .
2-46:However this approach will often not be acceptable in Internet scale systems .
2-47:We propose enforcing security within the broker network as well as at the edges that event clients connect to, by encrypting event content .
2-48:Publications will be encrypted with their event type specific encryption keys .
2-49:By controlling access to the encryption keys, we can control access to the event types .
2-50:The proposed approach allows event brokers to route events even when they have access only to a subset of the potential encryption keys .
2-51:We introduce decentralised publish subscribe systems and relevant cryptography in Section 2 .
2-52:In Section 3 we present our model for encrypting event content on both the event and the attribute level .
2-53:Section 4 discusses managing encryption keys in multi domain publish subscribe systems .
2-54:We analytically evaluate the performance of our proposal in Section 5 .
2-55:Finally Section 6 discusses related work in securing publish subscribe systems and Section 7 provides concluding remarks. .
3 BACKGROUND :
3-1:In this section we provide a brief introduction to decentralised publish subscribe systems .
3-2:We indicate our assumptions about multi domain publish subscribe systems, and describe how these assumptions influence the developments we have made from our previously published work .
3-3:2.1 Decentralised Publish Subscribe Systems A publish subscribe system includes publishers, subscribers, and an event service .
3-4:Publishers publish events, subscribers subscribe to events of interest to them, and the event service is responsible for delivering published events to all subscribers whose interests match the given event .
3-5:The event service in a decentralised publish subscribe system is distributed over a number of broker nodes .
3-6:Together these brokers form a network that is responsible for maintaining the necessary routing paths from publishers to subscribers .
3-7:Clients (publishers and subscribers) connect to a local broker, which is fully trusted by the client .
3-8:In our discussion we refer to the client hosting brokers as publisher hosting brokers or subscriber hosting brokers depending on whether the connected client is a publisher or 105 IB SHB Sub Pub Pub Sub Sub IB PHB IB IB PHB IB IB IB IB SHB SHB IBIB IB IB IB IB IB IBIB IB TO IB IB IB Metropolitan Police Domain Congestion Charge Service Domain PITO Domain Detective Smith Camera 1 Camera 2 Billing Office Statistics Office Sub Subscriber SHB Subscriber Hosting Broker Pub Publisher PHB Publisher Hosting Broker TO Type Owner IB Intermediate Broker KEY Figure 1: An overall view of our multi domain publish subscribe deployment a subscriber, respectively .
3-9:A local broker is usually either part of the same domain as the client, or it is owned by a service provider trusted by the client .
3-10:A broker network can have a static topology (e.g .
3-11:Siena [3] and Gryphon [14]) or a dynamic topology (e.g .
3-12:Scribe [4] and Hermes [13]) .
3-13:Our proposed approach will work in both cases .
3-14:A static topology enables the system administrator to build trusted domains and in that way improve the efficiency of routing by avoiding unnecessary encryptions (see Sect .
3-15:3.4), which is very difficult with a dynamic topology .
3-16:On the other hand, a dynamic topology allows the broker network to dynamically re balance itself when brokers join or leave the network either in a controlled fashion or as a result of a network or node failure .
3-17:Our work is based on the Hermes system .
3-18:Hermes is a content based publish subscribe middleware that includes strong event type support .
3-19:In other words, each publication is an instance of a particular predefined event type .
3-20:Publications are type checked at the local broker of each publisher .
3-21:Our attribute level encryption scheme assumes that events are typed .
3-22:Hermes uses a structured overlay network as a transport and therefore has a dynamic topology .
3-23:A Hermes publication consists of an event type identifier and a set of attribute value pairs .
3-24:The type identifier is the SHA 1 hash of the name of the event type .
3-25:It is used to route the publication through the event broker network .
3-26:It conveniently hides the type of the publication, i.e .
3-27:brokers are prevented from seeing which events are flowing through them unless they are aware of the specific event type name and identifier .
3-28:2.2 Secure Event Types Pesonen et al .
3-29:introduced secure event types in [11], which can have their integrity and authenticity confirmed by checking their digital signatures .
3-30:A useful side effect of secure event types are their globally unique event type and attribute names .
3-31:These names can be referred to by access control policies .
3-32:In this paper we use the secure name of the event type or attribute to refer to the encryption key used to encrypt the event or attribute .
3-33:2.3 Capability Based Access Control Pesonen et al .
3-34:proposed a capability based access control architecture for multi domain publish subscribe systems in [12] .
3-35:The model treats event types as resources that publishers, subscribers, and event brokers want to access .
3-36:The event type owner is responsible for managing access control for an event type by issuing Simple Public Key Infrastructure authorisation certificates that grant the holder access to the specified event type .
3-37:For example, authorised publishers will have been issued an authorisation certificate that specifies that the publisher, identified by public key, is authorised to publish instances of the event type specified in the certificate .
3-38:We leverage the above mentioned access control mechanism in this paper by controlling access to encryption keys using the same authorisation certificates .
3-39:That is, a publisher who is authorised to publish a given event type, is also authorised 106 to access the encryption keys used to protect events of that type .
3-40:We discuss this in more detail in Sect .
3-41:4 .
3-42:2.4 Threat model The goal of the proposed mechanism is to enforce access control for authorised participants in the system .
3-43:In our case the first level of access control is applied when the participant tries to join the publish subscribe network .
3-44:Unauthorised event brokers are not allowed to join the broker network .
3-45:Similarly unauthorised event clients are not allowed to connect to an event broker .
3-46:All the connections in the broker network between event brokers and event clients utilise Transport Layer Security [5] in order to prevent unauthorised access on the transport layer .
3-47:The architecture of the publish subscribe system means that event clients must connect to event brokers in order to be able to access the publish subscribe system .
3-48:Thus we assume that these clients are not a threat .
3-49:The event client relies completely on the local event broker for access to the broker network .
3-50:Therefore the event client is unable to access any events without the assistance of the local broker .
3-51:The brokers on the other hand are able to analyse all events in the system that pass through them .
3-52:A broker can analyse both the event traffic as well as the number and names of attributes that are populated in an event (in the case of attribute level encryption) .
3-53:There are viable approaches to preventing traffic analysis by inserting random events into the event stream in order to produce a uniform traffic pattern .
3-54:Similarly attribute content can be padded to a standard length in order to avoid leaking information to the adversary .
3-55:While traffic analysis is an important concern we have not addressed it further in this paper. .
4 ENCRYPTING EVENT CONTENT :
4-1:We propose enforcing access control in a decentralised broker network by encrypting the contents of published events and controlling access to the encryption keys .
4-2:Effectively we move the responsibility for access control from the broker network to the key managers .
4-3:It is assumed that all clients have access to a broker that they can trust and that is authorised to access the event content required by the client .
4-4:This allows us to implement the event content encryption within the broker network without involving the clients .
4-5:By delegating the encryption tasks to the brokers, we lower the number of nodes required to have access to a given encryption key1 .
4-6:The benefits are three fold: i) fewer nodes handle the confidential encryption key so there is a smaller chance of the key being disclosed; ii) key refreshes involve fewer nodes which means that the key management algorithm will incur smaller communication and processing overheads to the publish subscribe system; and iii) the local broker will decrypt an event once and deliver it to all subscribers, instead of each subscriber 1 The encryption keys are changed over time in response to brokers joining or leaving the network, and periodically to reduce the amount of time any single key is used .
4-7:This is discussed in Sect .
4-8:4.2 having to decrypt the same event .
4-9:Delegating encryption tasks to the local broker is appropriate, because encryption is a middleware feature used to enforce access control within the middleware system .
4-10:If applications need to handle encrypted data in the application layer, they are free to publish encrypted data over the publish subscribe system .
4-11:We can implement encryption either at the event level or the attribute level .
4-12:Event encryption is simpler, requires fewer keys, fewer independent cryptographic operations, and thus is usually faster .
4-13:Attribute encryption enables access control at the attribute level, which means that we have a more expressive and powerful access control mechanism, while usually incurring a larger performance penalty .
4-14:In this section we discuss encrypting event content both at the event level and the attribute level; avoiding leaking information to unauthorised brokers by encrypting subscription filters; avoiding unnecessary encryptions between authorised brokers; and finally, how event content encryption was implemented in our prototype .
4-15:Note that since no publish subscribe client is ever given access to encryption keys, any encryption performed by the brokers is necessarily completely transparent to all clients .
4-16:3.1 Event Encryption In event encryption all the event attributes are encrypted as a single block of plaintext .
4-17:The event type identifier is left intact (i.e .
4-18:in plaintext) in order to facilitate event routing in the broker network .
4-19:The globally unique event type identifier specifies the encryption key used to encrypt the event content .
4-20:Each event type in the system will have its own individual encryption key .
4-21:Keys are refreshed, as discussed in Sect .
4-22:4.2 .
4-23:While in transit the event will consist of a tuple containing the type identifier, a publication timestamp, ciphertext, and a message authentication tag: <type id, timestamp, cipher text, authentication tag> .
4-24:Event brokers that are authorised to access the event, and thus have access to the encryption key, can decrypt the event and implement content based routing .
4-25:Event brokers that do not have access to the encryption key will be forced to route the event based only on its type .
4-26:That is, they will not be able to make intelligent decisions about whether events need not be transmitted down their outgoing links .
4-27:Event encryption results in one encryption at the publisher hosting broker, and one decryption at each filtering intermediate broker and subscriber hosting broker that the event passes through, regardless of the number of attributes .
4-28:This results in a significant performance advantage compared to attribute encryption .
4-29:3.2 Attribute Encryption In attribute encryption each attribute value in an event is encrypted separately with its own encryption key .
4-30:The encryption key is identified by the attribute"s globally unique identifier (the globally unique event identifier defines a namespace inside which the attribute identifier is a fully qualified name) .
4-31:107 The event type identifier is left intact to facilitate event routing for unauthorised brokers .
4-32:The attribute identifiers are also left intact to allow authorised brokers to decrypt the attribute values with the correct keys .
4-33:Brokers that are authorised to access some of the attributes in an event, can implement content based routing over the attributes that are accessible to them .
4-34:An attribute encrypted event in transit consists of the event type identifier, a publication timestamp, and a set of attribute tuples: <type id, timestamp, attributes > .
4-35:Attribute tuples consist of an attribute identifier, ciphertext, and a message authentication tag: <attr id, ciphertext, authentication tag> .
4-36:The attribute identifier is the SHA 1 hash of the attribute name used in the event type definition .
4-37:Using the attribute identifier in the published event instead of the attribute name prevents unauthorised parties from learning which attributes are included in the publication .
4-38:Compared with event encryption, attribute encryption usually results in larger processing overheads, because each attribute is encrypted separately .
4-39:In the encryption process the initialisation of the encryption algorithm takes a significant portion of the total running time of the algorithm .
4-40:Once the algorithm is initialised, increasing the amount of data to be encrypted does not affect the running time very much .
4-41:This disparity is emphasised in attribute encryption, where an encryption algorithm must be initialised for each attribute separately, and the amount of data encrypted is relatively small .
4-42:As a result attribute encryption incurs larger processing overheads when compared with event encryption which can be clearly seen from the performance results in Sect .
4-43:5 .
4-44:The advantage of attribute encryption is that the type owner is able to control access to the event type at the attribute level .
4-45:The event type owner can therefore allow clients to have different levels of access to the same event type .
4-46:Also, attribute level encryption enables content based routing in cases where an intermediate broker has access only to some of the attributes of the event, thus reducing the overall impact of event delivery on the broker network .
4-47:Therefore the choice between event and attribute encryption is a trade off between expressiveness and performance, and depends on the requirements of the distributed application .
4-48:The expressiveness provided by attribute encryption can be emulated by introducing a new event type for each group of subscribers with the same authorisation .
4-49:The publisher would then publish an instance of each of these types instead of publishing just a combined event .
4-50:For example, in our London police network, the congestion control cameras would have to publish one event for the CCS and another for the detective .
4-51:This approach could become difficult to manage if the attributes have a variety of security properties, since a large number of event types would be required and policies and subscriptions may change dynamically .
4-52:This approach creates a large number of extra events that must be routed through the network, as is shown in Sect .
4-53:5.3 .
4-54:3.3 Encrypting Subscriptions In order to fully protect the confidentiality of event content we must also encrypt subscriptions .
4-55:Encrypted subscriptions guarantee: i) that only authorised brokers are able to submit subscriptions to the broker network, and ii) that unauthorised brokers do not gain information about event content by monitoring which subscriptions a given event matches .
4-56:For example, in the first case an unauthorised broker can create subscriptions with appropriately chosen filters, route them towards the root of the event dissemination tree, and monitor which events were delivered to it as matching the subscription .
4-57:The fact that the event matched the subscription would leak information to the broker about the event content even if the event was still encrypted .
4-58:In the second case, even if an unauthorised broker was unable to create subscriptions itself, it could still look at subscriptions that were routed through it, take note of the filters on those subscriptions, and monitor which events are delivered to it by upstream brokers as matching the subscription filters .
4-59:This would again reveal information about the event content to the unauthorised broker .
4-60:In the case of encrypting complete events, we also encrypt the complete subscription filter .
4-61:The event type identifier in the subscription must be left intact to allow brokers to route events based on their topic when they are not authorised to access the filter .
4-62:In such cases the unauthorised broker is required to assume that events of such a type match all filter expressions .
4-63:Each attribute filter is encrypted individually, much as when encrypting a publication .
4-64:In addition to the event type identifier the attribute identifiers are also left intact to allow authorised brokers to decrypt those filters that they have access to, and route the event based on its matching the decrypted filters .
4-65:3.4 Avoiding Unnecessary Cryptographic Operations Encrypting the event content is not necessary if the current broker and the next broker down the event dissemination tree have the same credentials with respect to the event type at hand .
4-66:For example, one can assume that all brokers inside an organisation would share the same credentials and therefore, as long as the next broker is a member of the same domain, the event can be routed to it in plaintext .
4-67:With attribute encryption it is possible that the neighbouring broker is authorised to access a subset of the decrypted attributes, in which case those attributes that the broker is not authorised to access would be passed to it encrypted .
4-68:In order to know when it is safe to pass the event in plaintext form, the brokers exchange credentials as part of a handshake when they connect to each other .
4-69:In cases when the brokers are able to verify each others" credentials, they will add them to the routing table for future reference .
4-70:If a broker acquires new credentials after the initial handshake, it will present these new credentials to its neighbours while in session .
4-71:Regardless of its neighbouring brokers, the PHB will always encrypt the event content, because it is cheaper to encrypt the event once at the root of the event dissemination tree .
4-72:In Hermes the rendezvous node for each event type is selected uniformly randomly (the event type name is hashed with the SHA 1 hash algorithm to produce the event type 108 PHB IBIB IB SHB RN IB SHB Figure 2: Node addressing is evenly distributed across the network, thus rendezvous nodes may lie outside the domain that owns an event type IB IB SHBPHBP S Encrypts Filters from cache Decrypts, delivers Decrypts, filters Plaintext Cached Plaintext (most data) Cached Plaintext (some data) Different domains Cyphertext KEY Figure 3: Caching decrypted data to increase efficiency when delivering to peers with equivalent security privileges identifier, then the identifier is used to select the rendezvous node in the structured overlay network) .
4-73:Therefore it is probable that the rendezvous node will reside outside the current domain .
4-74:This situation is illustrated in the event dissemination tree in Fig .
4-75:2 .
4-76:So even with domain internal applications, where the event can be routed from the publisher to all subscribers in plaintext form, the event content will in most cases have to be encrypted for it to be routed to the rendezvous node .
4-77:To avoid unnecessary decryptions, we attach a plaintext content cache to encrypted events .
4-78:A broker fills the cache with content that it has decrypted, for example, in order to filter on the content .
4-79:The cache is accessed by the broker when it delivers an event to a local subscriber after first seeing if the event matches the subscription filter, but the broker also sends the cache to the next broker with the encrypted event .
4-80:The next broker can look the attribute up from the cache instead of having to decrypt it .
4-81:If the event is being sent to an unauthorised broker, the cache will be discarded before the event is sent .
4-82:Obviously sending the cache with the encrypted event will add to the communication cost, but this is outweighed by the saving in encryption decryption processing .
4-83:In Fig .
4-84:3 we see two separate cached plaintext streams accompanying an event depending on the inter broker relationships in two different domains .
4-85:We show in Sect .
4-86:5.2 that the overhead of sending encrypted messages with a full plaintext cache incurs almost no overhead compared to sending plaintext messages .
4-87:3.5 Implementation In our implementation we have used the EAX mode [2] of operation when encrypting events, attributes, and subscription filters .
4-88:EAX is a mode of operation for block ciphers, also called an Authenticated Encryption with Associated Data algorithm that provides simultaneously both data confidentiality and integrity protection .
4-89:The algorithm implements a two pass scheme where during the first pass the plain text is encrypted, and on the second pass a message authentication code is generated for the encrypted data .
4-90:The EAX mode is compatible with any block cipher .
4-91:We decided to use the Advanced Encryption Standard [9] algorithm in our implementation, because of its standard status and the fact that the algorithm has gone through thorough cryptanalysis during its existence and no serious vulnerabilities have been found thus far .
4-92:In addition to providing both confidentiality and integrity protection, the EAX mode uses the underlying block cipher in counter mode (CTR mode) [21] .
4-93:A block cipher in counter mode is used to produce a stream of key bits that are then XORed with the plaintext .
4-94:Effectively CTR mode transforms a block cipher into a stream cipher .
4-95:The advantage of stream ciphers is that the ciphertext is the same length as the plaintext, whereas with block ciphers the plaintext must be padded to a multiple of the block cipher"s block length (e.g .
4-96:the AES block size is 128 bits) .
4-97:Avoiding padding is very important in attribute encryption, because the padding might increase the size of the attribute disproportionally .
4-98:For example, a single integer might be 32 bits in length, which would be padded to 128 bits if we used a block cipher .
4-99:With event encryption the message expansion is not that relevant, since the length of padding required to reach the next 16 byte multiple will probably be a small proportion of the overall plaintext length .
4-100:In encryption mode the EAX algorithm takes as input a nonce (a number used once), an encryption key and the plaintext, and it returns the ciphertext and an authentication tag .
4-101:In decryption mode the algorithm takes as input the encryption key, the ciphertext and the authentication tag, and it returns either the plaintext, or an error if the authentication check failed .
4-102:The nonce is expanded to the block length of the underlying block cipher by passing it through an OMAC construct (see [7]) .
4-103:It is important that particular nonce values are not reused, otherwise the block cipher in CTR mode would produce an identical key stream .
4-104:In our implementation we used the PHB defined event timestamp (64 bit value counting the milliseconds since January 1, 1970 UTC) appended by the PHB"s identity (i.e .
4-105:public key) as the nonce .
4-106:The broker is responsible for ensuring that the timestamps increase monotonically .
4-107:The authentication tag is appended to the produced cipher text to create a two tuple .
4-108:With event encryption a single tag is created for the encrypted event .
4-109:With attribute 109 encryption each attribute is encrypted and authenticated separately, and they all have their individual tags .
4-110:The tag length is configurable in EAX without restrictions, which allows the user to make a trade off between the authenticity guarantees provided by EAX and the added communication overhead .
4-111:We used a tag length of 16 bytes in our implementation, but one could make the tag length a publisher subscriber defined parameter for each publication subscription or include it in the event type definition to make it a type specific parameter .
4-112:EAX also supports including unencrypted associated data in the tag calculation .
4-113:The integrity of this data is protected, but it is still readable by everyone .
4-114:This feature could be used with event encryption in cases where some of the event content is public and thus would be useful for content based routing .
4-115:The integrity of the data would still be protected against changes, but unauthorised brokers would be able to apply filters .
4-116:We have included the event type identifier as associated data in order to protect its integrity .
4-117:Other AEAD algorithms include the offset codebook mode [17] and the counter with CBC MAC mode [22] .
4-118:Contrarily to the EAX mode the OCB mode requires only one pass over the plaintext, which makes it roughly twice as fast as EAX .
4-119:Unfortunately the OCB mode has a patent application in place in the USA, which restricts its use .
4-120:The CCM mode is the predecessor of the EAX mode .
4-121:It was developed in order to provide a free alternative to OCB .
4-122:The EAX was developed later to address some issues with CCM [18] .
4-123:Similarly to EAX, CCM is also a two pass mode. .
5 KEY MANAGEMENT :
5-1:In both encryption approaches the encrypted event content has a globally unique identifier (i.e .
5-2:the event type or the attribute identifier) .
5-3:That identifier is used to determine the encryption key to use when encrypting or decrypting the content .
5-4:Each event type, in event encryption, and attribute, in attribute encryption, has its own individual encryption key .
5-5:By controlling access to the encryption key we effectively control access to the encrypted event content .
5-6:In order to control access to the encryption keys we form a key group of brokers for each individual encryption key .
5-7:The key group is used to refresh the key when necessary and to deliver the new key to all current members of the key group .
5-8:The key group manager is responsible for verifying that a new member requesting to join the key group is authorised to do so .
5-9:Therefore the key group manager must be trusted by the type owner to enforce the access control policy .
5-10:We assume that the key group manager is either a trusted third party or alternatively a member of the type owner"s domain .
5-11:In [12] Pesonen et al .
5-12:proposed a capability based access control architecture for multi domain publish subscribe systems .
5-13:The approach uses capabilities to decentralise the access control policy amongst the publish subscribe nodes (i.e .
5-14:clients and brokers): each node holds a set of capabilities that define the authority granted to that node .
5-15:Authority to access a given event type is granted by the owner of that type issuing a capability to a node .
5-16:The capability defines the event type, the action, and the attributes that Type Owner ACS Broker Key Manager 1.Grant authorisation for Number Platekey 2.Broker requests to join Number Plate key group 5.If the broker satisfies all checks,they will begin receiving appropriate keys .
5-17:3.Key manager may check broker"s credentials at the Access Control Service 4.Key manager may check that the Type Owner permits access Figure 4: The steps involved for a broker to be successful in joining a key group the node is authorised to access .
5-18:For example, a tuple <NP, subscribe, *> would authorise the owner to subscribe to Numberplate events with access to all attributes in the published events .
5-19:The sequence of events required for a broker to successfully join a key group is shown in Fig .
5-20:4 .
5-21:Both the client hosting broker and the client must be authorised to make the client"s request .
5-22:That is, if the client makes a subscription request for Numberplate events, both the client and the local broker must be authorised to subscribe to Numberplate events .
5-23:This is because from the perspective of the broker network, the local broker acts as a proxy for the client .
5-24:We use the same capabilities to authorise membership in a key group that are used to authorise publish subscribe requests .
5-25:Not doing so could lead to the inconsistent situation where a SHB is authorised to make a subscription on behalf of its clients, but is not able to decrypt incoming event content for them .
5-26:In the Numberplate example above, the local broker holding the above capability is authorised to join the Numberplate key group as well as the key groups for all the attributes in the Numberplate event type .
5-27:4.1 Secure Group Communication Event content encryption in a decentralised multi domain publish subscribe system can be seen as a sub category of secure group communication .
5-28:In both cases the key management system must scale well with the number of clients, clients might be spread over large geographic areas, there might be high rates of churn in group membership, and all members must be synchronised with each other in time in order to use the same encryption key at the same time .
5-29:There are a number of scalable key management protocols for secure group communication [15] .
5-30:We have implemented the One Way Function Tree [8] protocol as a proof of concept .
5-31:We chose to implement OFT, because of its relatively simplicity and good performance .
5-32:Our implementation uses the same structured overlay network used by the broker network as a transport .
5-33:The OFT protocol is based on a binary tree where the participants are at the leaves of the tree .
5-34:It scales in log2n in processing and communication costs, as well as in the size of the state stored at each participant, which we have verified in our simulations .
5-35:4.2 Key Refreshing Traditionally in group key management schemes the encryption key is refreshed when a new member joins the group, an 110 existing member leaves the group, or a timer expires .
5-36:Refreshing the key when a new member joins provides backward secrecy, i.e .
5-37:the new member is prevented from accessing old messages .
5-38:Similarly refreshing the key when an existing member leaves provides forward secrecy, i.e .
5-39:the old member is prevented from accessing future messages .
5-40:Timer triggered refreshes are issued periodically in order to limit the damage caused by the current key being compromised .
5-41:Even though the state of the art key management protocols are efficient, refreshing the key unnecessarily introduces extra traffic and processing amongst the key group members .
5-42:In our case key group membership is based on the broker holding a capability that authorises it to join the key group .
5-43:The capability has a set of validity conditions that in their simplest form define a time period when the certificate is valid, and in more complex cases involve on line checks back towards the issuer .
5-44:In order to avoid unnecessary key refreshes the key manager looks at the certificate validity conditions of the joining or leaving member .
5-45:In case of a joining member, if the manager can ascertain that the certificate was valid at the time of the previous key refresh, a new key refresh can be avoided .
5-46:Similarly, instead of refreshing the key immediately when a member leaves the key group, the key manager can cache their credentials and refresh the key only when the credentials expire .
5-47:These situations are both illustrated in Fig.5 .
5-48:It can be assumed that the credentials granted to brokers are relatively static, i.e .
5-49:once a domain is authorised to access an event type, the authority will be delegated to all brokers of that domain, and they will have the authority for the foreseeable future .
5-50:More fine grained and dynamic access control would be implemented at the edge of the broker network between the clients and the client hosting brokers .
5-51:When an encryption key is refreshed the new key is tagged with a timestamp .
5-52:The encryption key to use for a given event is selected based on the event"s publication timestamp .
5-53:The old keys will be kept for a reasonable amount of time in order to allow for some clock drift .
5-54:Setting this value is part of the key management protocol, although exactly how long this time should be will depend on the nature of the application and possibly the size of the network .
5-55:It can be configured independently per key group if necessary. .
6 EVALUATION :
6-1:In order to evaluate the performance of event content encryption we have implemented both encryption approaches running over our implementation of the Hermes publish subscribe middleware .
6-2:The implementation supports three modes: plaintext content, event encryption, and attribute encryption, in a single publish subscribe system .
6-3:We ran three performance tests in a discrete event simulator .
6-4:The simulator was run on an Intel P4 3.2GHz workstation with 1GB of main memory .
6-5:We decided to run the tests on an event simulator instead of an actual deployed system in order to be able to measure to aggregate time it takes to handle all messages in the system .
6-6:The following sections describe the specific test setups and the results in more detail .
6-7:5.1 End to End Overhead The end to end overhead test shows how much the overall message throughput of the simulator was affected by event content encryption .
6-8:We formed a broker network with two brokers, attached a publisher to one of them and a subscriber to the other one .
6-9:The subscriber subscribed to the advertised event type without any filters, i.e .
6-10:each publication matched the subscriber"s publication and thus was delivered to the subscriber .
6-11:The test measures the combined time it takes to publish and deliver 100,000 events .
6-12:If the content is encrypted this includes both encrypting the content at the PHB and decrypting it at the SHB .
6-13:In the test the number of attributes in the event type is increased from 1 to 25 (the x axis) .
6-14:Each attribute is set to a 30 character string .
6-15:For each number of attributes in the event type the publisher publishes 100,000 events, and the elapsed time is measured to derive the message throughput .
6-16:The test was repeated five times for each number of attributes and we use the average of all iterations in the graph, but the results were highly consistent so the standard deviation is not shown .
6-17:The same tests were run with no content encryption, event encryption, and attribute encryption .
6-18:As can be seen in Fig .
6-19:6, event content encryption introduces a large overhead compared to not using encryption .
6-20:The throughput when using attribute encryption with an event type with one attribute is 46% of the throughput achieved when events are sent in plaintext .
6-21:When the number of attributes increases the performance gap increases as well: with ten attributes the performance with attribute encryption has decreased to 11.7% of plaintext performance .
6-22:Event encryption fares better, because of fewer encryption operations .
6-23:The increase in the amount of encrypted data does not affect the performance as much as the number of individual encryption operations does .
6-24:The difference in performance with event encryption and attribute encryption with only one attribute is caused by the Java object serialisation mechanism: in the event encryption case the whole attribute structure is serialised, which results in more objects than serialising a single attribute value .
6-25:A more efficient implementation would provide its own marshalling mechanism .
6-26:Note that the EAX implementation we use runs the nonce (i.e .
6-27:initialisation vector) through an OMAC construct to increase its randomness .
6-28:Since the nonce is not required to be kept secret (just unique), there is a potential time space trade off we have not yet investigated in attaching extra nonce attributes that have already had this OMAC construct applied to them .
6-29:5.2 Domain Internal Events We explained in Sect .
6-30:3.4 that event content decryption and encryption can be avoided if both brokers are authorised to access the event content .
6-31:This test was designed to show that the use of the encrypted event content mechanism between two authorised brokers incurs only a small performance overhead .
6-32:In this test we again form a broker network with two brokers .
6-33:111 Key refresh schedule Broker 1 joining and leaving the key group Broker 2 joining and leaving the key group Actual key refresh times Time One day Broker"s key group credentials are valid Actual join time Actual leave time One day One day Figure 5: How the key refresh schedule is affected by brokers joining and leaving key groups 0 5000 10000 15000 20000 25000 30000 35000 0 5 10 15 20 25 MessagesperSecond Number of Attributes No Encryption Attribute Encryption Whole content Encryption Figure 6: Throughput of Events in a Simulator Both brokers are configured with the same credentials .
6-34:The publisher is attached to one of the brokers and the subscriber to the other, and again the subscriber does not specify any filters in its subscription .
6-35:The publisher publishes 100,000 events and the test measures the elapsed time in order to derive the system"s message throughput .
6-36:The event content is encrypted outside the timing measurement, i.e .
6-37:the encryption cost is not included in the measurements .
6-38:The goal is to model an environment where a broker has received a message from another authorised broker, and it routes the event to a third authorised broker .
6-39:In this scenario the middle broker does not need to decrypt nor encrypt the event content .
6-40:As shown in Fig .
6-41:2, the elapsed time was measured as the number of attributes in the published event was increased from 1 to 25 .
6-42:The attribute values in each case are 30 character strings .
6-43:Each test is repeated five times, and we use the average of all iterations in the graph .
6-44:The same test was then repeated with no encryption, event encryption and attribute encryption turned on .
6-45:The encrypted modes follow each other very closely .
6-46:Predictably, the plaintext mode performs a little better for all attribute counts .
6-47:The difference can be explained partially by the encrypted events being larger in size, because they include both the plaintext and the encrypted content in this test .
6-48:The difference in performance is 3.7% with one attribute and 2.5% with 25 attributes .
6-49:We believe that the roughness of the graphs can be explained by the Java garbage collector interfering with the simulation .
6-50:The fact that all three graphs show the same irregularities supports this theory .
6-51:112 50000 55000 60000 65000 70000 75000 80000 85000 90000 95000 100000 0 5 10 15 20 25 MessagesperSecond Number of Attributes No Encryption Attribute Encryption Whole content Encryption Figure 7: Throughput of Domain Internal Events 5.3 Communication Overhead Through the definition of multiple event types, it is possible to emulate the expressiveness of attribute encryption using only event content encryption .
6-52:The last test we ran was to show the communication overhead caused by this emulation technique, compared to using real attribute encryption .
6-53:In the test we form a broker network of 2000 brokers .
6-54:We attach one publisher to one of the brokers, and an increasing number of subscribers to the remaining brokers .
6-55:Each subscriber simulates a group of subscribers that all have the same access rights to the published event .
6-56:Each subscriber group has its own event type in the test .
6-57:The outcome of this test is shown in Fig .
6-58:8 .
6-59:The number of subscriber groups is increased from 1 to 50 (the x axis) .
6-60:For each n subscriber groups the publisher publishes one event to represent the use of attribute encryption and n events representing the events for each subscriber group .
6-61:We count the number of hops each publication makes through the broker network (y axis) .
6-62:Note that Fig .
6-63:8 shows workloads beyond what we would expect in common usage, in which many event types are likely to contain fewer than ten attributes .
6-64:The subscriber groups used in this test represent disjoint permission sets over such event attributes .
6-65:The number of these sets can be determined from the particular access control policy in use, but will be a value less than or equal to the factorial of the number of attributes in a given event type .
6-66:The graphs indicate that attribute encryption performs better than event encryption even for small numbers of subscriber groups .
6-67:Indeed, with only two subscriber groups (e.g .
6-68:the case with Numberplate events) the hop count increases from 7.2 hops for attribute encryption to 16.6 hops for event encryption .
6-69:With 10 subscriber groups the corresponding numbers are 24.2 and 251.0, i.e .
6-70:an order of magnitude difference. .
7 RELATED WORK :
7-1:Wang et al .
7-2:have categorised the various security issues that need to be addressed in publish subscribe systems in the future in [20] .
7-3:The paper is a comprehensive overview of security issues in publish subscribe systems and as such tries to draw attention to the issues rather than providing solutions .
7-4:Bacon et al .
7-5:in [1] examine the use of role based access control in multi domain, distributed publish subscribe systems .
7-6:Their work is complementary to this paper: distributed RBAC is one potential policy formalism that might use the enforcement mechanisms we have presented .
7-7:Opyrchal and Prakash address the problem of event confidentiality at the last link between the subscriber and the SHB in [10] .
7-8:They correctly state that a secure group communication approach is infeasible in an environment like publish subscribe that has highly dynamic group memberships .
7-9:As a solution they propose a scheme utilising key caching and subscriber grouping in order to minimise the number of required encryptions when delivering a publication from a SHB to a set of matching subscribers .
7-10:We assume in our work that the SHB is powerful enough to man113 1 10 100 1000 10000 0 5 10 15 20 25 30 35 40 45 50 NumberofHopsinTotal Number of Subscription Groups Attribute Encryption Whole content Encryption Figure 8: Hop Counts When Emulating Attribute Encryption age a TLS secured connection for each local subscriber .
7-11:Both Srivatsa et al .
7-12:[19] and Raiciu et al .
7-13:[16] present mechanisms for protecting the confidentiality of messages in decentralised publish subscribe infrastructures .
7-14:Compared to our work both papers aim to provide the means for protecting the integrity and confidentiality of messages whereas the goal for our work is to enforce access control inside the broker network .
7-15:Raiciu et al .
7-16:assume in their work that none of the brokers in the network are trusted and therefore all events are encrypted from publisher to subscriber and that all matching is based on encrypted events .
7-17:In contrast, we assume that some of the brokers on the path of a publication are trusted to access that publication and are therefore able to implement event matching .
7-18:We also assume that the publisher and subscriber hosting brokers are always trusted to access the publication .
7-19:The contributions of Srivatsa et al .
7-20:and Raiciu et al .
7-21:are complementary to the contributions in this paper .
7-22:Finally, Fiege et al .
7-23:address the related topic of event visibility in [6] .
7-24:While the work concentrated on using scopes as mechanism for structuring large scale event based systems, the notion of event visibility does resonate with access control to some extent. .
8-1:Event content encryption can be used to enforce an access control policy while events are in transit in the broker network of a multi domain publish subscribe system
8-2:Encryption causes an overhead, but i) there may be no alternative when access control is required, and ii) the performance penalty can be lessened with implementation optimisations, such as passing cached plaintext content alongside encrypted content between brokers with identical security credentials
8-3:This is particularly appropriate if broker to broker connections are secured by default so that wire sniffing is not an issue
8-4:Attribute level encryption can be implemented in order to enforce fine grained access control policies
8-5:In addition to providing attribute level access control, attribute encryption enables partially authorised brokers to implement contentbased routing based on the attributes that are accessible to them
8-6:Our experiments show that i) by caching plaintext and ciphertext content when possible, we are able to deliver comparable performance to plaintext events, and ii) that attribute encryption within an event incurs far less overhead than defining separate event types for the attributes that need different levels of protection
8-7:In environments comprising multiple domains, where eventbrokers have different security credentials, we have quantified how a trade off can be made between performance and expressiveness
8-8:Acknowledgements We would like to thank the anonymous reviewers for their very helpful comments
8-9:Lauri Pesonen is supported by EPSRC (GR T28164) and the Nokia Foundation
8-10:David Eyers is supported by EPSRC (GR S94919)
8-11:114
9-1:J
9-2:Bacon, D
9-3:M
9-4:Eyers, K
9-5:Moody, and L
9-6:I
9-7:W
9-8:Pesonen
9-9:Securing publish subscribe for multi domain systems
9-10:In G
9-11:Alonso, editor, Middleware, volume 3790 of Lecture Notes in Computer Science, pages 1 20
9-12:Springer, 2005
9-13:M
9-14:Bellare, P
9-15:Rogaway, and D
9-16:Wagner
9-17:Eax: A conventional authenticated encryption mode
9-18:Cryptology ePrint Archive, Report 2003 069, 2003
9-19:http:  eprint.iacr.org
9-20:A
9-21:Carzaniga, D
9-22:S
9-23:Rosenblum, and A
9-24:L
9-25:Wolf
9-26:Design and evaluation of a wide area event notification service
9-27:ACM Transactions on Computer Systems, 19(3):332 383, Aug
9-28:2001
9-29:M
9-30:Castro, P
9-31:Druschel, A
9-32:Kermarrec, and
picture:
