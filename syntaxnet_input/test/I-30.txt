Distributed Task Allocation in Social Networks 
content:
1 ABSTRACT :
1-1:This paper proposes a new variant of the task allocation problem, where the agents are connected in a social network and tasks arrive at the agents distributed over the network .
1-2:We show that the complexity of this problem remains NPhard .
1-3:Moreover, it is not approximable within some factor .
1-4:We develop an algorithm based on the contract net protocol .
1-5:Our algorithm is completely distributed, and it assumes that agents have only local knowledge about tasks and resources .
1-6:We conduct a set of experiments to evaluate the performance and scalability of the proposed algorithm in terms of solution quality and computation time .
1-7:Three different types of networks, namely small world, random and scale free networks, are used to represent various social relationships among agents in realistic applications .
1-8:The results demonstrate that our algorithm works well and that it scales well to large scale applications .
1-9:I.2.11 [Distributed Artificial Intelligence]: Multiagent .
2 INTRODUCTION :
2-1:Recent years have seen a lot of work on task and resource allocation methods, which can potentially be applied to many real world applications .
2-2:However, some interesting applications where relations between agents play a role require a slightly more general model .
2-3:Such situations appear very frequently in real world scenarios, and recent technological developments are bringing more of them within the range of task allocation methods .
2-4:Especially in business applications, preferential partner selection and interaction is very common, and this aspect becomes more important for task allocation research, to the extent that technological developments need to be able to support it .
2-5:For example, the development of semantic web and grid technologies leads to increased and renewed attention for the potential of the web to support business processes [7, 15] .
2-6:As an example, virtual organizations (VOs) are being re invented in the context of the grid, where they are composed of a number of autonomous entities (representing different individuals, departments and organizations), each of which has a range of problem solving capabilities and resources at its disposal [15, p .
2-7:237] .
2-8:The question is how VOs are to be dynamically composed and re composed from individual agents, when different tasks and subtasks need to be performed .
2-9:This would be done by allocating them to different agents who may each be capable of performing different subsets of those tasks .
2-10:Similarly, supply chain formation is concerned with the, possibly ad hoc, allocation of services to providers in the supply chain, in such a way that overall profit is optimized [6, 21] .
2-11:Traditionally, such allocation decisions have been analyzed using transaction cost economics [4], which takes the transaction between consecutive stages of development as its basic unit of analysis, and considers the firm and the market as alternative structural forms for organizing transactions .
2-12:(Transaction cost) economics has traditionally built on analysis of comparative statics: the central problem of economic organization is considered to be the adaptation of organizational forms to the characteristics of transactions .
2-13:More recently, TCE"s founding father, Ronald Coase, acknowledged that this is too simplistic an approach [5, p .
2-14:245]: The analysis cannot be confined to what happens within a single firm .
2-15:( .
2-16:.
2-17:.
2-18:) What we are dealing with is a complex interrelated structure .
2-19:In this paper, we study the problem of task allocation from the perspective of such a complex interrelated structure .
2-20:In particular, ‘the market" cannot be considered as an organizational form without considering specific partners to interact with on the market [11] .
2-21:Specifically, therefore, we consider agents to be connected to each other in a social network .
2-22:Furthermore, this network is not fully connected: as informed by the business literature, firms typically have established working relations with limited numbers of preferred partners [10]; these are the ones they consider when new tasks arrive and they have to form supply chains to allocate those tasks [19] .
2-23:Other than modeling the interrelated 500 978 81 904262 7 5 c 2007 IFAAMAS structure between business partners, the social network introduced in this paper can also be used to represent other types of connections or constraints among autonomous entities that arise from other application domains .
2-24:The next section gives a formal description of the task allocation problem on social networks .
2-25:In Section 3, we prove that the complexity of this problem remains NP hard .
2-26:We then proceed to develop a distributed algorithm in Section 4, and perform a series of experiments with this algorithm, as described in Section 5 .
2-27:Section 6 discusses related work, and Section 7 concludes. .
3 PROBLEM DESCRIPTION :
3-1:We formulate the social task allocation problem in this section .
3-2:There is a set A of agents: A = {a1, .
3-3:.
3-4:.
3-5:, am} .
3-6:Agents need resources to complete tasks .
3-7:Let R = {r1, .
3-8:.
3-9:.
3-10:, rk} denote the collection of the resource types available to the agents A .
3-11:Each agent a ∈ A controls a fixed amount of resources for each resource type in R, which is defined by a resource function: rsc : A × R → N .
3-12:Moreover, we assume agents are connected by a social network .
3-13:Definition 1 (Social network) .
3-14:An agent social network SN = (A, AE) is an undirected graph, where vertices A are agents, and each edge (ai, aj) ∈ AE indicates the existence of a social connection between agents ai and aj .
3-15:Suppose a set of tasks T = {t1, t2, .
3-16:.
3-17:.
3-18:, tn} arrives at such an agent social network .
3-19:Each task t ∈ T is then defined by a tuple u(t), rsc(t), loc(t) , where u(t) is the utility gained if task t is accomplished, and the resource function rsc : T ×R → N specifies the amount of resources required for the accomplishment of task t .
3-20:Furthermore, a location function loc : T → A defines the locations (i.e., agents) at which the tasks arrive in the social network .
3-21:An agent a that is the location of a task t, i.e .
3-22:loc(t) = a, is called the manager of this task .
3-23:Each task t ∈ T needs some specific resources from the agents in order to complete the task .
3-24:The exact assignment of tasks to agents is defined by a task allocation .
3-25:Definition 2 (Task allocation) .
3-26:Given a set of tasks T = {t1, .
3-27:.
3-28:.
3-29:, tn} and a set of agents A = {a1, .
3-30:.
3-31:.
3-32:, am} in a social network SN, a task allocation is a mapping φ : T × A × R → N .
3-33:A valid task allocation in SN must satisfy the following constrains: • A task allocation must be correct .
3-34:Each agent a ∈ A cannot use more than its available resources, i.e .
3-35:for each r ∈ R, P t∈T φ(t, a, r) ≤ rsc(a, r) .
3-36:• A task allocation must be complete .
3-37:For each task t ∈ T , either all allocated agents" resources are sufficient, i.e .
3-38:for each r ∈ R, P a∈A φ(t, a, r) ≥ rsc(t, r), or t is not allocated, i.e .
3-39:φ(t, ·, ·) = 0 .
3-40:• A task allocation must obey the social relationships .
3-41:Each task t ∈ T can only be allocated to agents that are (direct) neighbors of agent loc(t) in the social network SN .
3-42:Each such agent that can contribute to a task is called a contractor .
3-43:We write Tφ to represent the tasks that are fully allocated in φ .
3-44:The utility of φ is then the summation of the utilities of each task in Tφ, i.e., Uφ = P t∈Tφ u(t) .
3-45:Using this notation, we define the efficient task allocation below .
3-46:Definition 3 (Efficient task allocation) .
3-47:We say a task allocation φ is efficient if it is valid and Uφ is maximized, i.e., Uφ = max( P t∈Tφ u(t)) .
3-48:We are now ready to define the task allocation problem in social network that we study in this paper .
3-49:Definition 4 (Social task allocation problem) .
3-50:Given a set of agents A connected by a social network SN = (A, AE), and a finite set of tasks T , the social task allocation problem (or STAP for short) is the problem of finding the efficient task allocation φ, such that φ is valid and the social welfare Uφ is maximized. .
4 COMPLEXITY RESULTS :
4-1:The traditional task allocation problem, TAP (without the condition of the social network SN), is NP complete [18], and the complexity comes from the fact that we need to evaluate the exponential number of subsets of the task set .
4-2:Although we may consider the TAP as a special case of the STAP by assuming agents are fully connected, we cannot directly use the complexity results from the TAP, since we study the STAP in an arbitrary social network, which, as we argued in the introduction, should be partially connected .
4-3:We now show that the TAP with an arbitrary social network is also NP complete, even when the utility of each task is 1, and the quantity of all required and available resources is 1 .
4-4:Theorem 1 .
4-5:Given the social task allocation problem with an arbitrary social network, as defined in Definition 4, the problem of deciding whether a task allocation φ with utility more than k exists is NP complete .
4-6:Proof .
4-7:We first show that the problem is in NP .
4-8:Given an instance of the problem and an integer k, we can verify in polynomial time whether an allocation φ is a valid allocation and whether the utility of φ is greater than k .
4-9:We now prove that the STAP is NP hard by showing that MAXIMUM INDEPENDENT SET ≤P STAP .
4-10:Given an undirected graph G = (V, E) and an integer k, we construct a network G = (V , E ) which has an efficient task allocation with k tasks of utility 1 allocated if and only if G has an independent set of size k .
4-11:av1 av3 ae3 rsc(ae1 ) = {e1} rsc(ae4 ) = {e4} av4 ae2 av2 ae4 ae1 rsc(ae2 ) = {e2}{e3} rsc(av3 ) = {v3} rsc(av4 ) = {v4} t1 = {v1, e1, e3} t2 = {v2, e1, e2} rsc(ae3 ) = rsc(av1 ) = {v1} rsc(av2 ) = {v2} t3 = {v3, e3, e4} t4 = {v4, e2, e4} e1 e2 e4 e3 v1 v2 v4v3 Figure 1: The MIS problem can be reduced to the STAP .
4-12:The left figure is an undirected graph G, which has the optimal solution {v1, v4} or {v2, v3}; the right figure is the constructed instance of the STAP, where the optimal allocation is {t1, t4} or {t2, t3} .
4-13:An instance of the following construction is shown in Figure 1 .
4-14:For each node v ∈ V and each edge e ∈ E in the graph G, we create a vertex agent av and an edge agent ae in G .
4-15:The Sixth Intl .
4-16:Joint Conf .
4-17:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 501 When v was incident to e in G we correspondingly add an edge e in G between av and ae .
4-18:We assign each agent in G one resource, which is related to the node or the edge in the graph G, i.e., for each v ∈ V , rsc(av) = {v} (here we write rsc(a) and rsc(t) to represent the set of resources available to required by a and t), and for each e ∈ E, rsc(ae) = {e} .
4-19:Each vertex agent avi in G has a task ti that requires a set of neighboring resources ti = {vi} ∪ {e|e = (u, vi) ∈ E} .
4-20:There is no task on the edge agents in G .
4-21:We define utility 1 for each task, and the quantity of all required and available resources to be 1 .
4-22:Taken an instance of the IS problem, suppose there is a solution of size k, i.e., a subset N ⊆ V such that no two vertices in N are joined by an edge in E and |N| = k .
4-23:N specifies a set of vertex agents AN in the corresponding graph G .
4-24:Given two agents a1, a2 ∈ AN we now know that there is no edge agent ae connected to both a1 and a2 .
4-25:Thus, for each agent a ∈ AN , a assigns its task to the edge agents which are connected to a .
4-26:All other vertex agents a ∈ AN are not able to assign their tasks, since the required resources of the edge agents are already used by the agents a ∈ AN .
4-27:The set of tasks of the agents AN (|AN | = k) is thus the maximum set of tasks that can be allocated .
4-28:The utility of this allocation is k .
4-29:Similarly, if there is a solution for the STAP with the utility value k, and the allocated task set is N, then for the IS problem, there exists a maximum independent set N of size k in G .
4-30:An example can be found in Figure 1 .
4-31:We just proved that the STAP is NP hard for an arbitrary graph .
4-32:In our proof, the complexity comes from the introduction of a social network .
4-33:One may expect that the complexity of this problem can be reduced for some networks where the number of neighbors of the agents is bounded by a fixed constant .
4-34:We now give a complexity result on this class of networks as follows .
4-35:Theorem 2 .
4-36:Let the number of neighbors of each agent in the social network SN be bounded by Δ for Δ ≥ 3 .
4-37:Computing the efficient task allocation given such a network is NP complete .
4-38:In addition, it is not approximable within Δε for some ε > 0 .
4-39:Proof .
4-40:It has been shown in [2] that the maximum independent set problem in the case of the degree bounded by Δ for Δ ≥ 3 is NP complete and is not approximable within Δε for some ε > 0 .
4-41:Using the similar reduction from the proof of Theorem 1, this result also holds for the STAP .
4-42:Since our problem is as hard as MIS as shown in Theorem 1, it is not possible to give a worst case bound better than Δε for any polynomial time algorithm, unless P = NP. .
5 ALGORITHMS :
5-1:To deal with the problem of allocating tasks in a social network, we present a distributed algorithm .
5-2:We introduce this algorithm by describing the protocol for the agents .
5-3:After that we give the optimal, centralized algorithm and an upper bound algorithm, which we use in Section 5 to benchmark the quality of our distributed algorithm .
5-4:4.1 Protocol for distributed task allocation We can summarize the description of the task allocation problem in social networks from Section 2 as follows .
5-5:We Algorithm 1 Greedy distributed allocation protocol .
5-6:Each manager a calculates the efficiency e(t) for each of their tasks t ∈ Ta, and then while Ta = ∅: such that for each task t ∈ Ta: e(t ) ≤ e(t) .
5-7:neighbors (of a) by informing these neighbors of the efficiency e(t) and the required resources for t .
5-8:offer all relevant resources to the manager for the task with the highest efficiency .
5-9:allocate their tasks, and inform each contractor which part of the offer is accepted .
5-10:When a task is allocated, or when a manager has received offers from all neighbors, but still cannot satisfy its task, the task is removed from the task list Ta .
5-11:have a (social) network of agents .
5-12:Each agent has a set of resources of different types at its disposal .
5-13:We also have a set of tasks .
5-14:Each task requires some resources, has a fixed benefit, and is located at a certain agent .
5-15:This agent is called a manager .
5-16:We only allow neighboring agents to help with a task .
5-17:These agents are called contractors .
5-18:Agents can fulfill the role of manager as well as contractor .
5-19:The problem is to find out which tasks to execute, and which resources of which contractors to use for these tasks .
5-20:The idea of the protocol is as follows .
5-21:All manager agents a ∈ A try to find neighboring contractors to help them with their task(s) Ta = {ti ∈ T | loc(ti) = a} .
5-22:They start with offering the task that is most efficient in terms of the ratio between benefit and required resources .
5-23:Out of all tasks offered, contractors select the task with the highest efficiency, and send a bid to the related manager .
5-24:A bid consists of all the resources the agent is able to supply for this task .
5-25:If sufficient resources have been offered, the manager selects the required resources and informs all contractors of its choice .
5-26:The efficiency of a task is defined as follows: Definition 5 .
5-27:The efficiency e of a task t ∈ T is defined by the utility of this task divided by the sum of all required resources: e(t) = u(t)P r∈R rsc(t,r) .
5-28:A more detailed description of this protocol can be found in Algorithm 1 .
5-29:Here it is also defined how to determine when a task should not be offered anymore, because it is impossible to fulfill locally .
5-30:Obviously, a task is also not offered anymore when it has been allocated .
5-31:This protocol is such that, when no two tasks have exactly the same efficiency, in every iteration at least one task is removed from a task list.1 From this the computation and communication property of the algorithm follows .
5-32:Proposition 1 .
5-33:For a STAP with n tasks and m agents, the run time of the distributed algorithm is O(nm), and the number of communication messages is O(n2 m) .
5-34:1 Even when some tasks have the same efficiency, it is straightforward to make this result work .
5-35:For example, the implementation can ensure that the contractors choose the task with the lowest task id .
5-36:502 The Sixth Intl .
5-37:Joint Conf .
5-38:on Autonomous Agents and Multi Agent Systems (AAMAS 07) Algorithm 2 Optimal social task allocation .
5-39:Repeat the following for each combination of tasks: any previous combination, test if this combination is feasible as follows: r ∈ R (separately) as follows: (a) Create a source s and a sink s .
5-40:(b) For each agent a ∈ A create an agent node and an edge from s to this node with capacity equal to the amount of resources of type r agent a has .
5-41:(c) For each task t ∈ T create a task node and an edge from this node to s with capacity equal to the amount of resources of type r task T requires .
5-42:(d) For each agent a connect the agent node to all task nodes of neighboring tasks, i.e., t ∈ {t ∈ T | (a, loc(t)) ∈ AE} .
5-43:Give this connection unlimited capacity .
5-44:networks .
5-45:If the maximum flow in each network is equal to the total required resources of that type, the current combination of tasks is feasible .
5-46:In that case, this is the current best combination of tasks .
5-47:Proof .
5-48:In the worst case, in each iteration exactly one task is removed from a task list, so there are n iterations .
5-49:In each iteration in the worst case (i.e., a fully connected network), for each of the O(n) managers, O(m) messages are sent .
5-50:Next the task with the highest efficiency can be selected by each contractor in O(n) .
5-51:Assigning an allocation can be done in O(m) .
5-52:This leads to a total of O(n + m) operations for each iteration, and thus O(n2 + nm) operations in total .
5-53:The number of messages sent is O(n(nm + nm + nm)) = O(n2 m) .
5-54:We establish the quality of this protocol experimentally (in Section 5) .
5-55:Preferably, we compare the results to the optimal solution .
5-56:4.2 Optimal social task allocation The optimal task allocation algorithm should deal with the restrictions posed by the social network .
5-57:For this NPcomplete problem we used an exponential brute force algorithm to consider relevant combinations of tasks to execute .
5-58:For each combination we use a maximum flow algorithm to check whether the resources are sufficient for the selected subset of tasks .
5-59:The flow network describes which resources can be used for which tasks, depending on the social network .
5-60:If the maximum flow is equal to the sum of all resources required by the subset of tasks, we know that a feasible solution exists (see Algorithm 2) .
5-61:Clearly, we cannot expect this optimal algorithm to be able to find solutions for larger problem sizes .
5-62:To establish the quality of our protocol for large instances, we use the following method to determine an upper bound .
5-63:4.3 Upper bound for social task allocation Given a social task allocation problem, if the number of resource types for every task t ∈ T is bounded by 1, the Algorithm 3 An upper bound for social task allocation .
5-64:Create a network flow problem with costs as follows: .
6 Create a source s and a sink s . :
6-1:create an agent resource node ai, and an edge from s to this node with capacity equal to the amount of resources of type r agent a has available and with costs 0 .
6-2:create a task resource node ti, and an edge from this node to s with capacity equal to the amount of resources of type r task t requires and costs −e(t) .
6-3:connect the agent resource node ai to all task resource nodes ti for neighboring tasks t ∈ {t ∈ T | (a, loc(t)) ∈ AE or a = loc(t)} .
6-4:Give this connection unlimited capacity and zero costs .
6-5:capacity and zero costs .
6-6:Solve the minimum cost flow network problem for this network .
6-7:The costs of the resulting network is an upper bound for the social task allocation problem .
6-8:problem is polynomially solvable by transforming it to a flow network problem .
6-9:Our method for efficiently calculating an upper bound for STAP makes use of this special case by converting any given STAP instance P into a new problem P where each task only has one resource type .
6-10:More specifically, for every task t ∈ T with utility u(t), we do the following .
6-11:Let m be the number of resource types {r1, .
6-12:.
6-13:.
6-14:, rm} required by t .
6-15:We then split t into a set of m tasks T = {t1, .
6-16:.
6-17:.
6-18:, tm} where each task ti only has one unique resource type (of {r1, .
6-19:.
6-20:.
6-21:, rm}) and each task has a fair share of the utility, i.e., the efficiency of t from Definition 5 times the amount of this resource type rsc(ti, ri) .
6-22:After polynomially performing this conversion for every task in T , the original problem P becomes the special case P .
6-23:Note that the set of valid allocations in P is only a subset of the set of valid allocations in P , because it is now possible to partially allocate a task .
6-24:From this it is easy to see that the solution of P gives an upper bound of the solution of the original problem P .
6-25:To compute the optimal solution for P , we transform it to a minimum cost flow problem .
6-26:We model the cost in the flow network by the negation of the new task"s utility .
6-27:A polynomial time implementation of a scaling minimum cost flow algorithm [9] is used for the computation .
6-28:The resulting minimum cost flow represents a maximum allocation of the tasks for P .
6-29:The detailed modeling is described in Algorithm 3 .
6-30:In the next section, we use this upper bound to estimate the quality of the GDAP for large scale instances. .
7 EXPERIMENTS :
7-1:We implemented the greedy distributed allocation protocol (GDAP), the optimal allocation algorithm (OPT), and the upper bound algorithm in Java, and tested them on a Linux PC .
7-2:The purpose of these experiments is to study the performance of the distributed algorithm in different problem settings using different social networks .
7-3:The perThe Sixth Intl .
7-4:Joint Conf .
7-5:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 503 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 0.4 0.6 0.8 1 1.2 1.4 1.6 Rewardrelativetooptimal Resource ratio small world upper bound random upper bound scale free upper bound small world GDAP random GDAP scale free GDAP Figure 2: The solution qualities of the GDAP and the upper bound depend on the resource ratio .
7-6:0 5 10 15 20 25 30 0 2 4 6 8 10 12 14 16 18 Numberofagents Degree small world random scale free Figure 3: The histogram of the degrees .
7-7:formance measurements are the solution quality and computation time, where the solution quality is computed as follows .
7-8:When the number of tasks is small, we compare the output of the distributed algorithm with the optimal solution, i.e., SQ = GDAP OP T , but if it is not feasible to compute the optimal solution, we use the value returned by the upper bound algorithm for evaluation, i.e., SQ = GDAP UB .
7-9:To see whether the latter is a good measure, we also compare the quality of the upper bound to the optimal solution for smaller problems .
7-10:In the following, we describe the setup of all experiments, and present the results .
7-11:5.1 Experimental settings We consider several experimental environments .
7-12:In all environments the agents are connected by a social network .
7-13:In the experiments, three different networks are used to simulate the social relationships among agents in potential realworld problems .
7-14:Small world networks are networks where most neighbors of an agent are also connected to each other .
7-15:For the experiments we use a method for generating random small world networks proposed by Watts et al .
7-16:[22], with a fixed rewiring probability p = 0.05 .
7-17:Scale free networks have the property that a couple of nodes have many connections, and many nodes have only a small number of connections .
7-18:To generate these we use the implementation in the JUNG library of the generator proposed by Barab´asi and Albert [3] .
7-19:We also generate random networks as follows .
7-20:First we connect each agent to another agent such that all agents are connected .
7-21:Next, we randomly add connections until the desired average degree has been reached .
7-22:We now describe the different settings used in our experiments with both small and large scale problems .
7-23:Setting 1 .
7-24:The number of agents is 40, and the number of tasks is 20 .
7-25:The number of different resource types is bounded by 5, and the average number of resources required by a task is 30 .
7-26:Consequently, the total number of resources required by the tasks is fixed .
7-27:However, the resources available to the agents are varied .
7-28:We define the resource ratio to refer to the ratio between the total number of available resources and the total number of required resources .
7-29:Resources are allocated uniformly to the agents .
7-30:The average degrees of the networks may also change .
7-31:In this setting the task benefits are distributed normally around the number of resources required .
7-32:Setting 2 .
7-33:This setting is similar to Setting 1, but here we let the benefits of the tasks vary dramatically 40% of the tasks have around 10 times higher benefit than the other 60% of the tasks .
7-34:Setting 3 .
7-35:This setting is for large scale problems .
7-36:The ratio between the number of agents and the number of tasks is set to 5 3, and the number of agents varies from 100 to 2000 .
7-37:We also fix the resource ratio to 1.2 and the average degree to 6 .
7-38:The number of different resource types is 20, and the average resource requirement of a tasks is 100 .
7-39:The task benefits are again normally distributed .
7-40:5.2 Experimental results The experiments are done with the three different settings in the three different networks mentioned before, where each recorded data is the average over 20 random instances .
7-41:5.2.1 Experiment 1 Experimental setting 1 is used for this set of experiments .
7-42:We would like to see how the GDAP behaves in the different networks when the number of resources available to the agents is changing .
7-43:We also study the behavior of our upper bound algorithm .
7-44:For this experiment we fix the average number of neighbors (degree) in each network type to six .
7-45:In Figure 2 we see how the quality of both the upper bound and the GDAP algorithm depends on the resource ratio .
7-46:Remarkably, for lower resource ratios our GDAP is much closer to the optimal allocation than the upper bound .
7-47:When the resource ratio grows above 1.5, the graphs of the upper bound and the GDAP converge, meaning that both are really close to the optimal solution .
7-48:This can be explained by the fact that when plenty of resources are available, all tasks can be allocated without any conflicts .
7-49:However, when resources are very scarce, the upper bound is much too optimistic, because it is based on the allocation of sub tasks per resource type, and does not reason about how many of the tasks can actually be allocated completely .
7-50:We also notice from the graph that the solution quality of the GDAP on all three networks is quite high (over 0.8) when the available resource is very limited (0.3) .
7-51:It drops below 0.8 with the increased ratio and goes up again once there are plenty of resources available (resource ratio 0.9) .
7-52:Clearly, if 504 The Sixth Intl .
7-53:Joint Conf .
7-54:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 2 4 6 8 10 12 14 16 Rewardrelativetooptimal Degree small world upper bound random upper bound scale free upper bound small world GDAP random GDAP scale free GDAP Figure 4: The quality of the GDAP and the upper bound depend on the network degree .
7-55:resources are really scarce, only a few tasks can be successfully allocated even by the optimal algorithm .
7-56:Therefore, the GDAP is able to give quite a good allocation .
7-57:Although the differences are minor, it can also be seen that the results for the small world network are consistently slightly better than those of random networks, which in turn outperform scale free networks .
7-58:This can be understood by looking at the distribution of the agents" degree, as shown in Figure 3 .
7-59:In this experiment, in the small world network almost every manager has a degree of six .
7-60:In random networks, the degree varies between one and about ten .
7-61:However, in the scale free network, most nodes have only three or four connections, and only a very few have up to twenty connections .
7-62:As we will see in the next experiment, having more connections means getting better results .
7-63:For the next experiment we fix the resource ratio to 1.0 and study the quality of both the upper bound and the GDAP algorithm related to the degree of the social network .
7-64:The result can be found in Figure 4 .
7-65:In this figure we can see that a high average degree also leads to convergence of the upper bound and the GDAP .
7-66:Obviously, when managers have many connections, it becomes easier to allocate tasks .
7-67:An exception is, similar to what we have seen in Figure 2, that the solution of the GDAP is also very good if the connections are extremely limited (degree 2), due to the fact that the number of possibly allocated tasks is very small .
7-68:Again we see that the upper bound is not that good for problems where resources are hard to reach, i.e .
7-69:in social networks with a low average degree.2 Since the solution quality clearly depends on the resource ratio as well as on the degree of the social network, we study the effect of changing both, to see whether they influence each other .
7-70:Figure 5 shows how the solution quality depends on both the resource ratio and the network degree .
7-71:This graph confirms the results that the GDAP performs better for problems with higher degree and higher resource ratio .
7-72:However, it is now also more clear that it performs better for very low degree and resource availability .
7-73:For this experiment with 40 agents and 20 tasks, the worst performance is met for instances with degree six and resource ratio 0.6 to instances with degree twelve and resource ratio 0.3 .
7-74:But even for those instances, the performance lies above 0.7 .
7-75:2 The consistent standard deviation of about 15% over the 20 problem instances is not displayed as error bars in these first graphs, because it would obfuscate the interesting correlations that can now be seen .
7-76:4 6 8 10 12 14 16 0.4 0.6 0.8 1 1.2 1.4 1.6 0.7 0.75 0.8 0.85 0.9 0.95 1 Relative reward small world Average degree Resource ratio Relative reward Figure 5: The quality of the GDAP depends on both the resource ratio and the network degree .
7-77:5.2.2 Experiment 2 To study the robustness of the GDAP against different problem settings, we generate instances where the task benefit distribution is different: 40% of the tasks gets a 10 times higher benefit (as described in Setting 2) .
7-78:The effect of this different distribution can be seen in Figure 6 .
7-79:These two graphs show that the results for the skewed task benefit distribution are slightly better on average, both when varying the resource ratio, and when varying the average degree of the network .
7-80:We argue that this can be explained by the greedy nature of GDAP, which causes the tasks with high efficiency to be allocated first, and makes the algorithm perform better in this heterogeneous setting .
7-81:5.2.3 Experiment 3 The purpose of this final experiment is to test whether the algorithm can be scaled to large problems, like applications running on the internet .
7-82:We therefore generate instances where the number of agents varies from 100 to 2000, and simultaneously increase the number of tasks from 166 to 3333 (Setting 3) .
7-83:Figure 7 shows the run time for these instances on a Linux machine with an AMD Opteron 2.4 GHz processor .
7-84:These graphs confirm the theoretical analysis from the previous section, saying that both the upper bound and the GDAP are polynomial .
7-85:In fact, the graphs show that the GDAP almost behaves linearly .
7-86:Here we see that the locality of the GDAP really helps in reducing the computation time .
7-87:Also note that the GDAP requires even less computation time than the upper bound .
7-88:The quality of the GDAP for these large instances cannot be compared to the optimal solution .
7-89:Therefore, in Figure 8 the upper bound is used instead .
7-90:This result shows that the GDAP behaves stably and consistently well with the increasing problem size .
7-91:It also shows once more that the GDAP performs better in a small world network. .
8 RELATED WORK :
8-1:Task allocation in multiagent systems has been investigated by many researchers in recent years with different assumptions and emphases .
8-2:However, most of the research to date on task allocation does not consider social connections among agents, and studies the problem in a centralized The Sixth Intl .
8-3:Joint Conf .
8-4:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 505 0.65 0.7 0.75 0.8 0.85 0.9 0.95 1 0.4 0.6 0.8 1 1.2 1.4 1.6 Rewardrelativetooptimal Resource ratio skewed small world skewed random skewed scale free uniform small world uniform random uniform scale free 0.7 0.75 0.8 0.85 0.9 0.95 1 2 4 6 8 10 12 14 16 Rewardrelativetooptimal Degree skewed small world skewed random skewed scale free uniform small world uniform random uniform scale free Figure 6: The quality of the GDAP algorithm for a uniform and a skewed task benefit distribution related to the resource ratio (the first graph), and the network degree (the second graph) .
8-5:setting .
8-6:For example, Kraus et al .
8-7:[12] develop an auction protocol that enables agents to form coalitions with time constraints .
8-8:It assumes each agent knows the capabilities of all others .
8-9:The proposed protocol is centralized, where one manager is responsible for allocating the tasks to all coalitions .
8-10:Manisterski at al .
8-11:[14] discuss the possibilities of achieving efficient allocations in both cooperative and noncooperative settings .
8-12:They propose a centralized algorithm to find the optimal solution .
8-13:In contrast to this work, we introduce also an efficient completely distributed protocol that takes the social network into account .
8-14:Task allocation has also been studied in distributed settings by for example Shehory and Kraus [18] and by Lerman and Shehory [13] .
8-15:They propose distributed algorithms with low communication complexity for forming coalitions in large scale multiagent systems .
8-16:However, they do not assume the existence of any agent network .
8-17:The work of Sander et al .
8-18:[16] introduces computational geometry based algorithms for distributed task allocation in geographical domains .
8-19:Agents are then allowed to move and actively search for tasks, and the capability of agents to perform tasks is homogeneous .
8-20:In order to apply their approach, agents need to have some knowledge about the geographical positions of tasks and some other agents .
8-21:Other work [17] proposes a location mechanism for open multiagent systems to allocate tasks to unknown agents .
8-22:In this approach each agent caches a list of agents they know .
8-23:The analysis of the communication complexity of this method is based on lattice like graphs, while we investigate how to efficiently solve task allocation in a social network, whose topology can be arbitrary .
8-24:Networks have been employed in the context of task allocation in some other works as well, for example to limit the 0 1000 2000 3000 4000 5000 6000 7000 0 200 400 600 800 1000 1200 1400 1600 1800 2000 Time(ms) Agents upper bound small world upper bound random upper bound scale free GDAP small world GDAP random GDAP scale free Figure 7: The run time of the GDAP algorithm .
8-25:0.75 0.8 0.85 0.9 0.95 1 0 200 400 600 800 1000 1200 1400 1600 1800 2000 Rewardrelativetoupperbound Agents small world random scale free Figure 8: The quality of the GDAP algorithm compared to the upper bound .
8-26:interactions between agents and mediators [1] .
8-27:Mediators in this context are agents who receive the task and have connections to other agents .
8-28:They break up the task into subtasks, and negotiate with other agents to obtain commitments to execute these subtasks .
8-29:Their focus is on modeling the decision process of just a single mediator .
8-30:Another approach is to partition the network into cliques of nodes, representing coalitions which the agents involved may use as a coordination mechanism [20] .
8-31:The focus of that work is distributed coalition formation among agents, but in our approach, we do not need agents to form groups before allocating tasks .
8-32:Easwaran and Pitt [6] study ‘complex tasks" that require ‘services" for their accomplishment .
8-33:The problem concerns the allocation of subtasks to service providers in a supply chain .
8-34:Another study of task allocation in supply chains is [21], where it is argued that the defining characteristic of Supply Chain Formation is hierarchical subtask decomposition .
8-35:HSD is implemented using task dependency networks (TDN), with agents and goods as nodes, and I O relations between them as edges .
8-36:Here, the network is given, and the problem is to select a subgraph, for which the authors propose a market based algorithm, in particular, a series of auctions .
8-37:Compared to these works, our approach is more general in the sense that we are able to model different types of connections or constraints among agents for different problem domains in addition to supply chain formation .
8-38:Finally, social networks have been used in the context of team formation .
8-39:Previous work has shown how to learn which relations are more beneficial in the long run [8], and adapt the social network accordingly .
8-40:We believe these results can be transferred to the domain of task allocation as well, leaving this as a topic for further study .
8-41:506 The Sixth Intl .
8-42:Joint Conf .
8-43:on Autonomous Agents and Multi Agent Systems (AAMAS 07) .
9-1:In this paper we studied the task allocation problem in a social network (STAP), which can be seen as a new, more general, variant of the TAP
9-2:We believe it has a great amount of potential for realistic problems
9-3:We provided complexity results on computing the efficient solution for the STAP, as well as a bound on possible approximation algorithms
9-4:Next, we presented a distributed protocol, related to the contractnet protocol
9-5:We also introduced an exponential algorithm to compute the optimal solution, as well as a fast upperbound algorithm
9-6:Finally, we used the optimal solution and the upper bound (for larger instances) to conduct an extensive set of experiments to assess the solution quality and the computational efficiency of the proposed distributed algorithm in different types of networks, namely, small world networks, random networks, and scale free networks
9-7:The results presented in this paper show that the distributed algorithm performs well in small world, scale free, and random networks, and for many different settings
9-8:Also other experiments were done (e.g
9-9:on grid networks) and these results held up over a wider range of scenarios
9-10:Furthermore, we showed that it scales well to large networks, both in terms of quality and of required computation time
9-11:The results also suggest that small world networks are slightly better suited for local task allocation, because there are no nodes with very few neighbors
9-12:There are many interesting extensions to our current work
9-13:In this paper, we focus on the computational aspect in the design of the distributed algorithm
9-14:In our future work, we would also like to address some of the related issues in game theory, such as strategic agents, and show desirable properties of a distributed protocol in such a context
9-15:In the current algorithm we assume that agents can only contact their neighbors to request resources, which may explain why our algorithm performs not as good in the scalefree networks as in the small world networks
9-16:Our future work may allow agents to reallocate (sub)tasks
9-17:We are interested in seeing how such interactions will affect the performance of task allocation in different social networks
9-18:A third interesting topic for further work is the addition of reputation information among the agents
9-19:This may help to model changing business relations and incentivize agents to follow the protocol
9-20:Finally, it would be interesting to study real life instances of the social task allocation problem, and see how they relate to the randomly generated networks of different types studied in this paper
9-21:Acknowledgments
9-22:This work is supported by the Technology Foundation STW, applied science division of NWO, and the Ministry of Economic Affairs.
10-1:S
10-2:Abdallah and V
10-3:Lesser
10-4:Modeling Task Allocation Using a Decision Theoretic Model
10-5:In Proc
10-6:AAMAS, pages 719 726
10-7:ACM, 2005
10-8:N
10-9:Alon, U
10-10:Feige, A
10-11:Wigderson, and D
10-12:Zuckerman
10-13:Derandomized Graph Products
10-14:Computational Complexity, 5(1):60 75, 1995
10-15:A. L
10-16:Barab´asi and R
10-17:Albert
10-18:Emergence of scaling in random networks
10-19:Science, 286(5439):509 512, 1999
10-20:R
10-21:H
10-22:Coase
10-23:The Nature of the Firm
10-24:Economica NS, 4(16):386 405, 1937
10-25:R
10-26:H
10-27:Coase
10-28:My Evolution as an Economist
10-29:In W
10-30:Breit and R
10-31:W
10-32:Spencer, editors, Lives of the Laureates, pages 227 249
10-33:MIT Press, 1995
10-34:A
10-35:M
10-36:Easwaran and J
10-37:Pitt
10-38:Supply Chain Formation in Open, Market Based Multi Agent Systems
10-39:International J
10-40:of Computational Intelligence and Applications, 2(3):349 363, 2002
10-41:I
10-42:Foster, N
10-43:R
10-44:Jennings, and C
10-45:Kesselman
10-46:Brain Meets Brawn: Why Grid and Agents Need Each Other
10-47:In Proc
10-48:AAMAS, pages 8 15, Washington, DC, USA, 2004
10-49:IEEE Computer Society
10-50:M
10-51:E
10-52:Gaston and M
10-53:desJardins
10-54:Agent organized networks for dynamic team formation
10-55:In Proc
10-56:AAMAS, pages 230 237, New York, NY, USA, 2005
10-57:ACM Press
10-58:A
10-59:Goldberg
10-60:An Efficient Implementation of a Scaling Minimum Cost Flow Algorithm
10-61:J
10-62:of Algorithms, 22:1 29, 1997
10-63:R
10-64:Gulati
10-65:Does Familiarity Breed Trust? The Implications of Repeated Ties for Contractual Choice in Alliances
10-66:Academy of Management Journal, 38(1):85 112, 1995
10-67:T
10-68:Klos and B
10-69:Nooteboom
10-70:Agent based Computational Transaction Cost Economics
10-71:Economic Dynamics and Control, 25(3 4):503 526, 01
10-72:S
10-73:Kraus, O
10-74:Shehory, and G
10-75:Taase
10-76:Coalition formation with uncertain heterogeneous information
10-77:In Proc
10-78:AAMAS, pages 1 8
10-79:ACM, 2003
10-80:K
10-81:Lerman and O
10-82:Shehory
10-83:Coalition formation for large scale electronic markets
10-84:In Proc
10-85:ICMAS, pages 167 174
10-86:IEEE Computer Society, 2000
10-87:E
10-88:Manisterski, E
10-89:David, S
10-90:Kraus, and N
10-91:Jennings
10-92:Forming Efficient Agent Groups for Completing Complex Tasks
10-93:In Proc
10-94:AAMAS, pages 257 264
10-95:ACM, 2006
10-96:J
10-97:Patel et al
10-98:Agent Based Virtual Organizations for the Grid
10-99:Multi Agent and Grid Systems, 1(4):237 249, 2005
10-100:P
10-101:V
10-102:Sander, D
10-103:Peleshchuk, and B
10-104:J
10-105:Grosz
10-106:A scalable, distributed algorithm for efficient task allocation
10-107:In Proc
10-108:AAMAS, pages 1191 1198, New York, NY, USA, 2002
10-109:ACM Press
10-110:O
10-111:Shehory
10-112:A scalable agent location mechanism
10-113:In Proc
10-114:ATAL, volume 1757 of LNCS, pages 162 172
10-115:Springer, 2000
10-116:O
10-117:Shehory and S
10-118:Kraus
10-119:Methods for Task Allocation via Agent Coalition Formation
10-120:Artificial Intelligence, 101(1 2):165 200, 1998
10-121:R
10-122:M
10-123:Sreenath and M
10-124:P
10-125:Singh
10-126:Agent based service selection
10-127:Web Semantics, 1(3):261 279, 2004
10-128:P
10-129:T
10-130:Toˇsi´c and G
10-131:A
10-132:Agha
10-133:Maximal Clique Based Distributed Coalition Formation for Task Allocation in Large Scale Multi Agent Systems
10-134:In Proc
10-135:MMAS, volume 3446 of LNAI, pages 104 120
10-136:Springer, 2005
10-137:W
10-138:E
10-139:Walsh and M
10-140:P
10-141:Wellman
10-142:Modeling Supply Chain Formation in Multiagent Systems
10-143:In Proc
10-144:AMEC II, volume 1788 of LNAI, pages 94 101
10-145:Springer, 2000
10-146:D
10-147:J
10-148:Watts and S
10-149:H
10-150:Strogatz
10-151:Collective dynamics of ‘small world" networks
10-152:Nature, 393:440 442, 1998
10-153:The Sixth Intl
10-154:Joint Conf
10-155:on Autonomous Agents and Multi Agent Systems (AAMAS 07) 507
picture:
