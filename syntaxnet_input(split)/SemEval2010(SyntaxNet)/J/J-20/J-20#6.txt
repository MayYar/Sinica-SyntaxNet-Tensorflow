
1
Input: CYCLE FORMULATION In this section , we consider a formulation of the clearing problem as an ILP with one variable for each cycle .
Parse:
consider VBP ROOT
 +-- FORMULATION NN nsubj
 |   +-- CYCLE NN amod
 +-- In IN prep
 |   +-- section NN pobj
 |       +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- formulation NN dobj
 |   +-- a DT det
 |   +-- of IN prep
 |       +-- problem NN pobj
 |           +-- the DT det
 |           +-- clearing NN nn
 +-- as IN prep
 |   +-- ILP NNP pobj
 |       +-- an DT det
 |       +-- with IN prep
 |           +-- variable NN pobj
 |               +-- one CD num
 |               +-- for IN prep
 |                   +-- cycle NN pobj
 |                       +-- each DT det
 +-- . . punct

2
Input: This encoding is based on the following classical algorithm for solving the directed cycle cover problem when cycles have length 2 .
Parse:
based VBN ROOT
 +-- encoding NN nsubjpass
 |   +-- This DT det
 +-- is VBZ auxpass
 +-- on IN prep
 |   +-- algorithm NN pobj
 |       +-- the DT det
 |       +-- following VBG amod
 |       +-- classical JJ amod
 |       +-- for IN prep
 |           +-- solving VBG pcomp
 |               +-- problem NN dobj
 |               |   +-- the DT det
 |               |   +-- directed VBN amod
 |               |   +-- cover NN nn
 |               |       +-- cycle NN nn
 |               +-- have VBP advcl
 |                   +-- when WRB advmod
 |                   +-- cycles NNS nsubj
 |                   +-- length NN dobj
 |                       +-- 2 CD num
 +-- . . punct

3
Input: Given a market G = -LRB- V , E -RRB- , construct a new graph on V with a weight wc edge for each cycle c of length 2 .
Parse:
construct VB ROOT
 +-- Given VBN prep
 |   +-- G NNP dep
 |       +-- a DT det
 |       +-- market NN nn
 |       +-- = SYM punct
 |       +-- -LRB- -LRB- punct
 |       +-- V NNP dep
 |       |   +-- , , punct
 |       |   +-- E NNP appos
 |       +-- -RRB- -RRB- punct
 +-- , , punct
 +-- graph NN dobj
 |   +-- a DT det
 |   +-- new JJ amod
 |   +-- on IN prep
 |       +-- V NN pobj
 +-- with IN prep
 |   +-- edge NN pobj
 |       +-- a DT det
 |       +-- weight NN nn
 |       +-- wc NN nn
 |       +-- for IN prep
 |           +-- cycle NN pobj
 |               +-- each DT det
 |               +-- c CD dep
 |                   +-- of IN prep
 |                       +-- length NN pobj
 |                           +-- 2 CD num
 +-- . . punct

4
Input: It is easy to see that matchings in this new graph correspond to cycle covers by length 2 cycles in the original market graph .
Parse:
easy JJ ROOT
 +-- It PRP nsubj
 +-- is VBZ cop
 +-- see VB xcomp
 |   +-- to TO aux
 |   +-- correspond VBP ccomp
 |       +-- that IN mark
 |       +-- matchings NNS nsubj
 |       |   +-- in IN prep
 |       |       +-- graph NN pobj
 |       |           +-- this DT det
 |       |           +-- new JJ amod
 |       +-- to IN prep
 |       |   +-- covers NNS pobj
 |       |       +-- cycle NN nn
 |       +-- by IN prep
 |           +-- cycles NNS pobj
 |               +-- length NN nn
 |               +-- 2 CD num
 |               +-- in IN prep
 |                   +-- graph NN pobj
 |                       +-- the DT det
 |                       +-- original JJ amod
 |                       +-- market NN nn
 +-- . . punct

5
Input: Hence , the market clearing problem with L = 2 can be solved in polynomial time by finding a maximum weight matching .
Parse:
solved VBN ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- problem NN nsubjpass
 |   +-- the DT det
 |   +-- clearing NN nn
 |   |   +-- market NN nn
 |   +-- with IN prep
 |       +-- L NN pobj
 |           +-- = SYM dep
 |           +-- 2 CD num
 +-- can MD aux
 +-- be VB auxpass
 +-- in IN prep
 |   +-- time NN pobj
 |       +-- polynomial JJ amod
 +-- by IN prep
 |   +-- finding VBG pcomp
 |       +-- matching NN dobj
 |           +-- a DT det
 |           +-- maximum JJ amod
 |           +-- weight NN nn
 +-- . . punct

6
Input: c_1 v 1 v 2 v 3 v 4 c_3c_2 Figure 4
Parse:
Figure NN ROOT
 +-- c_1 LS dep
 +-- v NN dep
 +-- 1 CD dep
 |   +-- v NN prep
 |       +-- 2 CD dep
 +-- 4 CD num
 +-- c_3c_2 CD num

7
Input: We can generalize this encoding for arbitrary L .
Parse:
generalize VB ROOT
 +-- We PRP nsubj
 +-- can MD aux
 +-- encoding VBG dobj
 |   +-- this DT det
 +-- for IN prep
 |   +-- L NN pobj
 |       +-- arbitrary JJ amod
 +-- . . punct

8
Input: Let C -LRB- L -RRB- be the set of all cycles of G with length at most L .
Parse:
Let VB ROOT
 +-- set NN ccomp
 |   +-- C DT nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- L NNP dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- of IN prep
 |   |   +-- cycles NNS pobj
 |   |       +-- all DT det
 |   |       +-- of IN prep
 |   |           +-- G NNP pobj
 |   |               +-- with IN prep
 |   |                   +-- length NN pobj
 |   +-- at IN prep
 |       +-- L NNP pobj
 |           +-- most RBS amod
 +-- . . punct

9
Input: Then the following ILP finds the maximum weight cycle cover by C -LRB- L -RRB- cycles
Parse:
finds VBZ ROOT
 +-- Then RB advmod
 +-- ILP NNP nsubj
 |   +-- the DT det
 |   +-- following VBG amod
 +-- cover NN dobj
     +-- the DT det
     +-- maximum JJ amod
     +-- cycle NN nn
     |   +-- weight NN nn
     +-- by IN prep
         +-- cycles NNS pobj
             +-- L NNP nn
                 +-- C NNP nn
                 +-- -LRB- -LRB- punct
                 +-- -RRB- -RRB- punct

10
Input: The edge formulation can be solved in polynomial time when there are no constraints on the cycle size .
Parse:
solved VBN ROOT
 +-- formulation NN nsubjpass
 |   +-- The DT det
 |   +-- edge NN nn
 +-- can MD aux
 +-- be VB auxpass
 +-- in IN prep
 |   +-- time NN pobj
 |       +-- polynomial JJ amod
 +-- are VBP advcl
 |   +-- when WRB advmod
 |   +-- there EX expl
 |   +-- constraints NNS nsubj
 |       +-- no DT det
 |       +-- on IN prep
 |           +-- size NN pobj
 |               +-- the DT det
 |               +-- cycle NN nn
 +-- . . punct

11
Input: The cycle formulation can be solved in polynomial time when the cycle size is at most 2 .
Parse:
solved VBN ROOT
 +-- formulation NN nsubjpass
 |   +-- The DT det
 |   +-- cycle NN nn
 +-- can MD aux
 +-- be VB auxpass
 +-- in IN prep
 |   +-- time NN pobj
 |       +-- polynomial JJ amod
 +-- is VBZ advcl
 |   +-- when WRB advmod
 |   +-- size NN nsubj
 |   |   +-- the DT det
 |   |   +-- cycle NN nn
 |   +-- at IN prep
 |       +-- 2 CD pobj
 |           +-- most RBS amod
 +-- . . punct

12
Input: We now consider the case of short cycles of length at most L , where L ? 3 .
Parse:
consider VBP ROOT
 +-- We PRP nsubj
 +-- now RB advmod
 +-- case NN dobj
 |   +-- the DT det
 |   +-- of IN prep
 |       +-- cycles NNS pobj
 |           +-- short JJ amod
 |           +-- of IN prep
 |               +-- length NN pobj
 +-- at IN prep
 |   +-- L NNP pobj
 |       +-- most RBS amod
 |       +-- , , punct
 |       +-- 3 CD rcmod
 |           +-- where WRB advmod
 |           +-- L NNP dep
 |               +-- ? . punct
 +-- . . punct

13
Input: Our tree search algorithms use the LP relaxation of these formulations to provide upper bounds on the optimal solution .
Parse:
use VBP ROOT
 +-- algorithms NNS nsubj
 |   +-- Our PRP$ poss
 |   +-- search NN nn
 |       +-- tree NN nn
 +-- relaxation NN dobj
 |   +-- the DT det
 |   +-- LP JJ amod
 |   +-- of IN prep
 |       +-- formulations NNS pobj
 |           +-- these DT det
 +-- provide VB xcomp
 |   +-- to TO aux
 |   +-- bounds NNS dobj
 |   |   +-- upper JJ amod
 |   +-- on IN prep
 |       +-- solution NN pobj
 |           +-- the DT det
 |           +-- optimal JJ amod
 +-- . . punct

14
Input: These bounds help prune subtrees and guide the search in the usual ways .
Parse:
help VBP ROOT
 +-- bounds NNS nsubj
 |   +-- These DT det
 +-- prune NN ccomp
 |   +-- subtrees NNS dobj
 +-- and CC cc
 +-- guide VB conj
 |   +-- search NN dobj
 |       +-- the DT det
 |       +-- in IN prep
 |           +-- ways NNS pobj
 |               +-- the DT det
 |               +-- usual JJ amod
 +-- . . punct

15
Input: Theorem 2 .
Parse:
Theorem PRP ROOT
 +-- 2 CD dep
 +-- . . punct

16
Input: The LP relaxation of the cycle formulation weakly dominates the LP relaxation of the edge formulation .
Parse:
dominates VBZ ROOT
 +-- relaxation NN nsubj
 |   +-- The DT det
 |   +-- LP JJ nn
 |   +-- of IN prep
 |       +-- formulation NN pobj
 |           +-- the DT det
 |           +-- cycle NN nn
 +-- weakly RB advmod
 +-- relaxation NN dobj
 |   +-- the DT det
 |   +-- LP JJ nn
 |   +-- of IN prep
 |       +-- formulation NN pobj
 |           +-- the DT det
 |           +-- edge NN nn
 +-- . . punct

17
Input: Proof .
Parse:
Proof NNP ROOT
 +-- . . punct

18
Input: Consider an optimal solution to the LP relaxation of the cycle formulation .
Parse:
Consider VB ROOT
 +-- solution NN dobj
 |   +-- an DT det
 |   +-- optimal JJ amod
 |   +-- to IN prep
 |       +-- relaxation NN pobj
 |           +-- the DT det
 |           +-- LP NNP nn
 |           +-- of IN prep
 |               +-- formulation NN pobj
 |                   +-- the DT det
 |                   +-- cycle NN nn
 +-- . . punct

19
Input: We show how to construct an equivalent solution in the edge formulation .
Parse:
show VBP ROOT
 +-- We PRP nsubj
 +-- construct VB ccomp
 |   +-- how WRB advmod
 |   +-- to TO aux
 |   +-- solution NN dobj
 |       +-- an DT det
 |       +-- equivalent JJ amod
 |       +-- in IN prep
 |           +-- formulation NN pobj
 |               +-- the DT det
 |               +-- edge NN nn
 +-- . . punct

20
Input: For each edge in the graph , set its value as the sum of values of all the cycles of which it is a member .
Parse:
set VBD ROOT
 +-- For IN prep
 |   +-- edge NN pobj
 |       +-- each DT det
 |       +-- in IN prep
 |           +-- graph NN pobj
 |               +-- the DT det
 +-- , , punct
 +-- value NN dobj
 |   +-- its PRP$ poss
 +-- as IN prep
 |   +-- sum NN pobj
 |       +-- the DT det
 |       +-- of IN prep
 |           +-- values NNS pobj
 |               +-- of IN prep
 |                   +-- cycles NNS pobj
 |                       +-- all PDT predet
 |                       +-- the DT det
 |                       +-- member NN rcmod
 |                           +-- of IN prep
 |                           |   +-- which WDT pobj
 |                           +-- it PRP nsubj
 |                           +-- is VBZ cop
 |                           +-- a DT det
 +-- . . punct

21
Input: Also , define the value of a vertex in the same manner .
Parse:
define VB ROOT
 +-- Also RB advmod
 +-- , , punct
 +-- value NN dobj
 |   +-- the DT det
 |   +-- of IN prep
 |       +-- vertex NN pobj
 |           +-- a DT det
 +-- in IN prep
 |   +-- manner NN pobj
 |       +-- the DT det
 |       +-- same JJ amod
 +-- . . punct

22
Input: Because of the cycle constraints , the conservation and capacity constraints of the edge encoding are clearly satisfied .
Parse:
satisfied JJ ROOT
 +-- of IN prep
 |   +-- Because IN mwe
 |   +-- constraints NNS pobj
 |       +-- the DT det
 |       +-- cycle NN nn
 +-- , , punct
 +-- constraints NNS nsubj
 |   +-- the DT det
 |   +-- conservation NN nn
 |   |   +-- and CC cc
 |   |   +-- capacity NN conj
 |   +-- of IN prep
 |       +-- encoding NN pobj
 |           +-- the DT det
 |           +-- edge NN nn
 +-- are VBP cop
 +-- clearly RB advmod
 +-- . . punct

23
Input: It remains to show that none of the path constraints are violated .
Parse:
remains VBZ ROOT
 +-- It PRP nsubj
 +-- show VB xcomp
 |   +-- to TO aux
 |   +-- violated VBN ccomp
 |       +-- that IN mark
 |       +-- none NN nsubjpass
 |       |   +-- of IN prep
 |       |       +-- constraints NNS pobj
 |       |           +-- the DT det
 |       |           +-- path NN nn
 |       +-- are VBP auxpass
 +-- . . punct

24
Input: Let p be any length L path in the graph .
Parse:
Let VB ROOT
 +-- path NN ccomp
 |   +-- p PRP nsubj
 |   +-- be VB cop
 |   +-- any DT det
 |   +-- length NN nn
 |   +-- L NN nn
 |   +-- in IN prep
 |       +-- graph NN pobj
 |           +-- the DT det
 +-- . . punct

25
Input: Since p has L ? 1 interior vertices -LRB- not counting the endpoints -RRB- , the value sum of these interior vertices is at most L ? 1 .
Parse:
is VBZ ROOT
 +-- has VBZ advcl
 |   +-- Since IN mark
 |   +-- p NNP nsubj
 |   +-- L NNP dobj
 |       +-- ? . punct
 |       +-- vertices NNS appos
 |           +-- interior NN amod
 |           |   +-- 1 CD number
 |           +-- -LRB- -LRB- punct
 |           +-- counting VBG dep
 |           |   +-- not RB neg
 |           |   +-- endpoints NNS dobj
 |           |       +-- the DT det
 |           +-- -RRB- -RRB- punct
 +-- , , punct
 +-- sum NN nsubj
 |   +-- the DT det
 |   +-- value NN nn
 |   +-- of IN prep
 |       +-- vertices NNS pobj
 |           +-- these DT det
 |           +-- interior NNP amod
 +-- at IN prep
 |   +-- L NNP pobj
 |       +-- most RBS amod
 |       +-- ? . punct
 |       +-- 1 CD num
 +-- . . punct

26
Input: Now , for any cycle c of length at most L , the number of edges it has in p , which we denote by ec -LRB- p -RRB- , is at most the number of interior vertices it has in p , which we denote by vc -LRB- p -RRB- .
Parse:
is VBZ ROOT
 +-- Now RB advmod
 +-- , , punct
 +-- for IN prep
 |   +-- cycle NN pobj
 |       +-- any DT det
 |       +-- c CD num
 |       +-- of IN prep
 |       |   +-- length NN pobj
 |       +-- at IN prep
 |           +-- L NNP pobj
 |               +-- most RBS amod
 +-- number NN nsubj
 |   +-- the DT det
 |   +-- of IN prep
 |   |   +-- vertices NNS pobj
 |   |       +-- interior NNP amod
 |   +-- has VBZ rcmod
 |   |   +-- it PRP nsubj
 |   |   +-- in IN prep
 |   |       +-- p NN pobj
 |   +-- , , punct
 |   +-- denote VBP rcmod
 |       +-- which WDT dobj
 |       +-- we PRP nsubj
 |       +-- by IN prep
 |           +-- vc NNP pobj
 |               +-- p NN appos
 |                   +-- -LRB- -LRB- punct
 |                   +-- -RRB- -RRB- punct
 +-- most RBS advmod
 |   +-- at IN advmod
 +-- . . punct

27
Input: Hence , ? e ? p e = ? c ? C -LRB- L -RRB- c ? ec -LRB- p -RRB- ? ? c ? C -LRB- L -RRB- c ? vc -LRB- p -RRB- = ? v ? p v = L ? 1 .
Parse:
L NNP ROOT
 +-- Hence RB dep
 |   +-- , , punct
 |   +-- ? . punct
 |   +-- e NFP punct
 |   +-- p , punct
 +-- e NN dep
 +-- = SYM dep
 +-- ? . punct
 +-- c NN dep
 |   +-- ? . punct
 |   +-- vc UH dep
 |       +-- p NN dep
 |           +-- -LRB- -LRB- punct
 |           +-- -RRB- -RRB- punct
 +-- C NNP dep
 |   +-- L NNP appos
 |       +-- -LRB- -LRB- punct
 |       +-- -RRB- -RRB- punct
 +-- -LRB- -LRB- punct
 +-- -RRB- -RRB- punct
 +-- c NFP punct
 +-- v NN dep
 +-- p , punct
 +-- = NFP punct
 +-- L NN dep
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- . . punct

28
Input: 299 The converse of this theorem is not true .
Parse:
true JJ ROOT
 +-- converse NN nsubj
 |   +-- 299 CD num
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- theorem NN pobj
 |           +-- this DT det
 +-- is VBZ cop
 +-- not RB neg
 +-- . . punct

29
Input: Consider a graph which is simply a cycle with n edges .
Parse:
Consider VB ROOT
 +-- graph NN dobj
 |   +-- a DT det
 |   +-- cycle NN rcmod
 |       +-- which WDT nsubj
 |       +-- is VBZ cop
 |       +-- simply RB advmod
 |       +-- a DT det
 |       +-- with IN prep
 |           +-- edges NNS pobj
 |               +-- n DT det
 +-- . . punct

30
Input: Clearly , the LP relaxation of the cycle formulation has optimal value 0 , since there are no cycles of size at most L .
Parse:
has VBZ ROOT
 +-- Clearly RB advmod
 +-- , , punct
 +-- relaxation NN nsubj
 |   +-- the DT det
 |   +-- LP NNP nn
 |   +-- of IN prep
 |       +-- formulation NN pobj
 |           +-- the DT det
 |           +-- cycle NN nn
 +-- value NN dobj
 |   +-- optimal JJ amod
 |   +-- 0 CD num
 +-- are VBP advcl
 |   +-- since IN mark
 |   +-- there EX expl
 |   +-- cycles NNS nsubj
 |       +-- no DT det
 |       +-- of IN prep
 |       |   +-- size NN pobj
 |       +-- at IN prep
 |           +-- L NNP pobj
 |               +-- most RBS amod
 +-- . . punct

31
Input: However , the edge formulation has a solution of size n 2 , with each edge having value 1 2 .
Parse:
has VBZ ROOT
 +-- However RB advmod
 +-- , , punct
 +-- formulation NN nsubj
 |   +-- the DT det
 |   +-- edge NN nn
 +-- solution NN dobj
 |   +-- a DT det
 |   +-- of IN prep
 |   |   +-- size NN pobj
 |   |       +-- n CC cc
 |   |       +-- 2 CD conj
 |   +-- , , punct
 |   +-- with IN prep
 |       +-- having VBG pcomp
 |           +-- edge NN nsubj
 |           |   +-- each DT det
 |           +-- value NN dobj
 |               +-- 2 CD num
 |                   +-- 1 CD number
 +-- . . punct

32
Input: Hence , the cycle formulation is tighter than the edge formulation .
Parse:
tighter JJR ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- formulation NN nsubj
 |   +-- the DT det
 |   +-- cycle NN nn
 +-- is VBZ cop
 +-- than IN prep
 |   +-- formulation NN pobj
 |       +-- the DT det
 |       +-- edge NN nn
 +-- . . punct

33
Input: Additionally , for a graph with m edges , the edge formulation requires O -LRB- m3 -RRB- constraints , while the cycle formulation requires only O -LRB- m2 -RRB- .
Parse:
requires VBZ ROOT
 +-- Additionally RB advmod
 +-- , , punct
 +-- for IN prep
 |   +-- graph NN pobj
 |       +-- a DT det
 |       +-- with IN prep
 |           +-- edges NNS pobj
 |               +-- m CD num
 +-- formulation NN nsubj
 |   +-- the DT det
 |   +-- edge NN nn
 +-- constraints NNS dobj
 |   +-- m3 LS nn
 |       +-- O NNP dep
 |       +-- -LRB- -LRB- punct
 |       +-- -RRB- -RRB- punct
 +-- requires VBZ advcl
 |   +-- while IN mark
 |   +-- formulation NN nsubj
 |   |   +-- the DT det
 |   |   +-- cycle NN nn
 |   +-- O NN dobj
 |       +-- only RB advmod
 |       +-- m2 CD appos
 |           +-- -LRB- -LRB- punct
 |           +-- -RRB- -RRB- punct
 +-- . . punct

34
Input: 5.2 Column Generation for the LP Table 2 shows how the number of cycles of length at most 3 grows with the size of the market .
Parse:
shows VBZ ROOT
 +-- Generation NNP nsubj
 |   +-- 5.2 LS num
 |   +-- Column NNP nn
 |   +-- for IN prep
 |       +-- Table NNP pobj
 |           +-- the DT det
 |           +-- LP NNP nn
 |           +-- 2 CD num
 +-- grows VBZ ccomp
 |   +-- how WRB advmod
 |   +-- number NN nsubj
 |   |   +-- the DT det
 |   |   +-- of IN prep
 |   |   |   +-- cycles NNS pobj
 |   |   |       +-- of IN prep
 |   |   |           +-- length NN pobj
 |   |   +-- at IN prep
 |   |       +-- 3 CD pobj
 |   |           +-- most RBS amod
 |   +-- with IN prep
 |       +-- size NN pobj
 |           +-- the DT det
 |           +-- of IN prep
 |               +-- market NN pobj
 |                   +-- the DT det
 +-- . . punct

35
Input: With one variable per cycle in the cycle formulation , CPLEX can not even clear markets with 1 , 000 patients without running out of memory -LRB- see Figure 6 -RRB- .
Parse:
markets NNS ROOT
 +-- With IN prep
 |   +-- variable NN pobj
 |       +-- one CD num
 |       +-- per IN prep
 |       |   +-- cycle NN pobj
 |       +-- in IN prep
 |           +-- formulation NN pobj
 |               +-- the DT det
 |               +-- cycle NN nn
 +-- , , punct
 +-- CPLEX NNP nsubj
 +-- can MD aux
 +-- not RB neg
 +-- even RB advmod
 +-- clear JJ amod
 +-- with IN prep
 |   +-- patients NNS pobj
 |       +-- 000 CD num
 |           +-- 1 CD number
 |           +-- , , punct
 +-- without IN prep
 |   +-- running VBG pcomp
 |       +-- out IN prep
 |       |   +-- of IN pcomp
 |       |       +-- memory NN pobj
 |       +-- see VB parataxis
 |           +-- -LRB- -LRB- punct
 |           +-- Figure NN dobj
 |           |   +-- 6 CD num
 |           +-- -RRB- -RRB- punct
 +-- . . punct

36
Input: To address this problem , we used an incremental formulation approach .
Parse:
used VBD ROOT
 +-- address VB advcl
 |   +-- To TO aux
 |   +-- problem NN dobj
 |       +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- approach NN dobj
 |   +-- an DT det
 |   +-- incremental JJ amod
 |   +-- formulation NN nn
 +-- . . punct

37
Input: The first step in LP guided tree search is to solve the LP relaxation .
Parse:
is VBZ ROOT
 +-- step NN nsubj
 |   +-- The DT det
 |   +-- first JJ amod
 |   +-- in IN prep
 |       +-- search NN pobj
 |           +-- LP JJ nn
 |           +-- guided VBN amod
 |           +-- tree NN nn
 +-- solve VB xcomp
 |   +-- to TO aux
 |   +-- relaxation NN dobj
 |       +-- the DT det
 |       +-- LP NNP nn
 +-- . . punct

38
Input: Since the cycle formulation does not fit in memory , this LP stage would fail immediately without an incremental formulation approach .
Parse:
fail VB ROOT
 +-- fit VB advcl
 |   +-- Since IN mark
 |   +-- formulation NN nsubj
 |   |   +-- the DT det
 |   |   +-- cycle NN nn
 |   +-- does VBZ aux
 |   +-- not RB neg
 |   +-- in IN prep
 |       +-- memory NN pobj
 +-- , , punct
 +-- stage NN nsubj
 |   +-- this DT det
 |   +-- LP JJ amod
 +-- would MD aux
 +-- immediately RB advmod
 +-- without IN prep
 |   +-- approach NN pobj
 |       +-- an DT det
 |       +-- incremental JJ amod
 |       +-- formulation NN nn
 +-- . . punct

39
Input: However , motivated by the observation that an exchange solution can include only a tiny fraction of the cycles , we explored the approach of using column -LRB- i.e. , cycle -RRB- generation .
Parse:
explored VBD ROOT
 +-- However RB advmod
 +-- , , punct
 +-- motivated VBN partmod
 |   +-- by IN prep
 |       +-- observation NN pobj
 |           +-- the DT det
 |           +-- include VB ccomp
 |               +-- that IN mark
 |               +-- solution NN nsubj
 |               |   +-- an DT det
 |               |   +-- exchange NN nn
 |               +-- can MD aux
 |               +-- fraction NN dobj
 |                   +-- only RB advmod
 |                   +-- a DT det
 |                   +-- tiny JJ amod
 |                   +-- of IN prep
 |                       +-- cycles NNS pobj
 |                           +-- the DT det
 +-- we PRP nsubj
 +-- approach NN dobj
 |   +-- the DT det
 |   +-- of IN prep
 |       +-- using VBG pcomp
 |           +-- generation NN dobj
 |               +-- cycle NN nn
 |                   +-- column NN dep
 |                   +-- -LRB- -LRB- punct
 |                   +-- i.e. FW advmod
 |                   +-- , , punct
 |                   +-- -RRB- -RRB- punct
 +-- . . punct

40
Input: The idea of column generation is to start with a restricted LP containing only a small number of columns -LRB- variables , i.e. , cycles -RRB- , and then to repeatedly add columns until an optimal solution to this partially formulated LP is an optimal solution to the original -LRB- aka master -RRB- LP .
Parse:
is VBZ ROOT
 +-- idea NN nsubj
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- generation NN pobj
 |           +-- column NN nn
 +-- start VB xcomp
 |   +-- to TO aux
 |   +-- with IN prep
 |   |   +-- LP NN pobj
 |   |       +-- a DT det
 |   |       +-- restricted VBN amod
 |   |       +-- containing VBG partmod
 |   |           +-- number NN dobj
 |   |               +-- only RB advmod
 |   |               +-- a DT det
 |   |               +-- small JJ amod
 |   |               +-- of IN prep
 |   |               |   +-- columns NNS pobj
 |   |               +-- cycles NNS dep
 |   |                   +-- -LRB- -LRB- punct
 |   |                   +-- variables NNS dep
 |   |                   +-- , , punct
 |   |                   +-- i.e. FW dep
 |   |                   +-- -RRB- -RRB- punct
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- then RB advmod
 |   +-- add VB conj
 |       +-- to TO aux
 |       +-- repeatedly RB advmod
 |       +-- columns NNS dobj
 |       +-- solution NN advcl
 |           +-- until IN mark
 |           +-- solution NN nsubj
 |           |   +-- an DT det
 |           |   +-- optimal JJ amod
 |           |   +-- to IN prep
 |           |       +-- LP NNP pobj
 |           |           +-- this DT det
 |           |           +-- formulated VBN amod
 |           |               +-- partially RB advmod
 |           +-- is VBZ cop
 |           +-- an DT det
 |           +-- optimal JJ amod
 |           +-- to IN prep
 |               +-- LP NNP pobj
 |                   +-- the DT det
 |                   +-- original JJ amod
 |                   +-- -LRB- -LRB- punct
 |                   +-- master NN nn
 |                   |   +-- aka RB advmod
 |                   +-- -RRB- -RRB- punct
 +-- . . punct

41
Input: We explain this further by way of an example .
Parse:
explain VBP ROOT
 +-- We PRP nsubj
 +-- this DT dobj
 +-- further RBR advmod
 +-- by IN prep
 |   +-- way NN pobj
 |       +-- of IN prep
 |           +-- example NN pobj
 |               +-- an DT det
 +-- . . punct

42
Input: Consider the market in Figure 1 with L = 2 .
Parse:
Consider VB ROOT
 +-- market NN dobj
 |   +-- the DT det
 |   +-- in IN prep
 |       +-- Figure NN pobj
 |           +-- 1 CD num
 +-- with IN prep
 |   +-- L NN pobj
 |       +-- = SYM dep
 |       +-- 2 CD num
 +-- . . punct

43
Input: Figure 5 gives the corresponding master LP , P , and its dual , D .
Parse:
gives VBZ ROOT
 +-- Figure NN nsubj
 |   +-- 5 CD num
 +-- LP NN dobj
 |   +-- the DT det
 |   +-- corresponding VBG amod
 |   +-- master NN nn
 |   +-- , , punct
 |   +-- P UH conj
 |   +-- and CC cc
 |   +-- dual JJ conj
 |       +-- its PRP$ poss
 |       +-- , , punct
 |       +-- D NNP appos
 +-- . . punct

44
Input: Primal P max 2c1 +2c2 +2c3 s.t .
Parse:
P NN ROOT
 +-- Primal JJ amod
 +-- max NNP dep
 +-- 2c1 CD dep
 +-- +2c2 CD dep
 |   +-- s.t NNP dep
 |       +-- +2c3 CD num
 +-- . . punct

45
Input: c1 ? 1 -LRB- v1 -RRB- c1 +c2 ? 1 -LRB- v2 -RRB- +c2 +c3 ? 1 -LRB- v3 -RRB- +c3 ? 1 -LRB- v4 -RRB- with c1 , c2 , c3 ? 0 Dual D min v1 +v2 +v3 +v4 s.t v1 +v2 ? 2 -LRB- c1 -RRB- +v2 +v3 ? 2 -LRB- c2 -RRB- +v3 +v4 ? 2 -LRB- c3 -RRB- with v1 , v2 , v3 , v4 ? 0 Figure 5
Parse:
v1 LS ROOT
 +-- c1 LS dep
 |   +-- ? . punct
 +-- 1 CD num
 +-- -LRB- -LRB- punct
 +-- -RRB- -RRB- punct
 +-- +c2 CD dep
 |   +-- c1 CD num
 +-- ? , punct
 +-- v2 LS dep
 |   +-- 1 CD num
 |   +-- -LRB- -LRB- punct
 |   +-- -RRB- -RRB- punct
 |   +-- +c3 CD dep
 |   |   +-- 1 CD num
 |   |   +-- v3 LS dep
 |   |   |   +-- -LRB- -LRB- punct
 |   |   |   +-- -RRB- -RRB- punct
 |   |   +-- ? . punct
 |   |   +-- v4 CD dep
 |   |       +-- 1 CD num
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- -RRB- -RRB- punct
 |   |       +-- with IN prep
 |   |           +-- c1 CD pobj
 |   |               +-- , , punct
 |   |               +-- c2 CD amod
 |   |               +-- c3 CD appos
 |   +-- ? , punct
 +-- ? . punct
 +-- 0 NFP punct
 +-- min NNP dep
     +-- Dual JJ amod
     +-- D NNP nn
     +-- v1 CD num
     +-- +v2 CD dep
     +-- +v3 CD dep
     +-- +v4 CD dep
     +-- s.t FW dep
     +-- v1 CD dep
     +-- ? , punct
     +-- 2 CD dep
     +-- c1 LS dep
     |   +-- -LRB- -LRB- punct
     |   +-- -RRB- -RRB- punct
     +-- c2 LS dep
     |   +-- -LRB- -LRB- punct
     |   +-- -RRB- -RRB- punct
     +-- c3 CD dep
         +-- 2 CD num
         +-- -LRB- -LRB- punct
         +-- -RRB- -RRB- punct
         +-- with IN prep
             +-- v1 CD pobj
                 +-- , , punct
                 +-- v2 CD conj
                 +-- v3 CD conj
                 +-- v4 CD conj
                 +-- ? . punct
                 +-- 0 NFP punct
                 +-- Figure NN dep
                     +-- 5 CD num

46
Input: Let P be the restriction of P containing columns c1 and c3 only .
Parse:
Let VB ROOT
 +-- restriction NN ccomp
 |   +-- P PRP nsubj
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- of IN prep
 |   |   +-- P NN pobj
 |   +-- containing VBG partmod
 |       +-- columns NNS iobj
 |       +-- c1 CD dobj
 |           +-- and CC cc
 |           +-- c3 CD conj
 |           +-- only RB advmod
 +-- . . punct

47
Input: Let D be the dual of P , that is , D is just D without the constraint c2 .
Parse:
Let VB ROOT
 +-- dual JJ ccomp
 |   +-- D PRP nsubj
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- of IN prep
 |   |   +-- P NN pobj
 |   +-- , , punct
 |   +-- is VBZ ccomp
 |   |   +-- that DT advmod
 |   +-- D JJ ccomp
 |       +-- D NNP nsubj
 |       +-- is VBZ cop
 |       +-- just RB advmod
 |       +-- without IN prep
 |           +-- c2 CD pobj
 |               +-- the DT det
 |               +-- constraint NN amod
 +-- . . punct

48
Input: Because P and D are small , we can solve them to obtain OPT -LRB- P -RRB- = OPT -LRB- D -RRB- = 4 , with cOP T -LRB- P -RRB- = c1 = c3 = 1 and vOP T -LRB- D -RRB- = v1 = v2 = v3 = v4 = 1 .
Parse:
solve VB ROOT
 +-- small JJ advcl
 |   +-- Because IN mark
 |   +-- P NN nsubj
 |   |   +-- and CC cc
 |   |   +-- D NN conj
 |   +-- are VBP cop
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- them PRP dobj
 +-- obtain VB xcomp
 |   +-- to TO aux
 |   +-- OPT NNP dobj
 |       +-- -LRB- -LRB- punct
 |       +-- P NN dep
 |       +-- -RRB- -RRB- punct
 |       +-- = NFP punct
 |       +-- OPT NNP conj
 |       |   +-- D NNP appos
 |       |       +-- -LRB- -LRB- punct
 |       |       +-- -RRB- -RRB- punct
 |       +-- = SYM cc
 |       +-- 4 CD conj
 |       +-- , , punct
 |       +-- with IN conj
 |       |   +-- T NNP pobj
 |       |       +-- cOP NNP nn
 |       |       +-- P NN dep
 |       |       |   +-- -LRB- -LRB- punct
 |       |       |   +-- -RRB- -RRB- punct
 |       |       +-- = SYM dep
 |       |       +-- c1 CD dep
 |       |       +-- c3 CD num
 |       |       +-- = : punct
 |       |       +-- 1 CD num
 |       |       +-- and CC cc
 |       |       +-- T NNP conj
 |       |           +-- vOP NNP nn
 |       |           +-- D NNP appos
 |       |               +-- -LRB- -LRB- punct
 |       |               +-- -RRB- -RRB- punct
 |       +-- v1 CD conj
 |           +-- = SYM prep
 |               +-- v2 CD dep
 |                   +-- = : prep
 |                   |   +-- v3 CD dep
 |                   +-- = : punct
 |                   +-- v4 CD dep
 |                       +-- = SYM prep
 |                           +-- 1 CD num
 +-- . . punct

49
Input: While cOP T -LRB- P -RRB- must be a feasible solution of P , it turns out -LRB- fortunately -RRB- that vOP T -LRB- D -RRB- is feasible for D , so that OPT -LRB- D -RRB- ? OPT -LRB- D -RRB- .
Parse:
turns VBZ ROOT
 +-- solution NN advcl
 |   +-- While IN mark
 |   +-- T NNP nsubj
 |   |   +-- cOP NNP nn
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- P NN dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- must MD aux
 |   +-- be VB cop
 |   +-- a DT det
 |   +-- feasible JJ amod
 |   +-- of IN prep
 |       +-- P NN pobj
 +-- , , punct
 +-- it PRP nsubj
 +-- out RP prt
 +-- -LRB- -LRB- punct
 +-- fortunately RB advmod
 +-- -RRB- -RRB- punct
 +-- feasible JJ ccomp
 |   +-- that IN mark
 |   +-- T NNP nsubj
 |   |   +-- vOP NNP nn
 |   |   +-- D NNP appos
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- -RRB- -RRB- punct
 |   +-- is VBZ cop
 |   +-- for IN prep
 |   |   +-- D NNP pobj
 |   +-- , , punct
 |   +-- so IN advmod
 |       +-- that IN prep
 |           +-- OPT NNP pobj
 |               +-- D NNP appos
 |               |   +-- -LRB- -LRB- punct
 |               |   +-- -RRB- -RRB- punct
 |               +-- ? , punct
 |               +-- OPT NNP appos
 |                   +-- D NNP appos
 |                       +-- -LRB- -LRB- punct
 |                       +-- -RRB- -RRB- punct
 +-- . . punct

50
Input: We can verify this by checking that vOP T -LRB- D -RRB- satisfies the constraints of D not already in Di.e .
Parse:
verify VB ROOT
 +-- We PRP nsubj
 +-- can MD aux
 +-- this DT dobj
 +-- by IN prep
 |   +-- checking VBG pcomp
 |       +-- satisfies VBZ ccomp
 |           +-- that IN mark
 |           +-- T NNP nsubj
 |           |   +-- vOP NNP nn
 |           |   +-- -LRB- -LRB- punct
 |           |   +-- D NNP dep
 |           |   +-- -RRB- -RRB- punct
 |           +-- constraints NNS dobj
 |           |   +-- the DT det
 |           |   +-- of IN prep
 |           |       +-- D NNP pobj
 |           +-- in IN prep
 |               +-- not RB neg
 |               +-- already RB advmod
 |               +-- Di.e NNP pobj
 +-- . . punct

51
Input: constraint c2 .
Parse:
constraint NN ROOT
 +-- c2 CD dep
 +-- . . punct

52
Input: It follows that OPT -LRB- P -RRB- = OPT -LRB- D -RRB- ? OPT -LRB- D -RRB- = OPT -LRB- P -RRB- , and so vOP T -LRB- P -RRB- is provably an optimal solution for P , even though P is contains a only strict subset of the columns of P .
Parse:
follows VBZ ROOT
 +-- It PRP nsubj
 +-- solution NN ccomp
 |   +-- that IN mark
 |   +-- OPT NNP nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- P NN dep
 |   |   +-- -RRB- -RRB- punct
 |   |   +-- = NFP punct
 |   |   +-- OPT NNP conj
 |   |   |   +-- P NNP appos
 |   |   |       +-- -LRB- -LRB- punct
 |   |   |       +-- -RRB- -RRB- punct
 |   |   +-- ? , punct
 |   |   +-- = SYM cc
 |   |   +-- , , punct
 |   |   +-- and CC cc
 |   |   +-- T NNP conj
 |   |       +-- so RB advmod
 |   |       +-- vOP NNP nn
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- P NN dep
 |   |       +-- -RRB- -RRB- punct
 |   +-- is VBZ cop
 |   +-- provably RB advmod
 |   +-- an DT det
 |   +-- optimal JJ amod
 |   +-- for IN prep
 |   |   +-- P NN pobj
 |   +-- , , punct
 |   +-- contains VBZ advcl
 |       +-- even RB advmod
 |       +-- though IN mark
 |       +-- P NN nsubjpass
 |       +-- is VBZ auxpass
 |       +-- subset NN dobj
 |           +-- a DT det
 |           +-- only JJ amod
 |           +-- strict JJ amod
 |           +-- of IN prep
 |               +-- columns NNS pobj
 |                   +-- the DT det
 |                   +-- of IN prep
 |                       +-- P NN pobj
 +-- . . punct

53
Input: Of course , it may turn out -LRB- unfortunately -RRB- that vOP T -LRB- D -RRB- is not feasible for D .
Parse:
turn VB ROOT
 +-- course RB advmod
 |   +-- Of RB advmod
 +-- , , punct
 +-- it PRP nsubj
 +-- may MD aux
 +-- out RP prt
 +-- -LRB- -LRB- punct
 +-- unfortunately RB advmod
 +-- -RRB- -RRB- punct
 +-- feasible JJ ccomp
 |   +-- that IN mark
 |   +-- T NNP nsubj
 |   |   +-- vOP NNP nn
 |   |   +-- D NNP appos
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- -RRB- -RRB- punct
 |   +-- is VBZ cop
 |   +-- not RB neg
 |   +-- for IN prep
 |       +-- D NNP pobj
 +-- . . punct

54
Input: This can happen above if vOP T -LRB- D -RRB- = v1 = 2 , v2 = 0 , v3 = 0 , v4 = 2 .
Parse:
happen VB ROOT
 +-- This DT nsubj
 +-- can MD aux
 +-- above RB advmod
 +-- 2 CD advcl
 |   +-- if IN mark
 |   +-- T NNP nsubjpass
 |   |   +-- vOP NNP nn
 |   |   +-- D NNP appos
 |   |   |   +-- -LRB- -LRB- punct
 |   |   |   +-- -RRB- -RRB- punct
 |   |   +-- = SYM punct
 |   +-- v1 CD num
 |   +-- = SYM dep
 |   +-- v2 CD number
 |   +-- 0 CD dep
 |   +-- v3 CD dep
 |   +-- , , punct
 |   +-- v4 CD dep
 +-- . . punct

55
Input: Although we can still see that OPT -LRB- D -RRB- = OPT -LRB- D -RRB- , in general we can not prove this because D and P are too large to solve .
Parse:
see VB ROOT
 +-- Although IN mark
 +-- we PRP nsubj
 +-- can MD aux
 +-- still RB advmod
 +-- prove VB ccomp
 |   +-- that IN mark
 |   +-- OPT NNP nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- D NNP dep
 |   |   +-- -RRB- -RRB- punct
 |   |   +-- = NFP cc
 |   |   +-- D NNP conj
 |   |       +-- OPT NNP nn
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- -RRB- -RRB- punct
 |   +-- , , punct
 |   +-- in IN prep
 |   |   +-- general JJ pobj
 |   +-- we PRP nsubj
 |   +-- can MD aux
 |   +-- not RB neg
 |   +-- this DT dobj
 |   +-- large JJ advcl
 |       +-- because IN mark
 |       +-- D NNP nsubj
 |       |   +-- and CC cc
 |       |   +-- P EX conj
 |       +-- are VBP cop
 |       +-- too RB advmod
 |       +-- solve VB xcomp
 |           +-- to TO aux
 +-- . . punct

56
Input: Instead , because constraint c2 is violated , we add column c2 to P , update D , and repeat .
Parse:
add VBP ROOT
 +-- Instead RB advmod
 +-- , , punct
 +-- violated VBN advcl
 |   +-- because IN mark
 |   +-- c2 CD nsubjpass
 |   |   +-- constraint NN amod
 |   +-- is VBZ auxpass
 +-- we PRP nsubj
 +-- c2 CD dobj
 |   +-- column NN nn
 +-- P VB xcomp
 |   +-- to IN aux
 |   +-- , , punct
 |   +-- update VB conj
 |   |   +-- D NNP dobj
 |   +-- and CC cc
 |   +-- repeat VB conj
 +-- . . punct

57
Input: The problem of finding a violated constraint is called the pricing problem .
Parse:
called VBN ROOT
 +-- problem NN nsubjpass
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- finding VBG pcomp
 |           +-- constraint NN dobj
 |               +-- a DT det
 |               +-- violated VBN amod
 +-- is VBZ auxpass
 +-- problem NN xcomp
 |   +-- the DT det
 |   +-- pricing NN nn
 +-- . . punct

58
Input: Here , the price of a column -LRB- cycle in our setting -RRB- is the difference between its weight , and the dual value sum of the cycle '' s vertices .
Parse:
difference NN ROOT
 +-- Here RB advmod
 +-- , , punct
 +-- price NN nsubj
 |   +-- the DT det
 |   +-- of IN prep
 |       +-- column NN pobj
 |           +-- a DT det
 |           +-- -LRB- -LRB- punct
 |           +-- cycle NN dep
 |           |   +-- in IN prep
 |           |       +-- setting NN pobj
 |           |           +-- our PRP$ poss
 |           +-- -RRB- -RRB- punct
 +-- is VBZ cop
 +-- the DT det
 +-- between IN prep
 |   +-- weight NN pobj
 |       +-- its PRP$ poss
 |       +-- , , punct
 |       +-- and CC cc
 |       +-- vertices NNS conj
 |           +-- sum NN poss
 |               +-- the DT det
 |               +-- value NN nn
 |               |   +-- dual JJ amod
 |               +-- of IN prep
 |               |   +-- cycle NN pobj
 |               |       +-- the DT det
 |               +-- '' '' punct
 |               +-- s POS possessive
 +-- . . punct

59
Input: If any column of P has a positive price , its corresponding constraint is violated and we have not yet proven optimality .
Parse:
violated VBN ROOT
 +-- has VBZ advcl
 |   +-- If IN mark
 |   +-- column NN nsubj
 |   |   +-- any DT det
 |   |   +-- of IN prep
 |   |       +-- P NN pobj
 |   +-- price NN dobj
 |       +-- a DT det
 |       +-- positive JJ amod
 +-- , , punct
 +-- constraint NN nsubjpass
 |   +-- its PRP$ poss
 |   +-- corresponding VBG amod
 +-- is VBZ auxpass
 +-- and CC cc
 +-- proven VBN conj
 |   +-- we PRP nsubj
 |   +-- have VBP aux
 |   +-- not RB neg
 |   +-- yet RB advmod
 |   +-- optimality NN dobj
 +-- . . punct

60
Input: In this case , we must continue generating columns to add to P .
Parse:
continue VB ROOT
 +-- In IN prep
 |   +-- case NN pobj
 |       +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- must MD aux
 +-- generating VBG xcomp
 |   +-- columns NNS dobj
 |   +-- add VB xcomp
 |       +-- to TO aux
 |       +-- to IN prep
 |           +-- P NN pobj
 +-- . . punct

61
Input: 5.2.1 Pricing Problem For smaller instances , we can maintain an explicit collection of all feasible cycles .
Parse:
maintain VB ROOT
 +-- 5.2.1 LS dep
 +-- Pricing VBG partmod
 |   +-- Problem NN dobj
 |   +-- For IN prep
 |       +-- instances NNS pobj
 |           +-- smaller JJR amod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- collection NN dobj
 |   +-- an DT det
 |   +-- explicit JJ amod
 |   +-- of IN prep
 |       +-- cycles NNS pobj
 |           +-- all DT det
 |           +-- feasible JJ amod
 +-- . . punct

62
Input: This makes the pricing problem easy and efficient to solve
Parse:
makes VBZ ROOT
 +-- This DT nsubj
 +-- easy JJ xcomp
     +-- problem NN nsubj
     |   +-- the DT det
     |   +-- pricing NN nn
     +-- and CC cc
     +-- efficient JJ conj
     +-- solve VB ccomp
         +-- to TO aux

63
Input: We can even find cycles with the most positive price , which are the ones most likely to improve the objective value of restricted LP -LRB- 1 -RRB- .
Parse:
find VB ROOT
 +-- We PRP nsubj
 +-- can MD aux
 +-- even RB advmod
 +-- cycles NNS dobj
 |   +-- with IN prep
 |       +-- price NN pobj
 |           +-- the DT det
 |           +-- positive JJ amod
 |           |   +-- most RBS advmod
 |           +-- , , punct
 |           +-- ones NNS rcmod
 |               +-- which WDT nsubj
 |               +-- are VBP cop
 |               +-- the DT det
 |               +-- likely JJ amod
 |                   +-- most RBS advmod
 |                   +-- improve VB xcomp
 |                       +-- to TO aux
 |                       +-- value NN dobj
 |                           +-- the DT det
 |                           +-- objective JJ amod
 |                           +-- of IN prep
 |                               +-- LP NNP pobj
 |                                   +-- restricted VBN amod
 |                                   +-- -LRB- -LRB- punct
 |                                   +-- 1 CD num
 |                                   +-- -RRB- -RRB- punct
 +-- . . punct

64
Input: This approach does not scale however .
Parse:
scale VB ROOT
 +-- approach NN nsubj
 |   +-- This DT det
 +-- does VBZ aux
 +-- not RB neg
 +-- however RB advmod
 +-- . . punct

65
Input: A market with 5000 patients can have as many as 400 million cycles of length at most 3 -LRB- see Table 2 -RRB- .
Parse:
have VB ROOT
 +-- market NN nsubj
 |   +-- A DT det
 |   +-- with IN prep
 |       +-- patients NNS pobj
 |           +-- 5000 CD num
 +-- can MD aux
 +-- cycles NNS dobj
 |   +-- million CD num
 |   |   +-- as RB quantmod
 |   |   +-- many JJ quantmod
 |   |   +-- as IN quantmod
 |   |   +-- 400 CD number
 |   +-- of IN prep
 |       +-- length NN pobj
 +-- at IN prep
 |   +-- 3 CD pobj
 |       +-- most RBS amod
 +-- see VB dep
 |   +-- -LRB- -LRB- punct
 |   +-- 2 CD dobj
 |   |   +-- Table JJ amod
 |   +-- -RRB- -RRB- punct
 +-- . . punct

66
Input: This is too many cycles to keep in memory .
Parse:
cycles NNS ROOT
 +-- This DT nsubj
 +-- is VBZ cop
 +-- many JJ amod
 |   +-- too RB advmod
 +-- keep VB infmod
 |   +-- to TO aux
 |   +-- in IN prep
 |       +-- memory NN pobj
 +-- . . punct

67
Input: Hence , for larger instances , we have to generate feasible cycles while looking for one with a positive price .
Parse:
have VBP ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- for IN prep
 |   +-- instances NNS pobj
 |       +-- larger JJR amod
 +-- we PRP nsubj
 +-- generate VB xcomp
 |   +-- to TO aux
 |   +-- cycles NNS dobj
 |   |   +-- feasible JJ amod
 |   +-- looking VBG advcl
 |       +-- while IN mark
 |       +-- for IN prep
 |           +-- one CD pobj
 |               +-- with IN prep
 |                   +-- price NN pobj
 |                       +-- a DT det
 |                       +-- positive JJ amod
 +-- . . punct

68
Input: We do this using a depth first search algorithm on the market graph -LRB- see Figure 1 -RRB- .
Parse:
do VBP ROOT
 +-- We PRP nsubj
 +-- this DT dobj
 +-- using VBG xcomp
 |   +-- algorithm NN dobj
 |       +-- a DT det
 |       +-- depth NN amod
 |       +-- first JJ amod
 |       +-- search NN nn
 |       +-- on IN prep
 |       |   +-- graph NN pobj
 |       |       +-- the DT det
 |       |       +-- market NN nn
 |       +-- see VB dep
 |           +-- -LRB- -LRB- punct
 |           +-- Figure NN dobj
 |           |   +-- 1 CD num
 |           +-- -RRB- -RRB- punct
 +-- . . punct

69
Input: In order to make this search faster , we explore vertices in non decreasing value order , as these vertices are more likely to belong to cycles with positive weight .
Parse:
explore VBP ROOT
 +-- In IN prep
 |   +-- order NN pobj
 |       +-- make VB infmod
 |           +-- to TO aux
 |           +-- faster RBR xcomp
 |               +-- search NN nsubj
 |                   +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- vertices NNS dobj
 |   +-- in IN prep
 |       +-- order NN pobj
 |           +-- decreasing VBG amod
 |           |   +-- non FW dep
 |           +-- value NN nn
 +-- likely JJ advcl
 |   +-- as IN mark
 |   +-- vertices NNS nsubj
 |   |   +-- these DT det
 |   +-- are VBP cop
 |   +-- more RBR advmod
 |   +-- belong VB xcomp
 |       +-- to TO aux
 |       +-- to IN prep
 |       |   +-- cycles NNS pobj
 |       +-- with IN prep
 |           +-- weight NN pobj
 |               +-- positive JJ amod
 +-- . . punct

70
Input: We also use several pruning rules to determine if the current search path can lead to a positive weight cycle .
Parse:
use VBP ROOT
 +-- We PRP nsubj
 +-- also RB advmod
 +-- rules NNS dobj
 |   +-- several JJ amod
 |   +-- pruning NN nn
 +-- determine VB xcomp
 |   +-- to TO aux
 |   +-- lead VB advcl
 |       +-- if IN mark
 |       +-- path NN nsubj
 |       |   +-- the DT det
 |       |   +-- current JJ amod
 |       |   +-- search NN nn
 |       +-- can MD aux
 |       +-- to IN prep
 |           +-- cycle NN pobj
 |               +-- a DT det
 |               +-- positive JJ amod
 |               +-- weight NN nn
 +-- . . punct

71
Input: For example , at a given vertex in the search , we can prune based on the fact that every vertex we visit from this point onwards will have value at least as great the current vertex .
Parse:
prune VB ROOT
 +-- For IN prep
 |   +-- example NN pobj
 +-- , , punct
 +-- at IN prep
 |   +-- vertex NN pobj
 |       +-- a DT det
 |       +-- given VBN amod
 |       +-- in IN prep
 |           +-- search NN pobj
 |               +-- the DT det
 +-- we PRP nsubj
 +-- can MD aux
 +-- based VBN prep
 |   +-- on IN pcomp
 |       +-- fact NN pobj
 |           +-- the DT det
 |           +-- have VB ccomp
 |               +-- that IN mark
 |               +-- vertex NN nsubj
 |               |   +-- every DT det
 |               |   +-- visit VBP rcmod
 |               |       +-- we PRP nsubj
 |               |       +-- from IN prep
 |               |           +-- point NN pobj
 |               |               +-- this DT det
 |               |               +-- onwards RB advmod
 |               +-- will MD aux
 |               +-- value NN dobj
 |               +-- least RBS advmod
 |               |   +-- at RB advmod
 |               |   +-- as IN prep
 |               |       +-- great JJ pobj
 |               +-- vertex NN dobj
 |                   +-- the DT det
 |                   +-- current JJ amod
 +-- . . punct

72
Input: Even with these pruning rules , column generation is a bottleneck .
Parse:
bottleneck NN ROOT
 +-- with IN prep
 |   +-- Even RB advmod
 |   +-- rules NNS pobj
 |       +-- these DT det
 |       +-- pruning NN nn
 +-- , , punct
 +-- generation NN nsubj
 |   +-- column NN nn
 +-- is VBZ cop
 +-- a DT det
 +-- . . punct

73
Input: Hence , we also implemented the following optimizations .
Parse:
implemented VBD ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- also RB advmod
 +-- optimizations NNS dobj
 |   +-- the DT det
 |   +-- following VBG amod
 +-- . . punct

74
Input: Whenever the search exhaustively proves that a vertex belongs to no positive price cycle , we mark the vertex and do not use it as the root of a depth first search until its dual value decreases .
Parse:
mark VBP ROOT
 +-- proves VBZ advcl
 |   +-- Whenever WRB advmod
 |   +-- search NN nsubj
 |   |   +-- the DT det
 |   +-- exhaustively RB advmod
 |   +-- belongs VBZ ccomp
 |       +-- that IN mark
 |       +-- vertex NN nsubj
 |       |   +-- a DT det
 |       +-- to IN prep
 |           +-- cycle NN pobj
 |               +-- no DT det
 |               +-- positive JJ amod
 |               +-- price NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- vertex NN dobj
 |   +-- the DT det
 +-- and CC cc
 +-- use VB conj
 |   +-- do VB aux
 |   +-- not RB neg
 |   +-- it PRP dobj
 |   +-- as IN prep
 |   |   +-- root NN pobj
 |   |       +-- the DT det
 |   |       +-- of IN prep
 |   |           +-- search NN pobj
 |   |               +-- a DT det
 |   |               +-- depth NN amod
 |   |               +-- first JJ amod
 |   +-- decreases VBZ advcl
 |       +-- until IN mark
 |       +-- value NN nsubj
 |           +-- its PRP$ poss
 |           +-- dual JJ amod
 +-- . . punct

75
Input: In this way , we avoid unnecessarily repeating our computational efforts from a previous column generation iteration .
Parse:
avoid VBP ROOT
 +-- In IN prep
 |   +-- way NN pobj
 |       +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- unnecessarily RB advmod
 +-- repeating VBG xcomp
 |   +-- efforts NNS dobj
 |   |   +-- our PRP$ poss
 |   |   +-- computational JJ amod
 |   +-- from IN prep
 |       +-- iteration NN pobj
 |           +-- a DT det
 |           +-- previous JJ amod
 |           +-- generation NN nn
 |               +-- column NN nn
 +-- . . punct

76
Input: Finally , it can sometimes be beneficial for column generation to include several positive price columns in one iteration , since it may be faster to generate a second column , once the first one is found .
Parse:
beneficial JJ ROOT
 +-- Finally RB advmod
 +-- , , punct
 +-- it PRP nsubj
 +-- can MD aux
 +-- sometimes RB advmod
 +-- be VB cop
 +-- include VB advcl
 |   +-- for IN mark
 |   +-- generation NN nsubj
 |   |   +-- column NN nn
 |   +-- to TO aux
 |   +-- columns NNS dobj
 |   |   +-- several JJ amod
 |   |   +-- positive JJ amod
 |   |   +-- price NN nn
 |   +-- in IN prep
 |   |   +-- iteration NN pobj
 |   |       +-- one CD num
 |   +-- , , punct
 |   +-- faster JJR advcl
 |       +-- since IN mark
 |       +-- it PRP nsubj
 |       +-- may MD aux
 |       +-- be VB cop
 |       +-- generate VB xcomp
 |       |   +-- to TO aux
 |       |   +-- column NN dobj
 |       |       +-- a DT det
 |       |       +-- second JJ amod
 |       +-- , , punct
 |       +-- found VBN advcl
 |           +-- once IN mark
 |           +-- one CD nsubjpass
 |           |   +-- the DT det
 |           |   +-- first JJ amod
 |           +-- is VBZ auxpass
 +-- . . punct

77
Input: However , we avoid this for the following reason .
Parse:
avoid VBP ROOT
 +-- However RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- this DT dobj
 +-- for IN prep
 |   +-- reason NN pobj
 |       +-- the DT det
 |       +-- following VBG amod
 +-- . . punct

78
Input: If we attempt to find more positive price columns than there are to be found , or if the columns are far apart in the search space , we end up having to generate and check a large part of the collection of feasible cycles .
Parse:
end VBP ROOT
 +-- attempt VBP advcl
 |   +-- If IN mark
 |   +-- we PRP nsubj
 |   +-- find VB xcomp
 |   |   +-- to TO aux
 |   |   +-- found VBN xcomp
 |   |       +-- columns NNS nsubjpass
 |   |       |   +-- more JJR amod
 |   |       |   +-- positive JJ amod
 |   |       |   +-- price NN nn
 |   |       |   +-- are VBP dep
 |   |       |       +-- than IN mark
 |   |       |       +-- there EX expl
 |   |       +-- to TO aux
 |   |       +-- be VB auxpass
 |   +-- , , punct
 |   +-- or CC cc
 |   +-- are VBP conj
 |       +-- if IN mark
 |       +-- columns NNS nsubj
 |       |   +-- the DT det
 |       +-- apart RB advmod
 |       |   +-- far RB advmod
 |       +-- in IN prep
 |           +-- space NN pobj
 |               +-- the DT det
 |               +-- search NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- up RP prt
 +-- having VBG xcomp
 |   +-- generate VB xcomp
 |       +-- to TO aux
 |       +-- and CC cc
 |       +-- check VB conj
 |       +-- part NN dobj
 |           +-- a DT det
 |           +-- large JJ amod
 |           +-- of IN prep
 |               +-- collection NN pobj
 |                   +-- the DT det
 |                   +-- of IN prep
 |                       +-- cycles NNS pobj
 |                           +-- feasible JJ amod
 +-- . . punct

79
Input: In our experiments , we have seen this occur in markets with hundreds of millions of cycles , resulting in prohibitively expensive computation costs .
Parse:
seen VBN ROOT
 +-- In IN prep
 |   +-- experiments NNS pobj
 |       +-- our PRP$ poss
 +-- , , punct
 +-- we PRP nsubj
 +-- have VBP aux
 +-- occur VB ccomp
 |   +-- this DT nsubj
 |   +-- in IN prep
 |   |   +-- markets NNS pobj
 |   +-- with IN prep
 |       +-- hundreds NNS pobj
 |           +-- of IN prep
 |           |   +-- millions NNS pobj
 |           |       +-- of IN prep
 |           |           +-- cycles NNS pobj
 |           +-- , , punct
 |           +-- resulting VBG partmod
 |               +-- in IN prep
 |                   +-- costs NNS pobj
 |                       +-- expensive JJ amod
 |                       |   +-- prohibitively RB advmod
 |                       +-- computation NN nn
 +-- . . punct

80
Input: 5.2.2 Column Seeding Even if there is only a small gap to the master LP relaxation , column generation requires many iterations to improve the objective value of the restricted LP .
Parse:
requires VBZ ROOT
 +-- 5.2.2 LS dep
 +-- Column NNP nsubj
 +-- Seeding VBG partmod
 |   +-- is VBZ advcl
 |       +-- Even RB advmod
 |       +-- if IN mark
 |       +-- there EX expl
 |       +-- gap NN dep
 |           +-- only RB advmod
 |           +-- a DT det
 |           +-- small JJ amod
 |           +-- to IN prep
 |               +-- relaxation NN pobj
 |                   +-- the DT det
 |                   +-- master NN nn
 |                   +-- LP NN nn
 +-- , , punct
 +-- generation NN nsubj
 |   +-- column NN nn
 +-- iterations NNS dobj
 |   +-- many JJ amod
 +-- improve VB xcomp
 |   +-- to TO aux
 |   +-- value NN dobj
 |       +-- the DT det
 |       +-- objective JJ amod
 |       +-- of IN prep
 |           +-- LP NN pobj
 |               +-- the DT det
 |               +-- restricted VBN amod
 +-- . . punct

81
Input: Each of these 300 iterations is expensive , as we must solve the pricing problem , and re solve the restricted LP .
Parse:
expensive JJ ROOT
 +-- Each DT nsubj
 |   +-- of IN prep
 |       +-- iterations NNS pobj
 |           +-- these DT det
 |           +-- 300 CD num
 +-- is VBZ cop
 +-- , , punct
 +-- solve VB advcl
 |   +-- as IN mark
 |   +-- we PRP nsubj
 |   +-- must MD aux
 |   +-- problem NN dobj
 |   |   +-- the DT det
 |   |   +-- pricing NN nn
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- re IN advmod
 |   +-- solve VB conj
 |       +-- LP NN dobj
 |           +-- the DT det
 |           +-- restricted VBN amod
 +-- . . punct

82
Input: Hence , although we could begin with no columns in the restricted LP , it is much faster to seed the LP with enough columns that the optimal objective value is not too far from the master LP .
Parse:
faster JJR ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- begin VB advcl
 |   +-- although IN mark
 |   +-- we PRP nsubj
 |   +-- could MD aux
 |   +-- with IN prep
 |   |   +-- columns NNS pobj
 |   |       +-- no DT det
 |   +-- in IN prep
 |       +-- LP NN pobj
 |           +-- the DT det
 |           +-- restricted VBN amod
 +-- it PRP nsubj
 +-- is VBZ cop
 +-- much RB advmod
 +-- seed VB xcomp
 |   +-- to TO aux
 |   +-- LP NN dobj
 |   |   +-- the DT det
 |   +-- with IN prep
 |       +-- columns NNS pobj
 |           +-- enough JJ amod
 |           +-- is VBZ ccomp
 |               +-- that IN mark
 |               +-- value NN nsubj
 |               |   +-- the DT det
 |               |   +-- optimal JJ amod
 |               |   +-- objective JJ amod
 |               +-- not RB neg
 |               +-- far RB advmod
 |                   +-- too RB advmod
 |                   +-- from IN prep
 |                       +-- LP NN pobj
 |                           +-- the DT det
 |                           +-- master NN nn
 +-- . . punct

83
Input: Of course , we can not include so many columns that we run out of memory .
Parse:
include VB ROOT
 +-- course RB advmod
 |   +-- Of RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- not RB neg
 +-- columns NNS dobj
 |   +-- many JJ amod
 |   |   +-- so RB advmod
 |   +-- run VBP rcmod
 |       +-- that WDT dobj
 |       +-- we PRP nsubj
 |       +-- out IN prep
 |           +-- of IN pcomp
 |               +-- memory NN pobj
 +-- . . punct

84
Input: We experimented with several column seeders .
Parse:
experimented VBD ROOT
 +-- We PRP nsubj
 +-- with IN prep
 |   +-- seeders NNS pobj
 |       +-- several JJ amod
 |       +-- column NN nn
 +-- . . punct

85
Input: In one class of seeder , we use a heuristic to find an exchange , and then add the cycles of that exchange to the initial restricted LP .
Parse:
use VBP ROOT
 +-- In IN prep
 |   +-- class NN pobj
 |       +-- one CD num
 |       +-- of IN prep
 |           +-- seeder NN pobj
 +-- , , punct
 +-- we PRP nsubj
 +-- heuristic JJ dobj
 |   +-- a DT det
 +-- find VB xcomp
 |   +-- to TO aux
 |   +-- exchange NN dobj
 |   |   +-- an DT det
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- then RB advmod
 |   +-- add VB conj
 |       +-- cycles NNS dobj
 |       |   +-- the DT det
 |       |   +-- of IN prep
 |       |       +-- exchange NN pobj
 |       |           +-- that DT det
 |       +-- to IN prep
 |           +-- LP NNP pobj
 |               +-- the DT det
 |               +-- initial JJ amod
 |               +-- restricted VBN amod
 +-- . . punct

86
Input: We implemented two heuristics .
Parse:
implemented VBD ROOT
 +-- We PRP nsubj
 +-- heuristics NNS dobj
 |   +-- two CD num
 +-- . . punct

87
Input: The first is a greedy algorithm
Parse:
algorithm NN ROOT
 +-- first JJ nsubj
 |   +-- The DT det
 +-- is VBZ cop
 +-- a DT det
 +-- greedy JJ amod

88
Input: The other heuristic uses specialized maximum weight matching code -LRB- 16 -RRB- to find an optimal cover by length 2 cycles .
Parse:
specialized VBN ROOT
 +-- uses NNS nsubj
 |   +-- The DT det
 |   +-- other JJ amod
 |   +-- heuristic JJ amod
 +-- code NN dobj
 |   +-- maximum JJ amod
 |   +-- matching VBG nn
 |   |   +-- weight NN nn
 |   +-- 16 CD appos
 |       +-- -LRB- -LRB- punct
 |       +-- -RRB- -RRB- punct
 +-- find VB xcomp
 |   +-- to TO aux
 |   +-- cover NN dobj
 |   |   +-- an DT det
 |   |   +-- optimal JJ amod
 |   +-- by IN prep
 |       +-- cycles NNS pobj
 |           +-- length NN nn
 |               +-- 2 CD num
 +-- . . punct

89
Input: These heuristics perform extremely well , especially taking into account the fact that they only add a small number of columns .
Parse:
perform VBP ROOT
 +-- heuristics NNS nsubj
 |   +-- These DT det
 +-- well RB advmod
 |   +-- extremely RB advmod
 +-- , , punct
 +-- taking VBG xcomp
 |   +-- especially RB advmod
 |   +-- into IN prep
 |   |   +-- account NN pobj
 |   +-- fact NN dobj
 |       +-- the DT det
 |       +-- add VBP ccomp
 |           +-- that IN mark
 |           +-- they PRP nsubj
 |           +-- only RB advmod
 |           +-- number NN dobj
 |               +-- a DT det
 |               +-- small JJ amod
 |               +-- of IN prep
 |                   +-- columns NNS pobj
 +-- . . punct

90
Input: For example , Table 1 shows that an optimal cover by length 2 cycles has almost as much weight as the exchange with unrestricted cycle size .
Parse:
shows VBZ ROOT
 +-- For IN prep
 |   +-- example NN pobj
 +-- , , punct
 +-- Table NNP nsubj
 |   +-- 1 CD num
 +-- has VBZ ccomp
 |   +-- that IN mark
 |   +-- cover NN nsubj
 |   |   +-- an DT det
 |   |   +-- optimal JJ amod
 |   |   +-- by IN prep
 |   |       +-- cycles NNS pobj
 |   |           +-- length NN nn
 |   |           +-- 2 CD num
 |   +-- weight NN dobj
 |       +-- much JJ amod
 |       |   +-- almost RB advmod
 |       |   +-- as RB advmod
 |       +-- as IN prep
 |           +-- exchange NN pobj
 |               +-- the DT det
 |               +-- with IN prep
 |                   +-- size NN pobj
 |                       +-- unrestricted JJ amod
 |                       +-- cycle NN nn
 +-- . . punct

91
Input: However , we have enough memory to include hundreds of thousands of additional columns and thereby get closer still to the upper bound .
Parse:
have VBP ROOT
 +-- However RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- memory NN dobj
 |   +-- enough JJ amod
 +-- include VB xcomp
 |   +-- to TO aux
 |   +-- thousands NNS dobj
 |   |   +-- hundreds NNS dep
 |   |   +-- of IN quantmod
 |   |   +-- of IN prep
 |   |       +-- columns NNS pobj
 |   |           +-- additional JJ amod
 |   +-- and CC cc
 |   +-- thereby RB advmod
 |   +-- get VB conj
 |       +-- still RB advmod
 |       |   +-- closer JJR advmod
 |       +-- to IN prep
 |           +-- bound VBN pobj
 |               +-- the DT det
 |               +-- upper JJ amod
 +-- . . punct

92
Input: Our best column seeder constructs a random collection of feasible cycles .
Parse:
constructs VBZ ROOT
 +-- seeder NN nsubj
 |   +-- Our PRP$ poss
 |   +-- best JJS amod
 |   +-- column NN nn
 +-- collection NN dobj
 |   +-- a DT det
 |   +-- random JJ amod
 |   +-- of IN prep
 |       +-- cycles NNS pobj
 |           +-- feasible JJ amod
 +-- . . punct

93
Input: Since a market with 5000 patients can have as many as 400 million feasible cycles , it takes too long to generate and traverse all feasible cycles , and so we do not include a uniformly random collection .
Parse:
takes VBZ ROOT
 +-- have VB advcl
 |   +-- Since IN mark
 |   +-- market NN nsubj
 |   |   +-- a DT det
 |   |   +-- with IN prep
 |   |       +-- patients NNS pobj
 |   |           +-- 5000 CD num
 |   +-- can MD aux
 |   +-- cycles NNS dobj
 |       +-- million CD num
 |       |   +-- as RB quantmod
 |       |   +-- many JJ quantmod
 |       |   +-- as IN quantmod
 |       |   +-- 400 CD number
 |       +-- feasible JJ amod
 +-- , , punct
 +-- it PRP nsubj
 +-- long JJ advmod
 |   +-- too RB advmod
 +-- generate VB xcomp
 |   +-- to TO aux
 |   +-- and CC cc
 |   +-- traverse VB conj
 |   +-- cycles NNS dobj
 |       +-- all DT det
 |       +-- feasible JJ amod
 +-- and CC cc
 +-- include VB conj
 |   +-- so RB advmod
 |   +-- we PRP nsubj
 |   +-- do VBP aux
 |   +-- not RB neg
 |   +-- collection NN dobj
 |       +-- a DT det
 |       +-- random JJ amod
 |           +-- uniformly RB advmod
 +-- . . punct

94
Input: Instead , we perform a random walk on the market graph -LRB- see , for example , Figure 1 -RRB- , in which , after each step of the walk , we test whether there is an edge back onto our path that forms a feasible cycle .
Parse:
perform VBP ROOT
 +-- Instead RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- walk NN dobj
 |   +-- a DT det
 |   +-- random JJ amod
 |   +-- on IN prep
 |       +-- graph NN pobj
 |           +-- the DT det
 |           +-- market NN nn
 +-- see VB parataxis
 |   +-- -LRB- -LRB- punct
 |   +-- , , punct
 |   +-- for IN prep
 |   |   +-- example NN pobj
 |   +-- Figure NNP dobj
 |   |   +-- 1 CD num
 |   +-- -RRB- -RRB- punct
 +-- test VBP ccomp
 |   +-- in IN prep
 |   |   +-- which WDT pobj
 |   +-- , , punct
 |   +-- after IN prep
 |   |   +-- step NN pobj
 |   |       +-- each DT det
 |   |       +-- of IN prep
 |   |           +-- walk NN pobj
 |   |               +-- the DT det
 |   +-- we PRP nsubj
 |   +-- is VBZ ccomp
 |       +-- whether IN mark
 |       +-- there EX expl
 |       +-- edge NN nsubj
 |       |   +-- an DT det
 |       +-- back RB advmod
 |           +-- onto IN prep
 |               +-- path NN pobj
 |                   +-- our PRP$ poss
 |                   +-- forms VBZ rcmod
 |                       +-- that WDT nsubj
 |                       +-- cycle NN dobj
 |                           +-- a DT det
 |                           +-- feasible JJ amod
 +-- . . punct

95
Input: If we find a cycle , it is included in the restricted LP , and we start a new walk from a random vertex .
Parse:
included VBN ROOT
 +-- find VBP advcl
 |   +-- If IN mark
 |   +-- we PRP nsubj
 |   +-- cycle NN dobj
 |       +-- a DT det
 +-- , , punct
 +-- it PRP nsubjpass
 +-- is VBZ auxpass
 +-- in IN prep
 |   +-- LP NN pobj
 |       +-- the DT det
 |       +-- restricted VBN amod
 +-- and CC cc
 +-- start VBP conj
 |   +-- we PRP nsubj
 |   +-- walk NN dobj
 |       +-- a DT det
 |       +-- new JJ amod
 |       +-- from IN prep
 |           +-- vertex NN pobj
 |               +-- a DT det
 |               +-- random JJ amod
 +-- . . punct

96
Input: In our experiments -LRB- see Section 6 -RRB- , we use this algorithm to seed the LP with 400 , 000 cycles .
Parse:
use VBP ROOT
 +-- In IN prep
 |   +-- experiments NNS pobj
 |       +-- our PRP$ poss
 +-- see VB parataxis
 |   +-- -LRB- -LRB- punct
 |   +-- Section NN dobj
 |   |   +-- 6 CD num
 |   +-- -RRB- -RRB- punct
 +-- , , punct
 +-- we PRP nsubj
 +-- algorithm NN dobj
 |   +-- this DT det
 +-- seed VB xcomp
 |   +-- to TO aux
 |   +-- LP NN dobj
 |   |   +-- the DT det
 |   +-- with IN prep
 |       +-- 400 CD pobj
 |           +-- , , punct
 |           +-- cycles NNS appos
 |               +-- 000 CD num
 +-- . . punct

97
Input: This last approach outperforms the heuristic seeders described above .
Parse:
outperforms VBZ ROOT
 +-- approach NN nsubj
 |   +-- This DT det
 |   +-- last JJ amod
 +-- seeders NNS dobj
 |   +-- the DT det
 |   +-- heuristic JJ amod
 |   +-- described VBN partmod
 |       +-- above RB advmod
 +-- . . punct

98
Input: However , in our algorithm , we use a combination that takes the union of all columns from all three seeders .
Parse:
use VBP ROOT
 +-- However RB advmod
 +-- , , punct
 +-- in IN prep
 |   +-- algorithm NN pobj
 |       +-- our PRP$ poss
 +-- we PRP nsubj
 +-- combination NN dobj
 |   +-- a DT det
 |   +-- takes VBZ rcmod
 |       +-- that WDT nsubj
 |       +-- union NN dobj
 |       |   +-- the DT det
 |       |   +-- of IN prep
 |       |       +-- columns NNS pobj
 |       |           +-- all DT det
 |       +-- from IN prep
 |           +-- seeders NNS pobj
 |               +-- all DT det
 |               +-- three CD num
 +-- . . punct

99
Input: In Figure 6 , we compare the performance of the combination seeder against the combination without the random collection seeder .
Parse:
compare VBP ROOT
 +-- In IN prep
 |   +-- Figure NN pobj
 |       +-- 6 CD num
 +-- , , punct
 +-- we PRP nsubj
 +-- performance NN dobj
 |   +-- the DT det
 |   +-- of IN prep
 |   |   +-- seeder NN pobj
 |   |       +-- the DT det
 |   |       +-- combination NN nn
 |   +-- against IN prep
 |       +-- combination NN pobj
 |           +-- the DT det
 |           +-- without IN prep
 |               +-- seeder NN pobj
 |                   +-- the DT det
 |                   +-- collection NN nn
 |                       +-- random JJ amod
 +-- . . punct

100
Input: We do not plot the performance of the algorithm without any seeder at all , because it can take hours to clear markets we can otherwise clear in a few minutes .
Parse:
plot VB ROOT
 +-- We PRP nsubj
 +-- do VBP aux
 +-- not RB neg
 +-- performance NN dobj
 |   +-- the DT det
 |   +-- of IN prep
 |       +-- algorithm NN pobj
 |           +-- the DT det
 +-- without IN prep
 |   +-- seeder NN pobj
 |       +-- any DT det
 +-- all RB advmod
 |   +-- at RB advmod
 +-- , , punct
 +-- take VB advcl
 |   +-- because IN mark
 |   +-- it PRP nsubj
 |   +-- can MD aux
 |   +-- hours NNS dobj
 |   +-- to TO prep
 |       +-- markets NNS pobj
 |           +-- clear JJ amod
 |           +-- clear JJ rcmod
 |               +-- we PRP nsubj
 |               +-- can MD aux
 |               +-- otherwise RB advmod
 |               +-- in IN prep
 |                   +-- minutes NNS pobj
 |                       +-- a DT det
 |                       +-- few JJ amod
 +-- . . punct

101
Input: 5.2.3 Proving Optimality Recall that our aim is to find an optimal solution to the master LP relaxation .
Parse:
Proving VBG ROOT
 +-- 5.2.3 LS nsubj
 +-- Recall NNP dobj
 |   +-- Optimality NNP nn
 +-- is VBZ ccomp
 |   +-- that IN mark
 |   +-- aim NN nsubj
 |   |   +-- our PRP$ poss
 |   +-- find VB xcomp
 |       +-- to TO aux
 |       +-- solution NN dobj
 |           +-- an DT det
 |           +-- optimal JJ amod
 |           +-- to IN prep
 |               +-- relaxation NN pobj
 |                   +-- the DT det
 |                   +-- master NN nn
 |                   +-- LP NN nn
 +-- . . punct

102
Input: Using column generation , we can prove that a restricted primal solution is optimal once all columns have non positive prices .
Parse:
prove VB ROOT
 +-- Using VBG partmod
 |   +-- generation NN dobj
 |       +-- column NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- optimal JJ ccomp
 |   +-- that IN mark
 |   +-- solution NN nsubj
 |   |   +-- a DT det
 |   |   +-- restricted VBN amod
 |   |   +-- primal JJ amod
 |   +-- is VBZ cop
 |   +-- have VBP advcl
 |       +-- once RB mark
 |       +-- columns NNS nsubj
 |       |   +-- all DT det
 |       +-- prices NNS dobj
 |           +-- positive JJ amod
 |               +-- non AFX npadvmod
 +-- . . punct

103
Input: Unfortunately though , our clearing problem has the so called tailing off effect -LRB- 1 , Section 6.3 -RRB- , in which , even though the restricted primal is optimal in hindsight , a large number of additional iterations are required in order to prove optimality -LRB- i.e. , eliminate all positive price columns -RRB- .
Parse:
has VBZ ROOT
 +-- though RB advmod
 |   +-- Unfortunately RB advmod
 +-- , , punct
 +-- problem NN nsubj
 |   +-- our PRP$ poss
 |   +-- clearing NN nn
 +-- effect NN dobj
 |   +-- the DT det
 |   +-- called VBN amod
 |   |   +-- so RB advmod
 |   +-- tailing VBG amod
 |   |   +-- off RP prt
 |   +-- -LRB- -LRB- punct
 |   +-- 1 CD dep
 |   |   +-- , , punct
 |   |   +-- Section NN appos
 |   |       +-- 6.3 CD num
 |   +-- -RRB- -RRB- punct
 |   +-- , , punct
 |   +-- required VBN rcmod
 |       +-- in IN prep
 |       |   +-- order NN pobj
 |       |       +-- prove VB infmod
 |       |           +-- to TO aux
 |       |           +-- optimality NN dobj
 |       |               +-- eliminate VB dep
 |       |                   +-- -LRB- -LRB- punct
 |       |                   +-- i.e. FW advmod
 |       |                   +-- , , punct
 |       |                   +-- columns NNS dobj
 |       |                   |   +-- all DT det
 |       |                   |   +-- positive JJ amod
 |       |                   |   +-- price NN nn
 |       |                   +-- -RRB- -RRB- punct
 |       +-- , , punct
 |       +-- optimal JJ advcl
 |       |   +-- even RB advmod
 |       |   +-- though IN mark
 |       |   +-- primal NN nsubj
 |       |   |   +-- the DT det
 |       |   |   +-- restricted VBN amod
 |       |   +-- is VBZ cop
 |       |   +-- in IN prep
 |       |       +-- hindsight NN pobj
 |       +-- number NN nsubjpass
 |       |   +-- a DT det
 |       |   +-- large JJ amod
 |       |   +-- of IN prep
 |       |       +-- iterations NNS pobj
 |       |           +-- additional JJ amod
 |       +-- are VBP auxpass
 +-- . . punct

104
Input: There is no good general solution to the tailing off effect .
Parse:
is VBZ ROOT
 +-- There EX expl
 +-- solution NN nsubj
 |   +-- no DT det
 |   +-- good JJ amod
 |   +-- general JJ amod
 |   +-- to IN prep
 |       +-- effect NN pobj
 |           +-- the DT det
 |           +-- tailing NN amod
 |               +-- off RP prt
 +-- . . punct

105
Input: However , to mitigate this effect , we take advantage of the following problem specific observation .
Parse:
take VBP ROOT
 +-- However RB advmod
 +-- , , punct
 +-- mitigate VB advcl
 |   +-- to TO aux
 |   +-- effect NN dobj
 |       +-- this DT det
 +-- we PRP nsubj
 +-- advantage NN dobj
 +-- of IN prep
 |   +-- observation NN pobj
 |       +-- the DT det
 |       +-- following VBG amod
 |       +-- problem NN nn
 |       +-- specific JJ amod
 +-- . . punct

106
Input: Recall from Section 1.1 that , almost always , a maximum weight exchange with cycles of length at most 3 has the same weight as an unrestricted maximum weight exchange .
Parse:
Recall VB ROOT
 +-- from IN prep
 |   +-- Section NN pobj
 |       +-- 1.1 CD num
 +-- exchange NN ccomp
 |   +-- that DT mark
 |   +-- , , punct
 |   +-- always RB advmod
 |   |   +-- almost RB advmod
 |   +-- a DT det
 |   +-- maximum JJ amod
 |   +-- weight NN nn
 |   +-- with IN prep
 |   |   +-- cycles NNS pobj
 |   |       +-- of IN prep
 |   |           +-- length NN pobj
 |   +-- has VBZ rcmod
 |       +-- 3 CD nsubj
 |       |   +-- most RBS dep
 |       |       +-- at IN advmod
 |       +-- weight NN dobj
 |           +-- the DT det
 |           +-- same JJ amod
 |           +-- as IN prep
 |               +-- exchange NN pobj
 |                   +-- an DT det
 |                   +-- unrestricted JJ amod
 |                   +-- maximum JJ amod
 |                   +-- weight NN nn
 +-- . . punct

107
Input: -LRB- This does not mean that the solver for the unrestricted case will find a solution with short cycles , however. -RRB- Furthermore , the unrestricted clearing problem can be solved in polynomial time -LRB- recall Section 4 -RRB- .
Parse:
mean VB ROOT
 +-- -LRB- -LRB- punct
 +-- This DT nsubj
 +-- does VBZ aux
 +-- not RB neg
 +-- find VB ccomp
 |   +-- that IN mark
 |   +-- solver NN nsubj
 |   |   +-- the DT det
 |   |   +-- for IN prep
 |   |       +-- case NN pobj
 |   |           +-- the DT det
 |   |           +-- unrestricted JJ amod
 |   +-- will MD aux
 |   +-- solution NN dobj
 |       +-- a DT det
 |       +-- with IN prep
 |           +-- cycles NNS pobj
 |               +-- short JJ amod
 |               +-- , , punct
 |               +-- however. NN appos
 +-- -RRB- -RRB- punct
 +-- solved VBN ccomp
 |   +-- Furthermore RB advmod
 |   +-- , , punct
 |   +-- problem NN nsubjpass
 |   |   +-- the DT det
 |   |   +-- unrestricted JJ amod
 |   |   +-- clearing NN nn
 |   +-- can MD aux
 |   +-- be VB auxpass
 |   +-- in IN prep
 |   |   +-- time NN pobj
 |   |       +-- polynomial JJ amod
 |   +-- recall VB parataxis
 |       +-- -LRB- -LRB- punct
 |       +-- Section NN dobj
 |       |   +-- 4 CD num
 |       +-- -RRB- -RRB- punct
 +-- . . punct

108
Input: Hence , we can efficiently compute an upper bound on the master LP relaxation , and , whenever the restricted primal achieves this upper bound , we have proven optimality without necessarily having to eliminate all positive price columns ! In order for this to improve the running time of the overall algorithm , we need to be able to clear the unrestricted market in less time than it takes column generation to eliminate all the positive price cycles .
Parse:
compute VB ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- efficiently RB advmod
 +-- upper JJ dobj
 |   +-- an DT det
 |   +-- bound VBN partmod
 |       +-- on IN prep
 |           +-- relaxation NN pobj
 |               +-- the DT det
 |               +-- master NN nn
 |               +-- LP NNP nn
 +-- and CC cc
 +-- proven VBN conj
 |   +-- achieves VBZ advcl
 |   |   +-- whenever WRB advmod
 |   |   +-- primal JJ nsubj
 |   |   |   +-- the DT det
 |   |   |   +-- restricted VBN amod
 |   |   +-- bound VBN dobj
 |   |       +-- this DT det
 |   |       +-- upper JJ amod
 |   +-- , , punct
 |   +-- we PRP nsubj
 |   +-- have VBP aux
 |   +-- optimality NN dobj
 |   +-- without IN prep
 |   |   +-- having VBG pcomp
 |   |       +-- necessarily RB advmod
 |   |       +-- eliminate VB xcomp
 |   |           +-- to TO aux
 |   |           +-- columns NNS dobj
 |   |               +-- all DT det
 |   |               +-- positive JJ amod
 |   |               +-- price NN nn
 |   +-- ! . punct
 |   +-- need VBP parataxis
 |       +-- In IN prep
 |       |   +-- order NN pobj
 |       |       +-- improve VB infmod
 |       |           +-- for IN mark
 |       |           +-- this DT nsubj
 |       |           +-- to TO aux
 |       |           +-- time NN dobj
 |       |               +-- the DT det
 |       |               +-- running VBG nn
 |       |               +-- of IN prep
 |       |                   +-- algorithm NN pobj
 |       |                       +-- the DT det
 |       |                       +-- overall JJ amod
 |       +-- , , punct
 |       +-- we PRP nsubj
 |       +-- able JJ xcomp
 |           +-- to TO aux
 |           +-- be VB cop
 |           +-- clear VB xcomp
 |               +-- to TO aux
 |               +-- market NN dobj
 |               |   +-- the DT det
 |               |   +-- unrestricted JJ amod
 |               +-- in IN prep
 |                   +-- time NN pobj
 |                       +-- less JJR amod
 |                       +-- takes VBZ dep
 |                           +-- than IN mark
 |                           +-- it PRP nsubj
 |                           +-- generation NN dobj
 |                           |   +-- column NN nn
 |                           +-- eliminate VB xcomp
 |                               +-- to TO aux
 |                               +-- cycles NNS dobj
 |                                   +-- all PDT predet
 |                                   +-- the DT det
 |                                   +-- positive JJ amod
 |                                   +-- price NN nn
 +-- . . punct

109
Input: Even though the first problem is polynomial time solvable , this is not trivial for large instances .
Parse:
trivial JJ ROOT
 +-- solvable JJ advcl
 |   +-- Even RB advmod
 |   +-- though IN mark
 |   +-- problem NN nsubj
 |   |   +-- the DT det
 |   |   +-- first JJ amod
 |   +-- is VBZ cop
 |   +-- time NN nn
 |       +-- polynomial JJ amod
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- not RB neg
 +-- for IN prep
 |   +-- instances NNS pobj
 |       +-- large JJ amod
 +-- . . punct

110
Input: For example , for a market with 10 , 000 patients and 25 million edges , specialized maximum weight matching code -LRB- 16 -RRB- was too slow , and CPLEX ran out of memory on the edge formulation encoding from Section 4 .
Parse:
slow JJ ROOT
 +-- For IN prep
 |   +-- example NN pobj
 +-- , , punct
 +-- for IN prep
 |   +-- market NN pobj
 |       +-- a DT det
 |       +-- with IN prep
 |           +-- patients NNS pobj
 |               +-- 000 CD num
 |               |   +-- 10 CD number
 |               |   +-- , , punct
 |               +-- and CC cc
 |               +-- edges NNS conj
 |                   +-- million CD num
 |                       +-- 25 CD number
 +-- code NN nsubj
 |   +-- specialized JJ amod
 |   +-- maximum JJ amod
 |   +-- matching VBG nn
 |   |   +-- weight NN nn
 |   +-- -LRB- -LRB- punct
 |   +-- 16 CD dep
 |   +-- -RRB- -RRB- punct
 +-- was VBD cop
 +-- too RB advmod
 +-- and CC cc
 +-- ran VBD conj
 |   +-- CPLEX NNP nsubj
 |   +-- out RP prep
 |   |   +-- of IN pcomp
 |   |       +-- memory NN pobj
 |   |           +-- on IN prep
 |   |               +-- encoding VBG pobj
 |   |                   +-- the DT det
 |   |                   +-- edge NN nn
 |   |                   +-- formulation NN nn
 |   +-- from IN prep
 |       +-- Section NN pobj
 |           +-- 4 CD num
 +-- . . punct

111
Input: To make this idea work then , we used column generation to solve the edge formulation .
Parse:
used VBD ROOT
 +-- make VB advcl
 |   +-- To TO aux
 |   +-- work NN ccomp
 |       +-- idea NN nsubj
 |       |   +-- this DT det
 |       +-- then RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- generation NN dobj
 |   +-- column NN nn
 +-- solve VB xcomp
 |   +-- to TO aux
 |   +-- formulation NN dobj
 |       +-- the DT det
 |       +-- edge NN nn
 +-- . . punct

112
Input: This involves starting with a small random subset of the edges , and then adding positive price edges one by one until none remain .
Parse:
involves VBZ ROOT
 +-- This DT nsubj
 +-- starting VBG ccomp
 |   +-- with IN prep
 |   |   +-- subset NN pobj
 |   |       +-- a DT det
 |   |       +-- small JJ amod
 |   |       +-- random JJ amod
 |   |       +-- of IN prep
 |   |           +-- edges NNS pobj
 |   |               +-- the DT det
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- then RB advmod
 |   +-- adding VBG conj
 |       +-- edges NNS dobj
 |       |   +-- positive JJ amod
 |       |   +-- price NN nn
 |       +-- one CD dobj
 |       |   +-- by IN prep
 |       |       +-- one CD pobj
 |       +-- remain VBP advcl
 |           +-- until IN mark
 |           +-- none NN nsubj
 +-- . . punct

113
Input: We conduct this secondary column generation not in the original market graph G , but in the perfect matching bipartite graph of Figure 3 .
Parse:
conduct VBP ROOT
 +-- We PRP nsubj
 +-- generation NN dobj
 |   +-- this DT det
 |   +-- secondary JJ amod
 |   +-- column NN nn
 +-- in IN prep
 |   +-- not RB neg
 |   +-- G NNP pobj
 |   |   +-- the DT det
 |   |   +-- original JJ amod
 |   |   +-- graph NN nn
 |   |       +-- market NN nn
 |   +-- , , punct
 |   +-- but CC cc
 |   +-- in IN conj
 |       +-- graph NN pobj
 |           +-- the DT det
 |           +-- perfect JJ amod
 |           +-- matching NN nn
 |           +-- bipartite JJ amod
 |           +-- of IN prep
 |               +-- Figure NN pobj
 |                   +-- 3 CD num
 +-- . . punct

114
Input: We do this so that we only need to solve the LP , not the ILP , since the integrality gap in the perfect matching bipartite graph is 1 i.e .
Parse:
do VBP ROOT
 +-- We PRP nsubj
 +-- this DT dobj
 +-- need VBP advcl
 |   +-- so IN mark
 |   +-- that IN mark
 |   +-- we PRP nsubj
 |   +-- only RB advmod
 |   +-- solve VB xcomp
 |   |   +-- to TO aux
 |   |   +-- LP NN dobj
 |   |       +-- the DT det
 |   |       +-- , , punct
 |   |       +-- not RB neg
 |   |       +-- ILP NNP dep
 |   |           +-- the DT det
 |   +-- , , punct
 |   +-- i.e NN advcl
 |       +-- since IN mark
 |       +-- gap NN nsubj
 |       |   +-- the DT det
 |       |   +-- integrality NN nn
 |       |   +-- in IN prep
 |       |       +-- graph NN pobj
 |       |           +-- the DT det
 |       |           +-- perfect JJ amod
 |       |           +-- matching NN nn
 |       |           +-- bipartite JJ amod
 |       +-- is VBZ cop
 |       +-- 1 CD num
 +-- . . punct

115
Input: there always exists an integral solution that achieves the fractional upper bound .
Parse:
exists VBZ ROOT
 +-- there EX expl
 +-- always RB advmod
 +-- solution NN nsubj
 |   +-- an DT det
 |   +-- integral JJ amod
 |   +-- achieves VBZ rcmod
 |       +-- that WDT nsubj
 |       +-- upper JJ dobj
 |           +-- the DT det
 |           +-- fractional JJ amod
 |           +-- bound VBN partmod
 +-- . . punct

116
Input: The resulting speedup to the overall algorithm is dramatic , as can be seen in Figure 6 .
Parse:
dramatic JJ ROOT
 +-- speedup NN nsubj
 |   +-- The DT det
 |   +-- resulting VBG amod
 |   +-- to IN prep
 |       +-- algorithm NN pobj
 |           +-- the DT det
 |           +-- overall JJ amod
 +-- is VBZ cop
 +-- , , punct
 +-- seen VBN advcl
 |   +-- as IN mark
 |   +-- can MD aux
 |   +-- be VB auxpass
 |   +-- in IN prep
 |       +-- Figure NN pobj
 |           +-- 6 CD num
 +-- . . punct

117
Input: 5.2.4 Column Management If the optimal value of the initial restricted LP P is far from the the master LP P , then a large number of columns are generated before the gap is closed .
Parse:
generated VBN ROOT
 +-- Management NNP nsubjpass
 |   +-- 5.2.4 LS nn
 |   +-- Column NNP nn
 +-- is VBZ advcl
 |   +-- If IN mark
 |   +-- value NN nsubj
 |   |   +-- the DT det
 |   |   +-- optimal JJ amod
 |   |   +-- of IN prep
 |   |       +-- P NN pobj
 |   |           +-- the DT det
 |   |           +-- initial JJ amod
 |   |           +-- restricted VBN amod
 |   |           +-- LP NNP nn
 |   +-- far RB advmod
 |       +-- from IN prep
 |           +-- P NN pobj
 |               +-- the DT det
 |               +-- master NN nn
 |               +-- LP NN nn
 +-- , , punct
 +-- then RB advmod
 +-- number NN nsubjpass
 |   +-- a DT det
 |   +-- large JJ amod
 |   +-- of IN prep
 |       +-- columns NNS pobj
 +-- are VBP auxpass
 +-- closed VBN advcl
 |   +-- before IN mark
 |   +-- gap NN nsubjpass
 |   |   +-- the DT det
 |   +-- is VBZ auxpass
 +-- . . punct

118
Input: This leads to memory problems on markets with as few as 4 , 000 patients .
Parse:
leads VBZ ROOT
 +-- This DT nsubj
 +-- to IN prep
 |   +-- problems NNS pobj
 |       +-- memory NN nn
 |       +-- on IN prep
 |           +-- markets NNS pobj
 |               +-- with IN prep
 |                   +-- 4 CD pobj
 |                       +-- as RB quantmod
 |                       +-- few JJ quantmod
 |                       +-- as IN quantmod
 |                       +-- , , punct
 |                       +-- patients NNS appos
 |                           +-- 000 CD num
 +-- . . punct

119
Input: Also , even before memory becomes an issue , the column generation iterations become slow because of the additional overhead of solving a larger LP .
Parse:
slow JJ ROOT
 +-- Also RB advmod
 +-- , , punct
 +-- issue NN advcl
 |   +-- even RB advmod
 |   +-- before IN mark
 |   +-- memory NN nsubj
 |   +-- becomes VBZ cop
 |   +-- an DT det
 +-- iterations NNS nsubj
 |   +-- the DT det
 |   +-- generation NN nn
 |       +-- column NN nn
 +-- become VBP cop
 +-- of IN prep
 |   +-- because IN mwe
 |   +-- overhead NN pobj
 |       +-- the DT det
 |       +-- additional JJ amod
 |       +-- of IN prep
 |           +-- solving VBG pcomp
 |               +-- LP NN dobj
 |                   +-- a DT det
 |                   +-- larger JJR amod
 +-- . . punct

120
Input: To address these issues , we implemented a column management scheme to limit the size of the restricted LP .
Parse:
implemented VBD ROOT
 +-- address VB advcl
 |   +-- To TO aux
 |   +-- issues NNS dobj
 |       +-- these DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- scheme NN dobj
 |   +-- a DT det
 |   +-- management NN nn
 |   |   +-- column NN nn
 |   +-- limit VB infmod
 |       +-- to TO aux
 |       +-- size NN dobj
 |           +-- the DT det
 |           +-- of IN prep
 |               +-- LP NNP pobj
 |                   +-- the DT det
 |                   +-- restricted VBN amod
 +-- . . punct

121
Input: Whenever we add columns to the LP , we check to see if it contains more than a threshold number of columns .
Parse:
check VBP ROOT
 +-- add VBP advcl
 |   +-- Whenever WRB advmod
 |   +-- we PRP nsubj
 |   +-- columns NNS dobj
 |   +-- to IN prep
 |       +-- LP NNP pobj
 |           +-- the DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- see VB xcomp
 |   +-- to TO aux
 +-- contains VBZ advcl
 |   +-- if IN mark
 |   +-- it PRP nsubj
 |   +-- more JJR dobj
 |       +-- than IN prep
 |           +-- number NN pobj
 |               +-- a DT det
 |               +-- threshold NN nn
 |               +-- of IN prep
 |                   +-- columns NNS pobj
 +-- . . punct

122
Input: If this is the case , we selectively remove columns until it is again below the threshold2 .
Parse:
remove VBP ROOT
 +-- case NN advcl
 |   +-- If IN mark
 |   +-- this DT nsubj
 |   +-- is VBZ cop
 |   +-- the DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- selectively RB advmod
 +-- columns NNS dobj
 +-- is VBZ advcl
 |   +-- until IN mark
 |   +-- it PRP nsubj
 |   +-- again RB advmod
 |   +-- below IN prep
 |       +-- threshold2 CD pobj
 |           +-- the DT det
 +-- . . punct

123
Input: As we discussed earlier , only a tiny fraction of all the cycles will end up in the final solution .
Parse:
end VB ROOT
 +-- discussed VBD advcl
 |   +-- As IN mark
 |   +-- we PRP nsubj
 |   +-- earlier RBR advmod
 +-- , , punct
 +-- fraction NN nsubj
 |   +-- only RB advmod
 |   +-- a DT det
 |   +-- tiny JJ amod
 |   +-- of IN prep
 |       +-- cycles NNS pobj
 |           +-- all PDT predet
 |           +-- the DT det
 +-- will MD aux
 +-- up RP prt
 +-- in IN prep
 |   +-- solution NN pobj
 |       +-- the DT det
 |       +-- final JJ amod
 +-- . . punct

124
Input: It is unlikely that we delete such a cycle , and even if we do , it can always be generated again .
Parse:
unlikely JJ ROOT
 +-- It PRP nsubj
 +-- is VBZ cop
 +-- delete VBP ccomp
 |   +-- that IN mark
 |   +-- we PRP nsubj
 |   +-- cycle NN dobj
 |       +-- such PDT predet
 |       +-- a DT det
 +-- , , punct
 +-- and CC cc
 +-- generated VBN conj
 |   +-- do VBP advcl
 |   |   +-- even RB advmod
 |   |   +-- if IN mark
 |   |   +-- we PRP nsubj
 |   +-- , , punct
 |   +-- it PRP nsubjpass
 |   +-- can MD aux
 |   +-- always RB advmod
 |   +-- be VB auxpass
 |   +-- again RB advmod
 +-- . . punct

125
Input: Of course , we must not be too aggressive with the threshold , because doing so may offset the per iteration performance gains by significantly increasing the number of iterations required to get a suitable column set in the LP at the same time .
Parse:
aggressive JJ ROOT
 +-- course RB advmod
 |   +-- Of RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- must MD aux
 +-- not RB neg
 +-- be VB cop
 +-- too RB advmod
 +-- with IN prep
 |   +-- threshold NN pobj
 |       +-- the DT det
 +-- offset VB advcl
 |   +-- because IN mark
 |   +-- doing VBG csubj
 |   |   +-- so RB advmod
 |   +-- may MD aux
 |   +-- gains NNS dobj
 |   |   +-- the DT det
 |   |   +-- performance NN nn
 |   |       +-- per IN nn
 |   |           +-- iteration NN pobj
 |   +-- by IN prep
 |       +-- increasing VBG pcomp
 |           +-- significantly RB advmod
 |           +-- number NN dobj
 |               +-- the DT det
 |               +-- of IN prep
 |                   +-- iterations NNS pobj
 |                       +-- required VBN partmod
 |                           +-- get VB xcomp
 |                               +-- to TO aux
 |                               +-- column NN dobj
 |                                   +-- a DT det
 |                                   +-- suitable JJ amod
 |                                   +-- set VBN partmod
 |                                       +-- in IN prep
 |                                       |   +-- LP NN pobj
 |                                       |       +-- the DT det
 |                                       +-- at IN prep
 |                                           +-- time NN pobj
 |                                               +-- the DT det
 |                                               +-- same JJ amod
 +-- . . punct

126
Input: There are some columns we never delete , for example those we have branched on -LRB- see Section 5.3.2 -RRB- , or those with a non zero LP value .
Parse:
are VBP ROOT
 +-- There EX expl
 +-- columns NNS nsubj
 |   +-- some DT det
 |   +-- delete VBP rcmod
 |       +-- we PRP nsubj
 |       +-- never RB neg
 +-- , , punct
 +-- for IN prep
 |   +-- example NN pobj
 |   +-- those DT dep
 |       +-- branched VBN rcmod
 |       |   +-- we PRP nsubj
 |       |   +-- have VBP aux
 |       |   +-- on RP prt
 |       +-- see VB dep
 |       |   +-- -LRB- -LRB- punct
 |       |   +-- 5.3.2 CD dobj
 |       |   |   +-- Section NN nn
 |       |   +-- -RRB- -RRB- punct
 |       +-- , , punct
 |       +-- or CC cc
 |       +-- those DT conj
 |           +-- with IN prep
 |               +-- value NN pobj
 |                   +-- a DT det
 |                   +-- non FW nn
 |                   +-- zero CD num
 |                   +-- LP JJ amod
 +-- . . punct

127
Input: Amongst the rest , we delete those with the lowest price , since those correspond to the dual constraints that are most satisfied .
Parse:
delete VBP ROOT
 +-- Amongst VB partmod
 |   +-- rest NN dobj
 |       +-- the DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- those DT dobj
 |   +-- with IN prep
 |       +-- price NN pobj
 |           +-- the DT det
 |           +-- lowest JJS amod
 +-- correspond VBP advcl
 |   +-- since IN mark
 |   +-- those DT nsubj
 |   +-- to IN prep
 |       +-- constraints NNS pobj
 |           +-- the DT det
 |           +-- dual JJ amod
 |           +-- satisfied JJ rcmod
 |               +-- that WDT nsubj
 |               +-- are VBP cop
 |               +-- most RBS advmod
 +-- . . punct

128
Input: This column management scheme works well and has enabled us to clear markets with 10 , 000 patients , as seen in Figure 6 .
Parse:
works VBZ ROOT
 +-- scheme NN nsubj
 |   +-- This DT det
 |   +-- management NN nn
 |       +-- column NN nn
 +-- well RB advmod
 +-- and CC cc
 +-- enabled VBN conj
 |   +-- has VBZ aux
 |   +-- us PRP dobj
 |   +-- to TO prep
 |   |   +-- markets NNS pobj
 |   |       +-- clear JJ amod
 |   |       +-- with IN prep
 |   |           +-- patients NNS pobj
 |   |               +-- 000 CD num
 |   |                   +-- 10 CD number
 |   |                   +-- , , punct
 |   +-- , , punct
 |   +-- seen VBN advcl
 |       +-- as IN mark
 |       +-- in IN prep
 |           +-- Figure NNP pobj
 |               +-- 6 CD num
 +-- . . punct

129
Input: 5.3 Branch and Price Search for the ILP Given a large market clearing problem , we can successfully solve its LP relaxation to optimality by using the column generation enhancements described above .
Parse:
solve VB ROOT
 +-- Given VBN prep
 |   +-- Search NNP nsubj
 |   |   +-- 5.3 CD num
 |   |   +-- Branch NNP nn
 |   |   |   +-- and CC cc
 |   |   |   +-- Price NNP conj
 |   |   +-- for IN prep
 |   |       +-- ILP NNP pobj
 |   |           +-- the DT det
 |   +-- problem NN dep
 |       +-- a DT det
 |       +-- large JJ amod
 |       +-- clearing NN nn
 |           +-- market NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- successfully RB advmod
 +-- relaxation NN dobj
 |   +-- its PRP$ poss
 |   +-- LP JJ nn
 |   +-- to IN prep
 |       +-- optimality NN pobj
 +-- by IN prep
 |   +-- using VBG pcomp
 |       +-- enhancements NNS dobj
 |           +-- the DT det
 |           +-- generation NN nn
 |           |   +-- column NN nn
 |           +-- described VBN partmod
 |               +-- above RB advmod
 +-- . . punct

130
Input: However , the solutions we find are usually fractional .
Parse:
fractional JJ ROOT
 +-- However RB advmod
 +-- , , punct
 +-- solutions NNS nsubj
 |   +-- the DT det
 |   +-- find VBP rcmod
 |       +-- we PRP nsubj
 +-- are VBP cop
 +-- usually RB advmod
 +-- . . punct

131
Input: Thus the next 2 Based on memory size , we set the threshold at 400 , 000 .
Parse:
set VBD ROOT
 +-- Thus RB advmod
 +-- 2 CD nsubj
 |   +-- the DT det
 |   +-- next JJ amod
 +-- Based VBN prep
 |   +-- on IN pcomp
 |       +-- size NN pobj
 |           +-- memory NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- threshold NN dobj
 |   +-- the DT det
 +-- at IN prep
 |   +-- 000 CD pobj
 |       +-- 400 CD num
 |       +-- , , punct
 +-- . . punct

132
Input: 301 step involves performing a branch and price tree search -LRB- 1 -RRB- to find an optimal integral solution .
Parse:
involves VBZ ROOT
 +-- step NN nsubj
 |   +-- 301 CD num
 +-- performing VBG xcomp
 |   +-- search NN dobj
 |   |   +-- a DT det
 |   |   +-- branch NN nn
 |   |   |   +-- and CC cc
 |   |   |   +-- price NN conj
 |   |   +-- tree NN nn
 |   |   +-- 1 CD appos
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- -RRB- -RRB- punct
 |   +-- find VB xcomp
 |       +-- to TO aux
 |       +-- solution NN dobj
 |           +-- an DT det
 |           +-- optimal JJ amod
 |           +-- integral JJ amod
 +-- . . punct

133
Input: Briefly , this is the idea of branch and price .
Parse:
idea NN ROOT
 +-- Briefly RB advmod
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- the DT det
 +-- of IN prep
 |   +-- branch NN pobj
 |       +-- and CC cc
 |       +-- price NN conj
 +-- . . punct

134
Input: Whenever we set a fractional variable to 0 or 1 -LRB- branch -RRB- , both the master LP , and the restriction we are working with , are changed -LRB- constrained -RRB- .
Parse:
changed VBN ROOT
 +-- set VBD advcl
 |   +-- Whenever WRB advmod
 |   +-- we PRP nsubj
 |   +-- variable NN dobj
 |   |   +-- a DT det
 |   |   +-- fractional JJ amod
 |   +-- to IN prep
 |       +-- 0 CD pobj
 |           +-- or CC cc
 |           +-- 1 CD conj
 |           +-- -LRB- -LRB- punct
 |           +-- branch NN dep
 |           +-- -RRB- -RRB- punct
 +-- , , punct
 +-- LP NN nsubjpass
 |   +-- both CC preconj
 |   +-- the DT det
 |   +-- master NN nn
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- restriction NN conj
 |       +-- the DT det
 |       +-- working VBG rcmod
 |           +-- we PRP nsubj
 |           +-- are VBP aux
 |           +-- with IN prep
 +-- are VBP auxpass
 +-- -LRB- -LRB- punct
 +-- constrained VBN dep
 +-- -RRB- -RRB- punct
 +-- . . punct

135
Input: By default then , we need to perform column generation -LRB- go through the effort of pricing -RRB- at each node of the search tree to prove that the constrained restriction is optimal for constrained master LP .
Parse:
need VBP ROOT
 +-- By IN prep
 |   +-- default NN pobj
 +-- then RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- perform VB xcomp
 |   +-- to TO aux
 |   +-- generation NN dobj
 |   |   +-- column NN nn
 |   +-- go VB parataxis
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- through IN prep
 |   |   |   +-- effort NN pobj
 |   |   |       +-- the DT det
 |   |   |       +-- of IN prep
 |   |   |           +-- pricing NN pobj
 |   |   +-- -RRB- -RRB- punct
 |   +-- at IN prep
 |   |   +-- node NN pobj
 |   |       +-- each DT det
 |   |       +-- of IN prep
 |   |           +-- tree NN pobj
 |   |               +-- the DT det
 |   |               +-- search NN nn
 |   +-- prove VB xcomp
 |       +-- to TO aux
 |       +-- optimal JJ ccomp
 |           +-- that IN mark
 |           +-- restriction NN nsubj
 |           |   +-- the DT det
 |           |   +-- constrained JJ amod
 |           +-- is VBZ cop
 |           +-- for IN prep
 |               +-- LP NNS pobj
 |                   +-- constrained JJ amod
 |                   +-- master NN nn
 +-- . . punct

136
Input: -LRB- However , as discussed in Section 5.2.3 , we compute the integral upper bound for the root node based on relaxing the cycle length constraint completely , and whenever any node '' s LP in the tree achieves that value , we do not need to continue pricing columns at that node. -RRB- For the clearing problem with cycles of length at most 3 , we have found that there is rarely a gap between the optimal integral and fractional solutions .
Parse:
compute VBP ROOT
 +-- -LRB- -LRB- punct
 +-- However RB advmod
 +-- , , punct
 +-- discussed VBN advcl
 |   +-- as IN mark
 |   +-- in IN prep
 |       +-- Section NNP pobj
 |           +-- 5.2.3 CD num
 +-- we PRP nsubj
 +-- upper JJ dobj
 |   +-- the DT det
 |   +-- integral JJ amod
 |   +-- bound VBN partmod
 |       +-- for IN prep
 |           +-- node NN pobj
 |               +-- the DT det
 |               +-- root NN nn
 +-- based VBN prep
 |   +-- on IN pcomp
 |       +-- relaxing VBG pcomp
 |           +-- constraint NN dobj
 |           |   +-- the DT det
 |           |   +-- length NN nn
 |           |       +-- cycle NN nn
 |           +-- completely RB advmod
 +-- and CC cc
 +-- need VB conj
 |   +-- achieves VBZ advcl
 |   |   +-- whenever WRB advmod
 |   |   +-- LP NNP nsubj
 |   |   |   +-- node NN poss
 |   |   |   |   +-- any DT det
 |   |   |   |   +-- '' '' punct
 |   |   |   |   +-- s POS possessive
 |   |   |   +-- in IN prep
 |   |   |       +-- tree NN pobj
 |   |   |           +-- the DT det
 |   |   +-- value NN dobj
 |   |       +-- that DT det
 |   +-- , , punct
 |   +-- we PRP nsubj
 |   +-- do VBP aux
 |   +-- not RB neg
 |   +-- continue VB xcomp
 |       +-- to TO aux
 |       +-- columns NNS dobj
 |       |   +-- pricing NN nn
 |       +-- at IN prep
 |           +-- node. NN pobj
 |               +-- that DT det
 +-- -RRB- -RRB- punct
 +-- found VBN ccomp
 |   +-- For IN prep
 |   |   +-- problem NN pobj
 |   |       +-- the DT det
 |   |       +-- clearing NN nn
 |   |       +-- with IN prep
 |   |           +-- cycles NNS pobj
 |   |               +-- of IN prep
 |   |               |   +-- length NN pobj
 |   |               +-- at IN prep
 |   |                   +-- 3 CD pobj
 |   |                       +-- most RBS amod
 |   +-- , , punct
 |   +-- we PRP nsubj
 |   +-- have VBP aux
 |   +-- is VBZ ccomp
 |       +-- that IN mark
 |       +-- there EX expl
 |       +-- rarely RB advmod
 |       +-- gap NN nsubj
 |           +-- a DT det
 |           +-- between IN prep
 |               +-- solutions NNS pobj
 |                   +-- the DT det
 |                   +-- optimal JJ amod
 |                   +-- integral JJ amod
 |                       +-- and CC cc
 |                       +-- fractional JJ conj
 +-- . . punct

137
Input: This means we can largely avoid the expensive per node pricing step
Parse:
means VBZ ROOT
 +-- This DT nsubj
 +-- avoid VB ccomp
     +-- we PRP nsubj
     +-- can MD aux
     +-- largely RB advmod
     +-- step NN dobj
         +-- the DT det
         +-- expensive JJ amod
             +-- per IN prep
                 +-- pricing NN pobj
                     +-- node NN nn

138
Input: Although CPLEX can solve ILPs , it does not support branch and price -LRB- for example , because there can be problemspecific complications involving the interaction between the branching rule and the pricing problem -RRB- .
Parse:
support VB ROOT
 +-- solve VB advcl
 |   +-- Although IN mark
 |   +-- CPLEX NNP nsubj
 |   +-- can MD aux
 |   +-- ILPs NNP dobj
 +-- , , punct
 +-- it PRP nsubj
 +-- does VBZ aux
 +-- not RB neg
 +-- branch NN dobj
 |   +-- and CC cc
 |   +-- price NN conj
 +-- -LRB- -LRB- punct
 +-- for IN prep
 |   +-- example NN pobj
 +-- complications NNS advcl
 |   +-- because IN mark
 |   +-- there EX expl
 |   +-- can MD aux
 |   +-- be VB cop
 |   +-- problemspecific JJ amod
 |   +-- involving VBG partmod
 |       +-- interaction NN dobj
 |           +-- the DT det
 |           +-- between IN prep
 |               +-- rule NN pobj
 |                   +-- the DT det
 |                   +-- branching VBG amod
 |                   +-- and CC cc
 |                   +-- problem NN conj
 |                       +-- the DT det
 |                       +-- pricing NN nn
 +-- -RRB- -RRB- punct
 +-- . . punct

139
Input: Hence , we implemented our own branch and price algorithm , which explores the search tree in depth first order .
Parse:
implemented VBD ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- algorithm NNP dobj
 |   +-- our PRP$ poss
 |   +-- own JJ amod
 |   +-- branch NN nn
 |   |   +-- and CC cc
 |   |   +-- price NN conj
 |   +-- , , punct
 |   +-- explores VBZ rcmod
 |       +-- which WDT nsubj
 |       +-- tree NN dobj
 |       |   +-- the DT det
 |       |   +-- search NN nn
 |       +-- in IN prep
 |           +-- order NN pobj
 |               +-- depth NN amod
 |               +-- first JJ amod
 +-- . . punct

140
Input: We also experimented with the A* node selection order -LRB- 7 , 2 -RRB- .
Parse:
experimented VBD ROOT
 +-- We PRP nsubj
 +-- also RB advmod
 +-- with IN prep
 |   +-- order NN pobj
 |       +-- the DT det
 |       +-- A* , nn
 |       +-- selection NN nn
 |       |   +-- node NN nn
 |       +-- -LRB- -LRB- punct
 |       +-- 7 CD dep
 |       |   +-- , , punct
 |       |   +-- 2 CD num
 |       +-- -RRB- -RRB- punct
 +-- . . punct

141
Input: However , this search strategy requires significantly more memory , which we found was better employed in making the column generation phase faster -LRB- see Section 5.2.2 -RRB- .
Parse:
requires VBZ ROOT
 +-- However RB advmod
 +-- , , punct
 +-- strategy NN nsubj
 |   +-- this DT det
 |   +-- search NN nn
 +-- memory NN dobj
 |   +-- more JJR amod
 |   |   +-- significantly RB advmod
 |   +-- , , punct
 |   +-- found VBD rcmod
 |       +-- which WDT dobj
 |       +-- we PRP nsubj
 |       +-- employed VBN ccomp
 |           +-- was VBD auxpass
 |           +-- better RBR advmod
 |           +-- in IN prep
 |               +-- making VBG pcomp
 |                   +-- phase NN dobj
 |                   |   +-- the DT det
 |                   |   +-- generation NN nn
 |                   |       +-- column NN nn
 |                   +-- faster RBR advmod
 |                   +-- see VB parataxis
 |                       +-- -LRB- -LRB- punct
 |                       +-- Section NN dobj
 |                       |   +-- 5.2.2 CD num
 |                       +-- -RRB- -RRB- punct
 +-- . . punct

142
Input: The remaining major components of the algorithm are described in the next two subsections .
Parse:
described VBN ROOT
 +-- components NNS nsubjpass
 |   +-- The DT det
 |   +-- remaining VBG amod
 |   +-- major JJ amod
 |   +-- of IN prep
 |       +-- algorithm NN pobj
 |           +-- the DT det
 +-- are VBP auxpass
 +-- in IN prep
 |   +-- subsections NNS pobj
 |       +-- the DT det
 |       +-- next JJ amod
 |       +-- two CD num
 +-- . . punct

143
Input: 5.3.1 Primal Heuristics Before branching on a fractional variable , we use primal heuristics to construct a feasible integral solution .
Parse:
use VBP ROOT
 +-- Heuristics NNPS nsubj
 |   +-- 5.3.1 LS nn
 |   +-- Primal NNP nn
 +-- Before IN prep
 |   +-- branching VBG pcomp
 |       +-- on IN prep
 |           +-- variable NN pobj
 |               +-- a DT det
 |               +-- fractional JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- heuristics NNS dobj
 |   +-- primal JJ amod
 +-- construct VB xcomp
 |   +-- to TO aux
 |   +-- solution NN dobj
 |       +-- a DT det
 |       +-- feasible JJ amod
 |       +-- integral JJ amod
 +-- . . punct

144
Input: These solutions are lower bounds on the final optimal integral solutions .
Parse:
bounds NNS ROOT
 +-- solutions NNS nsubj
 |   +-- These DT det
 +-- are VBP cop
 +-- lower JJR amod
 +-- on IN prep
 |   +-- solutions NNS pobj
 |       +-- the DT det
 |       +-- final JJ amod
 |       +-- optimal JJ amod
 |       +-- integral JJ amod
 +-- . . punct

145
Input: Hence , whenever a restricted fractional solution is no better than the best integral solution found so far , we prune the current subtree .
Parse:
prune VBP ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- better RBR advmod
 |   +-- whenever WRB advmod
 |   +-- solution NN nsubj
 |   |   +-- a DT det
 |   |   +-- restricted VBN amod
 |   |   +-- fractional JJ amod
 |   +-- is VBZ cop
 |   +-- no RB advmod
 |   +-- than IN prep
 |       +-- solution NN pobj
 |           +-- the DT det
 |           +-- best JJS amod
 |           +-- integral JJ amod
 |           +-- found VBN partmod
 |               +-- far RB advmod
 |                   +-- so RB advmod
 +-- we PRP nsubj
 +-- subtree NN dobj
 |   +-- the DT det
 |   +-- current JJ amod
 +-- . . punct

146
Input: A primal heuristic is effective if it is efficient and constructs tight lower bounds .
Parse:
effective JJ ROOT
 +-- heuristic JJ nsubj
 |   +-- A DT det
 |   +-- primal JJ amod
 +-- is VBZ cop
 +-- efficient JJ advcl
 |   +-- if IN mark
 |   +-- it PRP nsubj
 |   +-- is VBZ cop
 |   +-- and CC cc
 |   +-- constructs VBZ conj
 |       +-- bounds NNS dobj
 |           +-- lower JJR amod
 |               +-- tight RB advmod
 +-- . . punct

147
Input: We experimented with two primal heuristics .
Parse:
experimented VBD ROOT
 +-- We PRP nsubj
 +-- with IN prep
 |   +-- heuristics NNS pobj
 |       +-- two CD num
 |       +-- primal JJ amod
 +-- . . punct

148
Input: The first is a simple rounding algorithm -LRB- 8 -RRB-
Parse:
algorithm NN ROOT
 +-- first JJ nsubj
 |   +-- The DT det
 +-- is VBZ cop
 +-- a DT det
 +-- simple JJ amod
 +-- rounding NN amod
 +-- -LRB- -LRB- punct
 +-- 8 CD dep
 +-- -RRB- -RRB- punct

149
Input: Whilst this heuristic is efficient , we found that the lower bounds it constructs rarely enable much pruning .
Parse:
found VBD ROOT
 +-- efficient JJ advcl
 |   +-- Whilst WDT mark
 |   +-- heuristic NN nsubj
 |   |   +-- this DT det
 |   +-- is VBZ cop
 +-- , , punct
 +-- we PRP nsubj
 +-- enable VBP ccomp
 |   +-- that IN mark
 |   +-- bounds NNS nsubj
 |   |   +-- the DT det
 |   |   +-- lower JJR amod
 |   |   +-- constructs VBZ rcmod
 |   |       +-- it PRP nsubj
 |   +-- rarely RB advmod
 |   +-- pruning NN dobj
 |       +-- much JJ amod
 +-- . . punct

150
Input: We also tried using CPLEX as a primal heuristic .
Parse:
tried VBD ROOT
 +-- We PRP nsubj
 +-- also RB advmod
 +-- using VBG xcomp
 |   +-- CPLEX NNP dobj
 |   +-- as IN prep
 |       +-- heuristic NN pobj
 |           +-- a DT det
 |           +-- primal JJ amod
 +-- . . punct

151
Input: At any given node of the search tree , we can convert the restricted LP relaxation back to an ILP by reintroducing the integrality constraints .
Parse:
convert VB ROOT
 +-- At IN prep
 |   +-- node NN pobj
 |       +-- any DT det
 |       +-- given VBN amod
 |       +-- of IN prep
 |           +-- tree NN pobj
 |               +-- the DT det
 |               +-- search NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- relaxation NN dobj
 |   +-- the DT det
 |   +-- restricted VBN amod
 |   +-- LP NN nn
 +-- back RB advmod
 |   +-- to IN prep
 |       +-- ILP NN pobj
 |           +-- an DT det
 +-- by IN prep
 |   +-- reintroducing VBG pcomp
 |       +-- constraints NNS dobj
 |           +-- the DT det
 |           +-- integrality NN nn
 +-- . . punct

152
Input: CPLEX has several built in primal heuristics , which we can apply to this ILP .
Parse:
has VBZ ROOT
 +-- CPLEX NNP nsubj
 +-- several JJ dobj
 |   +-- built VBN partmod
 |       +-- in IN prep
 |           +-- heuristics NNS pobj
 |               +-- primal JJ amod
 |               +-- , , punct
 |               +-- apply VB rcmod
 |                   +-- which WDT dobj
 |                   +-- we PRP nsubj
 |                   +-- can MD aux
 |                   +-- to IN prep
 |                       +-- ILP NN pobj
 |                           +-- this DT det
 +-- . . punct

153
Input: Moreover , we can use CPLEX '' s own tree search to find an optimal integral solution .
Parse:
use VB ROOT
 +-- Moreover RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- search NN dobj
 |   +-- CPLEX NNP poss
 |   |   +-- '' '' punct
 |   |   +-- s POS possessive
 |   +-- own JJ amod
 |   +-- tree NN nn
 +-- find VB xcomp
 |   +-- to TO aux
 |   +-- solution NN dobj
 |       +-- an DT det
 |       +-- optimal JJ amod
 |       +-- integral JJ amod
 +-- . . punct

154
Input: In general , this tree search is much faster than our own .
Parse:
faster JJR ROOT
 +-- In IN prep
 |   +-- general JJ pobj
 +-- , , punct
 +-- search NN nsubj
 |   +-- this DT det
 |   +-- tree NN nn
 +-- is VBZ cop
 +-- much RB advmod
 +-- than IN prep
 |   +-- own JJ pobj
 |       +-- our PRP$ poss
 +-- . . punct

155
Input: If CPLEX finds an integral solution that matches the fractional upper bound at the root node , we are done .
Parse:
done VBN ROOT
 +-- finds VBZ advcl
 |   +-- If IN mark
 |   +-- CPLEX NNP nsubj
 |   +-- solution NN dobj
 |       +-- an DT det
 |       +-- integral JJ amod
 |       +-- matches VBZ rcmod
 |           +-- that WDT nsubj
 |           +-- upper JJ dobj
 |               +-- the DT det
 |               +-- fractional JJ amod
 |               +-- bound VBN partmod
 |                   +-- at IN prep
 |                       +-- node NN pobj
 |                           +-- the DT det
 |                           +-- root NN nn
 +-- , , punct
 +-- we PRP nsubjpass
 +-- are VBP auxpass
 +-- . . punct

156
Input: Otherwise , no such integral solution exists , or we don '' t yet have the right combination of cycles in the restricted LP .
Parse:
exists NNS ROOT
 +-- Otherwise RB advmod
 +-- , , punct
 +-- solution NN nsubj
 |   +-- no DT det
 |   +-- such JJ amod
 |   +-- integral JJ amod
 +-- or CC cc
 +-- don VBP conj
 |   +-- we PRP nsubj
 |   +-- '' '' punct
 |   +-- t NN dobj
 |   +-- yet RB cc
 |   +-- have VBP conj
 |       +-- combination NN dobj
 |           +-- the DT det
 |           +-- right JJ amod
 |           +-- of IN prep
 |           |   +-- cycles NNS pobj
 |           +-- in IN prep
 |               +-- LP NN pobj
 |                   +-- the DT det
 |                   +-- restricted VBN amod
 +-- . . punct

157
Input: For kidney exchange markets , it is usually the second reason that applies -LRB- see Sections 5.2.2 and 5.2.4 -RRB- .
Parse:
reason NN ROOT
 +-- For IN prep
 |   +-- markets NNS pobj
 |       +-- exchange NN nn
 |           +-- kidney NN nn
 +-- , , punct
 +-- it PRP nsubj
 +-- is VBZ cop
 +-- usually RB advmod
 +-- the DT det
 +-- second JJ amod
 +-- applies VBZ rcmod
 |   +-- that WDT nsubj
 |   +-- see VB ccomp
 |       +-- -LRB- -LRB- punct
 |       +-- 5.2.2 CD dobj
 |       |   +-- Sections NNPS nn
 |       |   +-- and CC cc
 |       |   +-- 5.2.4 CD conj
 |       +-- -RRB- -RRB- punct
 +-- . . punct

158
Input: Hence , at some point in the tree search , once more columns have been generated as a result of branching , the CPLEX heuristic will find an optimal integral solution .
Parse:
find VB ROOT
 +-- generated VBN partmod
 |   +-- Hence RB advmod
 |   +-- , , punct
 |   +-- at IN prep
 |   |   +-- point NN pobj
 |   |       +-- some DT det
 |   |       +-- in IN prep
 |   |           +-- search NN pobj
 |   |               +-- the DT det
 |   |               +-- tree NN nn
 |   +-- columns NNS nsubjpass
 |   |   +-- more JJR amod
 |   |       +-- once RB advmod
 |   +-- have VBP aux
 |   +-- been VBN auxpass
 |   +-- as IN prep
 |       +-- result NN pobj
 |           +-- a DT det
 |           +-- of IN prep
 |               +-- branching NN pobj
 +-- , , punct
 +-- heuristic NN nsubj
 |   +-- the DT det
 |   +-- CPLEX NNP nn
 +-- will MD aux
 +-- solution NN dobj
 |   +-- an DT det
 |   +-- optimal JJ amod
 |   +-- integral JJ amod
 +-- . . punct

159
Input: Although CPLEX tree search is faster than our own , it is not so fast that we can apply it to every node in our search tree .
Parse:
fast JJ ROOT
 +-- faster JJR advcl
 |   +-- Although IN mark
 |   +-- search NN nsubj
 |   |   +-- CPLEX NNP nn
 |   |   +-- tree NN nn
 |   +-- is VBZ cop
 |   +-- than IN prep
 |       +-- own JJ pobj
 |           +-- our PRP$ poss
 +-- , , punct
 +-- it PRP nsubj
 +-- is VBZ cop
 +-- not RB neg
 +-- so RB advmod
 +-- apply VB ccomp
 |   +-- that IN mark
 |   +-- we PRP nsubj
 |   +-- can MD aux
 |   +-- it PRP dobj
 |   +-- to IN prep
 |       +-- node NN pobj
 |           +-- every DT det
 |           +-- in IN prep
 |               +-- tree NN pobj
 |                   +-- our PRP$ poss
 |                   +-- search NN nn
 +-- . . punct

160
Input: Hence , we make the following optimizations .
Parse:
make VBP ROOT
 +-- Hence RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- optimizations NNS dobj
 |   +-- the DT det
 |   +-- following VBG amod
 +-- . . punct

161
Input: Firstly , we add a constraint that requires the objective value of the ILP to be as large as the fractional target .
Parse:
add VBP ROOT
 +-- Firstly RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- constraint NN dobj
 |   +-- a DT det
 |   +-- requires VBZ rcmod
 |       +-- that WDT nsubj
 |       +-- value NN dobj
 |       |   +-- the DT det
 |       |   +-- objective JJ amod
 |       |   +-- of IN prep
 |       |       +-- ILP NNP pobj
 |       |           +-- the DT det
 |       +-- large JJ xcomp
 |           +-- to TO aux
 |           +-- be VB cop
 |           +-- as RB advmod
 |           +-- as IN prep
 |               +-- target NN pobj
 |                   +-- the DT det
 |                   +-- fractional JJ amod
 +-- . . punct

162
Input: If this is not the case , we want to abort and proceed to generate more columns with our branch and price search .
Parse:
want VBP ROOT
 +-- case NN advcl
 |   +-- If IN mark
 |   +-- this DT nsubj
 |   +-- is VBZ cop
 |   +-- not RB neg
 |   +-- the DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- abort VB xcomp
 |   +-- to TO aux
 |   +-- and CC cc
 |   +-- proceed VB conj
 |       +-- generate VB xcomp
 |           +-- to TO aux
 |           +-- columns NNS dobj
 |           |   +-- more JJR amod
 |           +-- with IN prep
 |               +-- search NN pobj
 |                   +-- our PRP$ poss
 |                   +-- branch NN nn
 |                       +-- and CC cc
 |                       +-- price NN conj
 +-- . . punct

163
Input: Secondly , we limit the number of nodes in CPLEX '' s search tree .
Parse:
limit VBP ROOT
 +-- Secondly RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- tree NN dobj
 |   +-- number NN poss
 |   |   +-- the DT det
 |   |   +-- of IN prep
 |   |   |   +-- nodes NNS pobj
 |   |   |       +-- in IN prep
 |   |   |           +-- CPLEX NNP pobj
 |   |   +-- '' '' punct
 |   |   +-- s POS possessive
 |   +-- search NN nn
 +-- . . punct

164
Input: This is because we have observed that no integral solution exists , CPLEX can take a very long time to prove that .
Parse:
is VBZ ROOT
 +-- This DT nsubj
 +-- observed VBN advcl
 |   +-- because IN mark
 |   +-- we PRP nsubj
 |   +-- have VBP aux
 |   +-- exists VBZ ccomp
 |       +-- that IN mark
 |       +-- solution NN nsubj
 |       |   +-- no DT det
 |       |   +-- integral JJ amod
 |       +-- , , punct
 |       +-- take VB ccomp
 |           +-- CPLEX NNP nsubj
 |           +-- can MD aux
 |           +-- time NN dobj
 |               +-- a DT det
 |               +-- long JJ amod
 |               |   +-- very RB advmod
 |               +-- prove VB infmod
 |                   +-- to TO aux
 |                   +-- that DT dobj
 +-- . . punct

165
Input: Finally , we only apply the CPLEX heuristic at a node if it has a sufficiently different set of cycles from its parent .
Parse:
apply VBP ROOT
 +-- Finally RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- only RB advmod
 +-- heuristic NN dobj
 |   +-- the DT det
 |   +-- CPLEX NNP nn
 +-- at IN prep
 |   +-- node NN pobj
 |       +-- a DT det
 +-- has VBZ advcl
 |   +-- if IN mark
 |   +-- it PRP nsubj
 |   +-- set NN dobj
 |       +-- a DT det
 |       +-- different JJ amod
 |       |   +-- sufficiently RB advmod
 |       +-- of IN prep
 |           +-- cycles NNS pobj
 |               +-- from IN prep
 |                   +-- parent NN pobj
 |                       +-- its PRP$ poss
 +-- . . punct

166
Input: Using CPLEX as a primal heuristic has a large impact because it makes the search tree smaller , so all the computationally expensive pricing work is avoided at nodes that are not generated in this smaller tree .
Parse:
has VBZ ROOT
 +-- Using VBG csubj
 |   +-- CPLEX NNP dobj
 |   +-- as IN prep
 |       +-- heuristic NN pobj
 |           +-- a DT det
 |           +-- primal JJ amod
 +-- impact NN dobj
 |   +-- a DT det
 |   +-- large JJ amod
 +-- makes VBZ advcl
 |   +-- because IN mark
 |   +-- it PRP nsubj
 |   +-- smaller JJR xcomp
 |   |   +-- tree NN nsubj
 |   |       +-- the DT det
 |   |       +-- search NN nn
 |   +-- , , punct
 |   +-- avoided VBN advcl
 |       +-- so RB mark
 |       +-- work NN nsubjpass
 |       |   +-- all PDT predet
 |       |   +-- the DT det
 |       |   +-- expensive JJ amod
 |       |   |   +-- computationally RB advmod
 |       |   +-- pricing NN nn
 |       +-- is VBZ auxpass
 |       +-- at IN prep
 |           +-- nodes NNS pobj
 |               +-- generated VBN rcmod
 |                   +-- that WDT nsubjpass
 |                   +-- are VBP auxpass
 |                   +-- not RB neg
 |                   +-- in IN prep
 |                       +-- tree NN pobj
 |                           +-- this DT det
 |                           +-- smaller JJR amod
 +-- . . punct

167
Input: 5.3.2 Cycle Brancher We experimented with two branching strategies , both of which select one variable per node .
Parse:
experimented VBD ROOT
 +-- Brancher NNP nsubj
 |   +-- 5.3.2 LS nn
 |   +-- Cycle NN nn
 +-- We PRP nsubj
 +-- with IN prep
 |   +-- strategies NNS pobj
 |       +-- two CD num
 |       +-- branching VBG amod
 |       +-- , , punct
 |       +-- select VBP rcmod
 |           +-- both DT nsubj
 |           |   +-- of IN prep
 |           |       +-- which WDT pobj
 |           +-- variable NN dobj
 |               +-- one CD num
 |               +-- per IN prep
 |                   +-- node NN pobj
 +-- . . punct

168
Input: The first strategy , branching by certainty , randomly selects a variable from those whose LP value is closest to 1 .
Parse:
selects VBZ ROOT
 +-- strategy NN nsubj
 |   +-- The DT det
 |   +-- first JJ amod
 +-- , , punct
 +-- branching VBG partmod
 |   +-- by IN prep
 |       +-- certainty NN pobj
 +-- randomly RB advmod
 +-- variable NN dobj
 |   +-- a DT det
 |   +-- from IN prep
 |       +-- those DT pobj
 |           +-- closest JJS rcmod
 |               +-- value NN nsubj
 |               |   +-- whose WP$ poss
 |               |   +-- LP JJ nn
 |               +-- is VBZ cop
 |               +-- to IN prep
 |                   +-- 1 CD pobj
 +-- . . punct

169
Input: The second strategy , branching by uncertainty , randomly selects a variable whose LP value is closest to 0.5 .
Parse:
selects VBZ ROOT
 +-- strategy NN nsubj
 |   +-- The DT det
 |   +-- second JJ amod
 +-- , , punct
 +-- branching VBG partmod
 |   +-- by IN prep
 |       +-- uncertainty NN pobj
 +-- randomly RB advmod
 +-- variable NN dobj
 |   +-- a DT det
 |   +-- closest JJS rcmod
 |       +-- value NN nsubj
 |       |   +-- whose WP$ poss
 |       |   +-- LP JJ nn
 |       +-- is VBZ cop
 |       +-- to IN prep
 |           +-- 0.5 CD pobj
 +-- . . punct

170
Input: In either case , two children of the node are generated corresponding to two subtrees , one in which the variable is set to 0 , the other in which it is set to 1 .
Parse:
generated VBN ROOT
 +-- In IN prep
 |   +-- case NN pobj
 |       +-- either DT det
 +-- , , punct
 +-- children NNS nsubjpass
 |   +-- two CD num
 |   +-- of IN prep
 |       +-- node NN pobj
 |           +-- the DT det
 +-- are VBP auxpass
 +-- corresponding VBG xcomp
 |   +-- to IN prep
 |       +-- subtrees NNS pobj
 |           +-- two CD num
 |           +-- , , punct
 |           +-- one CD appos
 |               +-- set VBN rcmod
 |                   +-- in IN prep
 |                   |   +-- which WDT pobj
 |                   +-- variable NN nsubjpass
 |                   |   +-- the DT det
 |                   +-- is VBZ auxpass
 |                   +-- to IN prep
 |                       +-- 0 CD pobj
 |                           +-- , , punct
 |                           +-- other JJ appos
 |                               +-- the DT det
 |                               +-- set VBN rcmod
 |                                   +-- in IN prep
 |                                   |   +-- which WDT pobj
 |                                   +-- it PRP nsubjpass
 |                                   +-- is VBZ auxpass
 |                                   +-- to IN prep
 |                                       +-- 1 CD pobj
 +-- . . punct

171
Input: Our depth first search always chooses to explore first the subtree in which the value of the variable is closest to its fractional value .
Parse:
chooses VBZ ROOT
 +-- search NN nsubj
 |   +-- Our PRP$ poss
 |   +-- depth NN nn
 |   +-- first JJ amod
 +-- always RB advmod
 +-- explore VB xcomp
 |   +-- to TO aux
 |   +-- first RB advmod
 |   +-- subtree NN dobj
 |       +-- the DT det
 |       +-- closest JJS rcmod
 |           +-- in IN prep
 |           |   +-- which WDT pobj
 |           +-- value NN nsubj
 |           |   +-- the DT det
 |           |   +-- of IN prep
 |           |       +-- variable NN pobj
 |           |           +-- the DT det
 |           +-- is VBZ cop
 |           +-- to IN prep
 |               +-- value NN pobj
 |                   +-- its PRP$ poss
 |                   +-- fractional JJ amod
 +-- . . punct

172
Input: For our clearing problem with cycles of length at most 3 , we found branching by uncertainty to be superior , rarely requiring any backtracking. .
Parse:
found VBD ROOT
 +-- For IN prep
 |   +-- problem NN pobj
 |       +-- our PRP$ poss
 |       +-- clearing NN nn
 |       +-- with IN prep
 |           +-- cycles NNS pobj
 |               +-- of IN prep
 |               |   +-- length NN pobj
 |               +-- at IN prep
 |                   +-- 3 CD pobj
 |                       +-- most RBS amod
 +-- , , punct
 +-- we PRP nsubj
 +-- superior JJ xcomp
 |   +-- branching VBG nsubj
 |   |   +-- by IN prep
 |   |       +-- uncertainty NN pobj
 |   +-- to TO aux
 |   +-- be VB cop
 +-- requiring VBG xcomp
 |   +-- rarely RB advmod
 |   +-- backtracking. NN dobj
 |       +-- any DT det
 +-- . . punct
