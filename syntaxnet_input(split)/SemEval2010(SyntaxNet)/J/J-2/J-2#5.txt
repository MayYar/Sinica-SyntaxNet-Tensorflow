
1
Input: MECHANISMS Among all linear VCG redistribution mechanisms , we would like to be able to identify the one that redistributes the greatest percentage of the total VCG payment.2 This is not a well defined notion
Parse:
like VB ROOT
 +-- MECHANISMS NNS nsubj
 |   +-- Among IN prep
 |       +-- mechanisms NNS pobj
 |           +-- all DT det
 |           +-- linear JJ amod
 |           +-- redistribution NN nn
 |               +-- VCG JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- would MD aux
 +-- able JJ xcomp
     +-- to TO aux
     +-- be VB cop
     +-- identify VB xcomp
         +-- to TO aux
         +-- notion NN ccomp
             +-- one NN nsubj
             |   +-- the DT det
             |   +-- redistributes VBZ rcmod
             |       +-- that WDT nsubj
             |       +-- percentage NN dobj
             |           +-- the DT det
             |           +-- greatest JJS amod
             |           +-- of IN prep
             |               +-- This DT pobj
             |                   +-- the DT det
             |                   +-- total JJ amod
             |                   +-- payment.2 CD nn
             |                       +-- VCG NNP nn
             +-- is VBZ cop
             +-- not RB neg
             +-- a DT det
             +-- defined VBN amod
                 +-- well RB advmod

2
Input: We emphasize that we do not assume that a prior distribution over bidders '' valuations is available , so we can not compare them based on expected redistribution .
Parse:
emphasize VBP ROOT
 +-- We PRP nsubj
 +-- assume VB ccomp
 |   +-- that IN mark
 |   +-- we PRP nsubj
 |   +-- do VBP aux
 |   +-- not RB neg
 |   +-- available JJ ccomp
 |       +-- that IN mark
 |       +-- distribution NN nsubj
 |       |   +-- a DT det
 |       |   +-- prior JJ amod
 |       |   +-- over IN prep
 |       |       +-- valuations NNS pobj
 |       |           +-- bidders NNS nn
 |       |           +-- '' '' punct
 |       +-- is VBZ cop
 |       +-- , , punct
 |       +-- compare VB advcl
 |           +-- so IN mark
 |           +-- we PRP nsubj
 |           +-- can MD aux
 |           +-- not RB neg
 |           +-- them PRP dobj
 |           +-- based VBN prep
 |               +-- on IN pcomp
 |                   +-- redistribution NN pobj
 |                       +-- expected VBN amod
 +-- . . punct

3
Input: Below , we study three well defined ways of comparing redistribution mechanisms
Parse:
study VBP ROOT
 +-- Below RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- ways NNS dobj
     +-- three CD num
     +-- defined VBN amod
     |   +-- well RB advmod
     +-- of IN prep
         +-- comparing VBG pcomp
             +-- mechanisms NNS dobj
                 +-- redistribution NN nn

4
Input: Best case performance .
Parse:
performance NN ROOT
 +-- Best JJS amod
 +-- case NN nn
 +-- . . punct

5
Input: One way of evaluating a mechanism is by considering the highest redistribution percentage that it achieves .
Parse:
is VBZ ROOT
 +-- way NN nsubj
 |   +-- One CD num
 |   +-- of IN prep
 |       +-- evaluating VBG pcomp
 |           +-- mechanism NN dobj
 |               +-- a DT det
 +-- by IN prep
 |   +-- considering VBG pcomp
 |       +-- percentage NN dobj
 |           +-- the DT det
 |           +-- highest JJS amod
 |           +-- redistribution NN nn
 |           +-- achieves VBZ rcmod
 |               +-- that WDT dobj
 |               +-- it PRP nsubj
 +-- . . punct

6
Input: Consider the previous two examples .
Parse:
Consider VB ROOT
 +-- examples NNS dobj
 |   +-- the DT det
 |   +-- previous JJ amod
 |   +-- two CD num
 +-- . . punct

7
Input: For the first example , the total redistribution payment is -LRB- m + 1 -RRB- m n ? vm+2 + -LRB- n ? m ? 1 -RRB- m n ? vm+1 .
Parse:
vm+1 CD ROOT
 +-- m NNP dep
 |   +-- m NNP dep
 |   |   +-- For IN prep
 |   |   |   +-- example NN pobj
 |   |   |       +-- the DT det
 |   |   |       +-- first JJ amod
 |   |   +-- , , punct
 |   |   +-- payment NN nsubj
 |   |   |   +-- the DT det
 |   |   |   +-- total JJ amod
 |   |   |   +-- redistribution NN nn
 |   |   +-- is VBZ cop
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- + SYM prep
 |   |   |   +-- 1 CD dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- n NN dep
 |   |   +-- m NNP nn
 |   |   +-- ? . punct
 |   |   +-- vm+2 NNP dep
 |   |   +-- + SYM dep
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- n RB advmod
 |   +-- m NN dep
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- -RRB- -RRB- punct
 +-- n NN dep
 |   +-- ? . punct
 +-- . . punct

8
Input: When ? vm+2 = ? vm+1 , this is equal to the total VCG payment m ? vm+1 .
Parse:
equal JJ ROOT
 +-- When WRB advmod
 +-- ? . prep
 |   +-- vm+2 CD pobj
 +-- vm+1 CD advcl
 |   +-- = SYM dep
 |       +-- ? . punct
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- to IN prep
 |   +-- m NN pobj
 |       +-- the DT det
 |       +-- total JJ amod
 |       +-- VCG JJ amod
 |       +-- payment NN nn
 |       +-- ? . punct
 |       +-- vm+1 CD num
 +-- . . punct

9
Input: Thus , this mechanism redistributes 100 % of the total VCG payment in the best case .
Parse:
redistributes VBZ ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- mechanism NN nsubj
 |   +-- this DT det
 +-- % NN dobj
 |   +-- 100 CD num
 |   +-- of IN prep
 |       +-- payment NN pobj
 |           +-- the DT det
 |           +-- total JJ amod
 |           +-- VCG JJ amod
 |           +-- in IN prep
 |               +-- case NN pobj
 |                   +-- the DT det
 |                   +-- best JJS amod
 +-- . . punct

10
Input: For the second example , the total redistribution payment is m ? vm+1 ? m -LRB- m+1 -RRB- -LRB- m+2 -RRB- -LRB- n ? m ? 1 -RRB- -LRB- n ? m ? 2 -RRB- ? vm+3 .
Parse:
vm+1 CD ROOT
 +-- m VBN dep
 |   +-- For IN prep
 |   |   +-- example NN pobj
 |   |       +-- the DT det
 |   |       +-- second JJ amod
 |   +-- , , punct
 |   +-- payment NN nsubjpass
 |   |   +-- the DT det
 |   |   +-- total JJ amod
 |   |   +-- redistribution NN nn
 |   +-- is VBZ auxpass
 |   +-- ? . punct
 +-- ? . punct
 +-- m NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB amod
 |   +-- ? . punct
 |   +-- 2 CD num
 |   +-- -RRB- -RRB- punct
 +-- vm+3 CD dep
 +-- . . punct

11
Input: When ? vm+3 = 0 , this is equal to the total VCG payment m ? vm+1 .
Parse:
equal JJ ROOT
 +-- When WRB advmod
 +-- ? . punct
 +-- vm+3 CD nsubj
 |   +-- = SYM prep
 |       +-- 0 CD pobj
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- to IN prep
 |   +-- m NN pobj
 |       +-- the DT det
 |       +-- total JJ amod
 |       +-- VCG JJ amod
 |       +-- payment NN nn
 |       +-- ? . punct
 |       +-- vm+1 CD num
 +-- . . punct

12
Input: Thus , this mechanism also redistributes 100 % of the total VCG payment in the best case .
Parse:
redistributes VBZ ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- mechanism NN nsubj
 |   +-- this DT det
 +-- also RB advmod
 +-- % NN dobj
 |   +-- 100 CD num
 |   +-- of IN prep
 |       +-- payment NN pobj
 |           +-- the DT det
 |           +-- total JJ amod
 |           +-- VCG JJ amod
 |           +-- in IN prep
 |               +-- case NN pobj
 |                   +-- the DT det
 |                   +-- best JJS amod
 +-- . . punct

13
Input: Moreover , there are actually infinitely many mechanisms that redistribute 100 % of the total VCG payment in the best case for example , any convex combination of the above two will redistribute 100 % if both ? vm+2 = ? vm+1 and ? vm+3 = 0 .
Parse:
are VBP ROOT
 +-- Moreover RB advmod
 +-- , , punct
 +-- there EX expl
 +-- mechanisms NNS nsubj
 |   +-- many JJ amod
 |   |   +-- actually RB advmod
 |   |   +-- infinitely RB advmod
 |   +-- redistribute VBP rcmod
 |   |   +-- that WDT nsubj
 |   |   +-- % NN dobj
 |   |   |   +-- 100 CD num
 |   |   |   +-- of IN prep
 |   |   |       +-- payment NN pobj
 |   |   |           +-- the DT det
 |   |   |           +-- total JJ amod
 |   |   |           +-- VCG JJ amod
 |   |   +-- in IN prep
 |   |       +-- case NN pobj
 |   |           +-- the DT det
 |   |           +-- best JJS amod
 |   |           +-- for IN prep
 |   |               +-- example NN pobj
 |   +-- , , punct
 |   +-- redistribute VB ccomp
 |       +-- combination NN nsubj
 |       |   +-- any DT det
 |       |   +-- convex NN nn
 |       |   +-- of IN prep
 |       |       +-- two CD pobj
 |       |           +-- the DT det
 |       |           +-- above JJ amod
 |       +-- will MD aux
 |       +-- % NN dobj
 |       |   +-- 100 CD num
 |       +-- 0 CD advcl
 |           +-- if IN mark
 |           +-- both DT dep
 |           |   +-- ? . punct
 |           |   +-- vm+2 CD dep
 |           |   +-- = SYM dep
 |           |   +-- vm+1 CD conj
 |           |   +-- and CC cc
 |           +-- vm+3 CD num
 |           +-- = SYM dep
 +-- . . punct

14
Input: Dominance .
Parse:
Dominance NNP ROOT
 +-- . . punct

15
Input: Inside the family of linear VCG redistribution mechanisms , we say one mechanism dominates another mechanism if the first one redistributes at least as much as the other for any bid vector .
Parse:
say VBP ROOT
 +-- Inside IN prep
 |   +-- family NN pobj
 |       +-- the DT det
 |       +-- of IN prep
 |           +-- mechanisms NNS pobj
 |               +-- linear JJ amod
 |               +-- VCG CD num
 |               +-- redistribution NN nn
 +-- , , punct
 +-- we PRP nsubj
 +-- dominates VBZ ccomp
 |   +-- mechanism NN nsubj
 |   |   +-- one CD num
 |   +-- mechanism NN dobj
 |   |   +-- another DT det
 |   +-- redistributes VBZ advcl
 |       +-- if IN mark
 |       +-- one CD nsubj
 |       |   +-- the DT det
 |       |   +-- first JJ amod
 |       +-- much JJ dobj
 |       |   +-- least RBS advmod
 |       |   |   +-- at RB advmod
 |       |   +-- as RB advmod
 |       |   +-- as IN prep
 |       |       +-- other JJ pobj
 |       |           +-- the DT det
 |       +-- for IN prep
 |           +-- vector NN pobj
 |               +-- any DT det
 |               +-- bid NN nn
 +-- . . punct

16
Input: For the previous two examples , neither dominates the other , because they each redistribute 100 % in different cases .
Parse:
dominates VBZ ROOT
 +-- For IN prep
 |   +-- examples NNS pobj
 |       +-- the DT det
 |       +-- previous JJ amod
 |       +-- two CD num
 +-- , , punct
 +-- neither CC nsubj
 +-- other JJ dobj
 |   +-- the DT det
 +-- redistribute VBP advcl
 |   +-- because IN mark
 |   +-- they PRP nsubj
 |   |   +-- each DT det
 |   +-- % NN dobj
 |   |   +-- 100 CD num
 |   +-- in IN prep
 |       +-- cases NNS pobj
 |           +-- different JJ amod
 +-- . . punct

17
Input: It turns out that there is no mechanism in the family that dominates all other mechanisms in the family .
Parse:
turns VBZ ROOT
 +-- It PRP nsubj
 +-- out RP prt
 +-- is VBZ ccomp
 |   +-- that IN mark
 |   +-- there EX expl
 |   +-- mechanism NN nsubj
 |       +-- no DT det
 |       +-- in IN prep
 |       |   +-- family NN pobj
 |       |       +-- the DT det
 |       +-- dominates VBZ rcmod
 |           +-- that WDT nsubj
 |           +-- mechanisms NNS dobj
 |           |   +-- all DT det
 |           |   +-- other JJ amod
 |           +-- in IN prep
 |               +-- family NN pobj
 |                   +-- the DT det
 +-- . . punct

18
Input: For suppose such a mechanism exists .
Parse:
exists VBZ ROOT
 +-- For IN prep
 |   +-- suppose VB pobj
 +-- mechanism NN nsubj
 |   +-- such PDT predet
 |   +-- a DT det
 +-- . . punct

19
Input: Then , it should dominate both examples above .
Parse:
dominate VB ROOT
 +-- Then RB advmod
 +-- , , punct
 +-- it PRP nsubj
 +-- should MD aux
 +-- examples NNS dobj
 |   +-- both DT det
 |   +-- above RB advmod
 +-- . . punct

20
Input: Consider the remaining VCG payment -LRB- the VCG payment failed to be redistributed -RRB- .
Parse:
Consider VB ROOT
 +-- payment NN dobj
 |   +-- the DT det
 |   +-- remaining VBG amod
 |   +-- VCG JJ amod
 |   +-- -LRB- -LRB- punct
 |   +-- payment NN dep
 |   |   +-- the DT det
 |   |   +-- VCG NNP nn
 |   |   +-- failed VBD partmod
 |   |       +-- redistributed VBN xcomp
 |   |           +-- to TO aux
 |   |           +-- be VB auxpass
 |   +-- -RRB- -RRB- punct
 +-- . . punct

21
Input: The remaining VCG payment of the dominant mechanism should be 0 whenever ? vm+2 = ? vm+1 or ? vm+3 = 0 .
Parse:
be VB ROOT
 +-- payment NN nsubj
 |   +-- The DT det
 |   +-- remaining VBG amod
 |   +-- VCG JJ amod
 |   +-- of IN prep
 |       +-- mechanism NN pobj
 |           +-- the DT det
 |           +-- dominant JJ amod
 +-- should MD aux
 +-- 0 NFP punct
 +-- whenever WRB prep
 |   +-- ? . prep
 |   |   +-- vm+2 CD pobj
 |   +-- vm+1 CD pobj
 |       +-- = SYM dep
 |       +-- or CC cc
 |       +-- ? . punct
 |       +-- vm+3 CD conj
 +-- . . punct

22
Input: Now , the remaining VCG payment is a linear function of the ? vi -LRB- linear redistribution -RRB- , and therefore also a polynomial function .
Parse:
function NN ROOT
 +-- Now RB advmod
 +-- , , punct
 +-- payment NN nsubj
 |   +-- the DT det
 |   +-- remaining VBG amod
 |   +-- VCG PRP$ nn
 +-- is VBZ cop
 +-- a DT det
 +-- linear JJ amod
 +-- of IN prep
 |   +-- the DT pobj
 |       +-- ? , punct
 |       +-- vi NN appos
 |       +-- redistribution NN appos
 |           +-- -LRB- -LRB- punct
 |           +-- linear JJ amod
 |           +-- -RRB- -RRB- punct
 +-- and CC cc
 +-- function NN conj
 |   +-- therefore RB advmod
 |   +-- also RB advmod
 |   +-- a DT det
 |   +-- polynomial JJ amod
 +-- . . punct

23
Input: The above implies that this function can be written as -LRB- ? vm+2 ? ? vm+1 -RRB- -LRB- ? vm+3 -RRB- P -LRB- ? v1 , ? v2 , .
Parse:
implies VBZ ROOT
 +-- above JJ nsubj
 |   +-- The DT det
 +-- written VBN ccomp
 |   +-- that IN mark
 |   +-- function NN nsubjpass
 |   |   +-- this DT det
 |   +-- can MD aux
 |   +-- be VB auxpass
 |   +-- as IN prep
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- ? . punct
 |   |   +-- vm+2 NNP pobj
 |   +-- ? , punct
 |   +-- ? . punct
 |   +-- vm+1 CD dobj
 |   +-- -RRB- -RRB- punct
 |   +-- -LRB- -LRB- punct
 |   +-- vm+3 CD dobj
 |   +-- P NN dobj
 |       +-- -LRB- -LRB- punct
 |       +-- ? , punct
 |       +-- v1 CD amod
 |       +-- , , punct
 |       +-- ? . punct
 |       +-- v2 CD dep
 +-- . . punct

24
Input: .
Parse:
. . ROOT

25
Input: .
Parse:
. . ROOT

26
Input: , ? vn -RRB- , where P is a 2 The percentage redistributed seems the natural criterion to use , among other things because it is scale invariant
Parse:
vn NFP ROOT
 +-- , , punct
 +-- ? . punct
 +-- -RRB- -RRB- punct
 +-- seems VBZ dep
     +-- 2 CD advcl
     |   +-- where WRB advmod
     |   +-- P NN nsubj
     |   +-- is VBZ cop
     |   +-- a DT det
     +-- redistributed VBN nsubj
     |   +-- The DT det
     |   +-- percentage NN nn
     +-- criterion NN xcomp
         +-- the DT det
         +-- natural JJ amod
         +-- use VB infmod
             +-- to TO aux
             +-- , , punct
             +-- among IN prep
             |   +-- things NNS pobj
             |       +-- other JJ amod
             +-- scale NN advcl
                 +-- because IN mark
                 +-- it PRP nsubj
                 +-- is VBZ cop
                 +-- invariant NN dobj

27
Input: 32 polynomial function .
Parse:
function NN ROOT
 +-- 32 CD num
 +-- polynomial JJ amod
 +-- . . punct

28
Input: But since the function must be linear -LRB- has degree at most 1 -RRB- , it follows that P = 0 .
Parse:
follows VBZ ROOT
 +-- But CC cc
 +-- linear JJ advcl
 |   +-- since IN mark
 |   +-- function NN nsubj
 |   |   +-- the DT det
 |   +-- must MD aux
 |   +-- be VB cop
 |   +-- degree NN dobj
 |       +-- -LRB- -LRB- punct
 |       +-- has VBZ aux
 |       +-- at IN prep
 |       |   +-- 1 CD pobj
 |       |       +-- most RBS amod
 |       +-- -RRB- -RRB- punct
 +-- , , punct
 +-- it PRP nsubj
 +-- P NN dobj
 |   +-- that IN amod
 |   +-- = SYM dep
 |   +-- 0 CD dep
 +-- . . punct

29
Input: Thus , a dominant mechanism would always redistribute all of the VCG payment , which is not possible .
Parse:
redistribute VB ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- mechanism NN nsubj
 |   +-- a DT det
 |   +-- dominant JJ amod
 +-- would MD aux
 +-- always RB advmod
 +-- all DT dobj
 |   +-- of IN prep
 |       +-- payment NN pobj
 |           +-- the DT det
 |           +-- VCG JJ amod
 |           +-- , , punct
 |           +-- possible JJ rcmod
 |               +-- which WDT nsubj
 |               +-- is VBZ cop
 |               +-- not RB neg
 +-- . . punct

30
Input: -LRB- If it were possible , then our worst case optimal redistribution mechanism would also always redistribute all of the VCG payment , and we will see later that it does not. -RRB- Worst case performance .
Parse:
redistribute VB ROOT
 +-- -LRB- -LRB- punct
 +-- possible JJ advcl
 |   +-- If IN mark
 |   +-- it PRP nsubj
 |   +-- were VBD cop
 +-- , , punct
 +-- then RB advmod
 +-- mechanism NN nsubj
 |   +-- our PRP$ poss
 |   +-- case NN nn
 |   |   +-- worst JJS amod
 |   +-- optimal JJ amod
 |   +-- redistribution NN nn
 +-- would MD aux
 +-- also RB advmod
 +-- always RB advmod
 +-- all DT dobj
 |   +-- of IN prep
 |       +-- payment NN pobj
 |           +-- the DT det
 |           +-- VCG NNP nn
 +-- and CC cc
 +-- see VB conj
 |   +-- we PRP nsubj
 |   +-- will MD aux
 |   +-- later RB advmod
 |   +-- does VBZ ccomp
 |       +-- that IN mark
 |       +-- it PRP nsubj
 |       +-- not. NNP dobj
 +-- -RRB- -RRB- punct
 +-- performance NN dobj
 |   +-- Worst JJS amod
 |   +-- case NN nn
 +-- . . punct

31
Input: Finally , we can evaluate a mechanism by considering the lowest redistribution percentage that it guarantees .
Parse:
evaluate VB ROOT
 +-- Finally RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- mechanism NN dobj
 |   +-- a DT det
 +-- by IN prep
 |   +-- considering VBG pcomp
 |       +-- percentage NN dobj
 |           +-- the DT det
 |           +-- lowest JJS amod
 |           +-- redistribution NN nn
 |           +-- guarantees VBZ rcmod
 |               +-- that IN dobj
 |               +-- it PRP nsubj
 +-- . . punct

32
Input: For the first example , the total redistribution payment is -LRB- m+1 -RRB- m n ? vm+2 + -LRB- n ? m ? 1 -RRB- m n ? vm+1 , which is greater than or equal to -LRB- n ? m ? 1 -RRB- m n ? vm+1 .
Parse:
n NN ROOT
 +-- m+1 CD dep
 |   +-- For IN prep
 |   |   +-- example NN pobj
 |   |       +-- the DT det
 |   |       +-- first JJ amod
 |   +-- , , punct
 |   +-- payment NN nsubj
 |   |   +-- the DT det
 |   |   +-- total JJ amod
 |   |   +-- redistribution NN nn
 |   +-- is VBZ cop
 |   +-- -LRB- -LRB- punct
 |   +-- -RRB- -RRB- punct
 +-- n NNP dep
 |   +-- m NNP nn
 |   +-- ? . punct
 |   +-- vm+2 NNP dep
 |   +-- + SYM dep
 |   +-- m NN dep
 |       +-- -LRB- -LRB- punct
 |       +-- n RB amod
 |       +-- ? . punct
 |       +-- 1 CD num
 |       +-- -RRB- -RRB- punct
 +-- m NNP nn
 +-- ? . punct
 +-- vm+1 CD dep
 |   +-- , , punct
 |   +-- greater JJR rcmod
 |       +-- which WDT nsubj
 |       +-- is VBZ cop
 |       +-- than IN prep
 |           +-- or CC cc
 |           +-- equal JJ conj
 |           +-- to IN dep
 |           +-- -LRB- -LRB- punct
 |           +-- n CC cc
 |           +-- ? . punct
 |           +-- n NN pobj
 |               +-- m NNP nn
 |               |   +-- m NN nn
 |               |   +-- ? . punct
 |               |   +-- 1 CD num
 |               |   +-- -RRB- -RRB- punct
 |               +-- ? . punct
 |               +-- vm+1 CD num
 +-- . . punct

33
Input: So in the worst case , which is when ? vm+2 = 0 , the percentage redistributed is n ? m ? 1 n .
Parse:
So RB ROOT
 +-- in IN prep
 |   +-- case NN pobj
 |       +-- the DT det
 |       +-- worst JJS amod
 |       +-- , , punct
 |       +-- is VBZ rcmod
 |           +-- which WDT nsubj
 |           +-- is VBZ advcl
 |               +-- when WRB advmod
 |               +-- 0 CD parataxis
 |               |   +-- ? . punct
 |               |   +-- = FW dep
 |               |   |   +-- vm+2 NN nn
 |               |   +-- , , punct
 |               +-- redistributed VBN nsubj
 |               |   +-- the DT det
 |               |   +-- percentage NN nn
 |               +-- n RB advmod
 |               |   +-- m NN npadvmod
 |               |       +-- ? . punct
 |               |       +-- 1 CD num
 |               +-- ? . punct
 +-- . . punct

34
Input: For the second example , the total redistribution payment is m ? vm+1 ? m -LRB- m+1 -RRB- -LRB- m+2 -RRB- -LRB- n ? m ? 1 -RRB- -LRB- n ? m ? 2 -RRB- ? vm+3 , which is greater than or equal to m ? vm+1 -LRB- 1 ? -LRB- m+1 -RRB- -LRB- m+2 -RRB- -LRB- n ? m ? 1 -RRB- -LRB- n ? m ? 2 -RRB- PROGRAMMING The optimization problem given in the previous section can be rewritten as a linear program , based on the following observations .
Parse:
vm+1 CD ROOT
 +-- m VBN dep
 |   +-- For IN prep
 |   |   +-- example NN pobj
 |   |       +-- the DT det
 |   |       +-- second JJ amod
 |   +-- , , punct
 |   +-- payment NN nsubjpass
 |   |   +-- the DT det
 |   |   +-- total JJ amod
 |   |   +-- redistribution NN nn
 |   +-- is VBZ auxpass
 |   +-- ? . punct
 +-- ? . punct
 +-- m NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB amod
 |   +-- ? . punct
 |   +-- 2 CD num
 |   +-- -RRB- -RRB- punct
 +-- vm+3 CD dep
 |   +-- , , punct
 |   +-- greater JJR rcmod
 |       +-- which WDT nsubj
 |       +-- is VBZ cop
 |       +-- than IN prep
 |           +-- or CC cc
 |           +-- equal JJ conj
 |           +-- to IN dep
 |               +-- rewritten VBN pobj
 |                   +-- m VB dep
 |                   +-- ? . punct
 |                   +-- vm+1 NN nsubjpass
 |                   |   +-- 1 CD dep
 |                   |   |   +-- -LRB- -LRB- punct
 |                   |   |   +-- ? . punct
 |                   |   |   +-- m+1 CD dep
 |                   |   |   |   +-- -LRB- -LRB- punct
 |                   |   |   +-- -RRB- -RRB- punct
 |                   |   +-- -LRB- -LRB- punct
 |                   |   +-- m+2 CD dep
 |                   |   +-- -RRB- -RRB- punct
 |                   |   +-- m NN dep
 |                   |   |   +-- -LRB- -LRB- punct
 |                   |   |   +-- n RB advmod
 |                   |   |   +-- ? . punct
 |                   |   |   +-- 1 CD num
 |                   |   |   +-- -RRB- -RRB- punct
 |                   |   |   +-- m NN appos
 |                   |   |       +-- -LRB- -LRB- punct
 |                   |   |       +-- n RB amod
 |                   |   |       +-- ? . punct
 |                   |   |       +-- 2 CD num
 |                   |   |       +-- -RRB- -RRB- punct
 |                   |   +-- PROGRAMMING VBG partmod
 |                   |       +-- problem NN dobj
 |                   |           +-- The DT det
 |                   |           +-- optimization NN nn
 |                   |           +-- given VBN partmod
 |                   |               +-- in IN prep
 |                   |                   +-- section NN pobj
 |                   |                       +-- the DT det
 |                   |                       +-- previous JJ amod
 |                   +-- can MD aux
 |                   +-- be VB auxpass
 |                   +-- as IN prep
 |                       +-- program NN pobj
 |                           +-- a DT det
 |                           +-- linear JJ amod
 |                           +-- , , punct
 |                           +-- based VBN partmod
 |                               +-- on IN prep
 |                                   +-- observations NNS pobj
 |                                       +-- the DT det
 |                                       +-- following VBG amod
 +-- . . punct

35
Input: Claim 1 .
Parse:
Claim NNP ROOT
 +-- 1 CD num
 +-- . . punct

36
Input: If c0 , c1 , .
Parse:
If IN ROOT
 +-- c0 CD dep
 |   +-- , , punct
 |   +-- c1 CD appos
 +-- . . punct

37
Input: .
Parse:
. . ROOT

38
Input: .
Parse:
. . ROOT

39
Input: , cn ? 1 satisfy both the individual rationality and the non deficit constraints , then ci = 0 for i = 0 , .
Parse:
satisfy VB ROOT
 +-- , , punct
 +-- cn NNP nsubj
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- rationality NN dobj
 |   +-- both CC preconj
 |   +-- the DT det
 |   +-- individual JJ amod
 |   +-- and CC cc
 |   +-- constraints NNS conj
 |   |   +-- the DT det
 |   |   +-- deficit NN nn
 |   |   |   +-- non FW nn
 |   |   +-- , , punct
 |   |   +-- then RB advmod
 |   |   +-- ci NNP dep
 |   |   +-- = SYM dep
 |   |   +-- 0 NFP punct
 |   |   +-- for IN prep
 |   |       +-- i PRP pobj
 |   +-- = : punct
 |   +-- 0 CD punct
 +-- . . punct

40
Input: .
Parse:
. . ROOT

41
Input: .
Parse:
. . ROOT

42
Input: , m .
Parse:
m UH ROOT
 +-- , , punct
 +-- . . punct

43
Input: Proof .
Parse:
Proof NNP ROOT
 +-- . . punct

44
Input: First , let us prove that c0 = 0 .
Parse:
let VB ROOT
 +-- First RB advmod
 +-- , , punct
 +-- prove VB ccomp
 |   +-- us PRP nsubj
 |   +-- c0 LS dobj
 |       +-- that IN amod
 +-- = SYM punct
 +-- 0 NFP punct
 +-- . . punct

45
Input: Consider the bid vector in which ? vi = 0 for all i .
Parse:
Consider VB ROOT
 +-- vector NN dobj
 |   +-- the DT det
 |   +-- bid NN nn
 |   +-- in IN prep
 |       +-- which WDT pobj
 +-- ? . punct
 +-- = SYM dobj
 |   +-- vi NN nn
 |   +-- 0 CD punct
 |   +-- for IN prep
 |       +-- i PRP pobj
 |           +-- all DT det
 +-- . . punct

46
Input: To obtain individual rationality , we must have c0 ? 0 .
Parse:
have VB ROOT
 +-- obtain VB advcl
 |   +-- To TO aux
 |   +-- rationality NN dobj
 |       +-- individual JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- must MD aux
 +-- c0 CD dobj
 +-- ? . punct
 +-- 0 NFP punct
 +-- . . punct

47
Input: To satisfy the non deficit constraint , we must have c0 ? 0 .
Parse:
have VB ROOT
 +-- satisfy VB advcl
 |   +-- To TO aux
 |   +-- constraint NN dobj
 |       +-- the DT det
 |       +-- deficit NN nn
 |           +-- non JJ nn
 +-- , , punct
 +-- we PRP nsubj
 +-- must MD aux
 +-- c0 CD dobj
 +-- ? . punct
 +-- 0 NFP punct
 +-- . . punct

48
Input: Thus we know c0 = 0 .
Parse:
know VBP ROOT
 +-- Thus RB advmod
 +-- we PRP nsubj
 +-- 0 CD dobj
 |   +-- c0 CD num
 |   +-- = SYM dep
 +-- . . punct

49
Input: Now , if ci = 0 for all i , there is nothing to prove .
Parse:
is VBZ ROOT
 +-- Now RB advmod
 +-- , , punct
 +-- ci NN advcl
 |   +-- if IN mark
 |   +-- = FW dep
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- all DT pobj
 +-- i PRP dep
 +-- there EX expl
 +-- nothing NN nsubj
 |   +-- prove VB infmod
 |       +-- to TO aux
 +-- . . punct

50
Input: Otherwise , let j = min -LRB- i|ci = 0 -RRB- .
Parse:
let VB ROOT
 +-- Otherwise RB advmod
 +-- , , punct
 +-- j DT dobj
 |   +-- = SYM prep
 |   |   +-- min FW dep
 |   +-- i|ci NNP appos
 |       +-- -LRB- -LRB- punct
 |       +-- = SYM dep
 |       |   +-- 0 CD num
 |       +-- -RRB- -RRB- punct
 +-- . . punct

51
Input: Assume that j ? m .
Parse:
j FW ROOT
 +-- Assume VB dep
 +-- that DT det
 +-- ? . punct
 +-- m NN dep
 +-- . . punct

52
Input: We recall that we can write the individual rationality constraint as follows
Parse:
recall VBP ROOT
 +-- We PRP nsubj
 +-- write VB ccomp
     +-- that IN mark
     +-- we PRP nsubj
     +-- can MD aux
     +-- constraint NN dobj
     |   +-- the DT det
     |   +-- individual JJ amod
     |   +-- rationality NN nn
     +-- follows VBZ advcl
         +-- as IN mark

53
Input: .
Parse:
. . ROOT

54
Input: .+cn ? 2 ? vn ? 2 +cn ? 1 ? vn ? 1 ? 0 for any bid vector .
Parse:
.+cn NNP ROOT
 +-- ? . punct
 +-- 2 CD num
 +-- vn NN dep
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- +cn NN dep
 |   +-- 2 CD num
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- vector NN pobj
 |       +-- any DT det
 |       +-- bid NN nn
 +-- . . punct

55
Input: Let us consider the bid vector in which ? vi = 1 for i ? j and ? vi = 0 for the rest .
Parse:
Let VB ROOT
 +-- consider VB ccomp
 |   +-- us PRP nsubj
 |   +-- vi NN ccomp
 |       +-- vector NN nsubj
 |       |   +-- the DT det
 |       |   +-- bid NN nn
 |       +-- in IN prep
 |       |   +-- which WDT pobj
 |       +-- ? . punct
 |       +-- = : prep
 |       |   +-- 1 CD dep
 |       +-- for IN prep
 |       |   +-- i PRP pobj
 |       +-- ? , punct
 |       +-- j UH conj
 |       +-- and CC cc
 |       +-- vi NN conj
 |           +-- = SYM dep
 |           +-- 0 CD punct
 |           +-- for IN prep
 |               +-- rest NN pobj
 |                   +-- the DT det
 +-- . . punct

56
Input: In this case zn = cj , so we must have cj ? 0 .
Parse:
have VB ROOT
 +-- In IN prep
 |   +-- case NN pobj
 |       +-- this DT det
 +-- zn , punct
 +-- = SYM discourse
 |   +-- cj UH dep
 +-- , , punct
 +-- so IN advmod
 +-- we PRP nsubj
 +-- must MD aux
 +-- cj NNP dobj
 +-- ? . punct
 +-- 0 NFP punct
 +-- . . punct

57
Input: The non deficit constraint can be written as follows
Parse:
written VBN ROOT
 +-- constraint NN nsubjpass
 |   +-- The DT det
 |   +-- deficit NN nn
 |       +-- non NNP nn
 +-- can MD aux
 +-- be VB auxpass
 +-- follows VBZ advcl
     +-- as IN mark

58
Input: .
Parse:
. . ROOT

59
Input: .
Parse:
. . ROOT

60
Input: + zn ? m ? vm+1 for any bid vector .
Parse:
zn UH ROOT
 +-- + SYM dep
 +-- ? . punct
 +-- m NN dep
 |   +-- ? . punct
 |   +-- vm+1 CD dep
 |       +-- for IN prep
 |           +-- vector NN pobj
 |               +-- any DT det
 |               +-- bid NN nn
 +-- . . punct

61
Input: Consider the same bid vector as above .
Parse:
Consider VB ROOT
 +-- vector NN dobj
 |   +-- the DT det
 |   +-- same JJ amod
 |   +-- bid NN nn
 +-- above RB advmod
 |   +-- as RB advmod
 +-- . . punct

62
Input: We have zi = 0 for i ? j , because for these bids , the jth highest other bid has value 0 , so all the ci that are nonzero are multiplied by 0 .
Parse:
have VBP ROOT
 +-- We PRP nsubj
 +-- zi NN dobj
 +-- = : punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- i PRP pobj
 +-- ? . punct
 +-- j UH discourse
 +-- , , punct
 +-- has VBZ advcl
 |   +-- because IN mark
 |   +-- for IN prep
 |   |   +-- bids NNS pobj
 |   |       +-- these DT det
 |   +-- , , punct
 |   +-- bid NN nsubj
 |   |   +-- the DT det
 |   |   +-- highest JJS amod
 |   |   |   +-- jth RB advmod
 |   |   +-- other JJ amod
 |   +-- value NN dobj
 |   +-- 0 NFP punct
 |   +-- so RB cc
 |   +-- multiplied VBN conj
 |       +-- ci NN nsubjpass
 |       |   +-- all PDT predet
 |       |   +-- the DT det
 |       |   +-- nonzero PRP rcmod
 |       |       +-- that WDT nsubj
 |       |       +-- are VBP cop
 |       +-- are VBP auxpass
 |       +-- by IN prep
 |           +-- 0 CD pobj
 +-- . . punct

63
Input: For i > j , we have zi = cj , because the jth highest other bid has value 1 , and all lower bids have value 0 .
Parse:
have VBP ROOT
 +-- For IN prep
 |   +-- i PRP pobj
 |       +-- > VBZ prep
 |           +-- j NFP pobj
 +-- , , punct
 +-- we PRP nsubj
 +-- cj NNP dobj
 |   +-- zi NN nn
 |   +-- = , nn
 +-- has VBZ advcl
 |   +-- because IN mark
 |   +-- bid NN nsubj
 |   |   +-- the DT det
 |   |   +-- highest JJS amod
 |   |   |   +-- jth RB advmod
 |   |   +-- other JJ amod
 |   +-- value NN dobj
 |   |   +-- 1 CD num
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- value NN conj
 |       +-- bids NNS nsubj
 |       |   +-- all DT det
 |       |   +-- lower JJR amod
 |       +-- have VBP aux
 |       +-- 0 CD num
 +-- . . punct

64
Input: So the non deficit constraint tells us that cj -LRB- n ? j -RRB- ? m ? vm+1 .
Parse:
tells VBZ ROOT
 +-- So IN dep
 +-- constraint NN nsubj
 |   +-- the DT det
 |   +-- deficit NN nn
 |       +-- non FW nn
 +-- us PRP dobj
 +-- that IN punct
     +-- cj . dep
         +-- n RB dep
             +-- -LRB- -LRB- punct
             +-- ? . punct
             +-- j NNP dep
             +-- -RRB- -RRB- punct
             +-- m NN dep
             |   +-- ? . punct
             |   +-- vm+1 CD num
             +-- . . punct

65
Input: Because j ? m , ? vm+1 = 0 , so the right hand side is 0 .
Parse:
0 CD ROOT
 +-- is VBZ advcl
 |   +-- Because IN mark
 |   +-- j NNP nsubj
 |   |   +-- ? . punct
 |   |   +-- m NNP dep
 |   |   +-- , , punct
 |   |   +-- 0 CD dep
 |   |       +-- vm+1 CD num
 |   |       +-- = SYM dep
 |   +-- , , punct
 |   +-- so IN advmod
 |   +-- side NN nsubj
 |       +-- the DT det
 |       +-- right JJ amod
 |       +-- hand NN nn
 +-- . . punct

66
Input: We also have n ? j > 0 because j ? m < n .
Parse:
have VBP ROOT
 +-- We PRP nsubj
 +-- also RB advmod
 +-- j FW dobj
 |   +-- n CC dep
 |   |   +-- ? . punct
 |   +-- > -RRB- punct
 +-- 0 CD punct
 +-- j GW advcl
 |   +-- because IN mark
 |   +-- ? . punct
 |   +-- m NNP dep
 |   +-- < -LRB- punct
 |   +-- n UH advmod
 +-- . . punct

67
Input: So cj ? 0 .
Parse:
cj GW ROOT
 +-- So RB advmod
 +-- ? . punct
 +-- 0 NFP punct
 +-- . . punct

68
Input: Because we have already established that cj ? 0 , it follows that cj = 0 ; but this is contrary to assumption .
Parse:
follows VBZ ROOT
 +-- established VBN advcl
 |   +-- Because IN mark
 |   +-- we PRP nsubj
 |   +-- have VBP aux
 |   +-- already RB advmod
 |   +-- cj NNP dobj
 |   |   +-- that DT det
 |   +-- ? . punct
 |   +-- 0 NFP punct
 +-- , , punct
 +-- it PRP nsubj
 +-- = SYM ccomp
 |   +-- that IN mark
 |   +-- cj , punct
 |   +-- 0 CD dep
 |   +-- ; : punct
 |   +-- but CC cc
 |   +-- contrary JJ conj
 |       +-- this DT nsubj
 |       +-- is VBZ cop
 |       +-- to TO prep
 |           +-- assumption NN pobj
 +-- . . punct

69
Input: So j > m .
Parse:
m NN ROOT
 +-- So RB dep
 +-- j DT det
 +-- > -RRB- punct
 +-- . . punct

70
Input: Incidentally , this claim also shows that if m = n ? 1 , then ci = 0 for all i .
Parse:
shows VBZ ROOT
 +-- Incidentally RB advmod
 +-- , , punct
 +-- claim NN nsubj
 |   +-- this DT det
 +-- also RB advmod
 +-- 1 CD dep
 |   +-- that IN mark
 |   +-- n RB dep
 |   |   +-- if IN mark
 |   |   +-- m NN dep
 |   |   +-- = : dep
 |   +-- ? . punct
 |   +-- , , punct
 |   +-- then RB advmod
 |   +-- ci NN dep
 |   +-- = SYM dep
 |   +-- 0 NFP punct
 |   +-- for IN prep
 |   |   +-- all DT pobj
 |   +-- i PRP dep
 +-- . . punct

71
Input: Thus , we are stuck with the VCG mechanism .
Parse:
stuck VBN ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- we PRP nsubjpass
 +-- are VBP auxpass
 +-- with IN prep
 |   +-- mechanism NN pobj
 |       +-- the DT det
 |       +-- VCG NNP nn
 +-- . . punct

72
Input: From here on , we only consider the case where m < n ? 1 .
Parse:
consider VBP ROOT
 +-- From IN prep
 |   +-- here RB pcomp
 |       +-- on RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- only RB advmod
 +-- 1 CD xcomp
 |   +-- case NN nsubj
 |   |   +-- the DT det
 |   +-- m NN dep
 |       +-- where WRB advmod
 |       +-- < -LRB- punct
 |       +-- n RB advmod
 |       +-- ? . punct
 +-- . . punct

73
Input: Claim 2 .
Parse:
Claim NNP ROOT
 +-- 2 CD num
 +-- . . punct

74
Input: The individual rationality constraint can be written as follows
Parse:
written VBN ROOT
 +-- constraint NN nsubjpass
 |   +-- The DT det
 |   +-- individual JJ amod
 |   +-- rationality NN amod
 +-- can MD aux
 +-- be VB auxpass
 +-- follows VBZ advcl
     +-- as IN mark

75
Input: .
Parse:
. . ROOT

76
Input: .
Parse:
. . ROOT

77
Input: , n ? 1 .
Parse:
1 CD ROOT
 +-- , , punct
 +-- n CC advmod
 +-- ? . punct
 +-- . . punct

78
Input: Before proving this claim , we introduce the following lemma .
Parse:
introduce VBP ROOT
 +-- Before IN prep
 |   +-- proving VBG pcomp
 |       +-- claim NN dobj
 |           +-- this DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- lemma NN dobj
 |   +-- the DT det
 |   +-- following VBG amod
 +-- . . punct

79
Input: Lemma 1 .
Parse:
Lemma NNP ROOT
 +-- 1 CD num
 +-- . . punct

80
Input: Given a positive integer k and a set of real constants s1 , s2 , .
Parse:
Given VBN ROOT
 +-- k CD dep
 |   +-- a DT det
 |   +-- integer NN nn
 |   |   +-- positive JJ amod
 |   +-- and CC cc
 |   +-- set NN conj
 |       +-- a DT det
 |       +-- of IN prep
 |           +-- constants NNS pobj
 |               +-- real JJ amod
 |               +-- s1 CD num
 |               +-- , , punct
 |               +-- s2 CD appos
 +-- . . punct

81
Input: .
Parse:
. . ROOT

82
Input: .
Parse:
. . ROOT

83
Input: , sk , -LRB- s1t1 + s2t2 + .
Parse:
sk UH ROOT
 +-- , , punct
 +-- -LRB- -LRB- punct
 +-- s1t1 CD dep
 |   +-- + SYM cc
 |   +-- s2t2 CD conj
 +-- + SYM dep
 +-- . . punct

84
Input: .
Parse:
. . ROOT

85
Input: .
Parse:
. . ROOT

86
Input: + sktk ? 0 for any t1 ? t2 ? .
Parse:
sktk UH ROOT
 +-- + SYM amod
 +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- t1 CD pobj
 |       +-- any DT det
 +-- t2 CD dep
 +-- . . punct

87
Input: .
Parse:
. . ROOT

88
Input: .
Parse:
. . ROOT

89
Input: ? tk ? 0 -RRB- if and only if -LRB- Pj i=1 si ? 0 for j = 1 , 2 , .
Parse:
tk UH ROOT
 +-- ? . punct
 +-- 0 NFP punct
 +-- -RRB- -RRB- punct
 +-- if IN prep
 |   +-- and CC cc
 |   +-- only RB conj
 |       +-- if IN pcomp
 |           +-- i=1 CD pobj
 |               +-- -LRB- -LRB- punct
 |               +-- Pj FW nn
 |               +-- si NN dep
 |               |   +-- ? . punct
 |               +-- 0 NFP punct
 |               +-- for IN prep
 |               |   +-- j NN pobj
 |               +-- = SYM dep
 |               |   +-- 1 CD num
 |               +-- , , punct
 |               +-- 2 CD dep
 +-- . . punct

90
Input: .
Parse:
. . ROOT

91
Input: .
Parse:
. . ROOT

92
Input: , k -RRB- .
Parse:
k CD ROOT
 +-- , , punct
 +-- -RRB- -RRB- punct
 +-- . . punct

93
Input: Proof .
Parse:
Proof NNP ROOT
 +-- . . punct

94
Input: Let di = ti ? ti+1 for i = 1 , 2 , .
Parse:
Let VB ROOT
 +-- = VB ccomp
 |   +-- di NNP nsubj
 |   +-- ti NN dobj
 +-- ? . punct
 +-- ti+1 CD dep
 |   +-- for IN prep
 |   |   +-- i PRP pobj
 |   +-- = : punct
 |   +-- 1 CD dep
 |       +-- , , punct
 |       +-- 2 CD amod
 +-- . . punct

95
Input: .
Parse:
. . ROOT

96
Input: .
Parse:
. . ROOT

97
Input: , k ? 1 , and dk = tk .
Parse:
k NN ROOT
 +-- , , punct
 +-- ? . punct
 +-- 1 CD num
 +-- and CC cc
 +-- dk NN conj
 |   +-- = SYM prep
 |       +-- tk NN pobj
 +-- . . punct

98
Input: Then -LRB- s1t1 +s2t2 + .
Parse:
+s2t2 CD ROOT
 +-- Then RB dep
 +-- -LRB- -LRB- punct
 +-- s1t1 CD num
 +-- + SYM advmod
 +-- . . punct

99
Input: .
Parse:
. . ROOT

100
Input: .+sktk ? 0 for any t1 ? t2 ? .
Parse:
.+sktk UH ROOT
 +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- t1 CD pobj
 |       +-- any DT det
 +-- t2 CD dep
 +-- . . punct

101
Input: .
Parse:
. . ROOT

102
Input: .
Parse:
. . ROOT

103
Input: ? tk ? 0 -RRB- is equivalent to -LRB- -LRB- P1 i=1 si -RRB- d1 + -LRB- P2 i=1 si -RRB- d2 + .
Parse:
equivalent JJ ROOT
 +-- tk UH nsubj
 |   +-- ? . punct
 |   +-- 0 NFP punct
 |   +-- -RRB- -RRB- punct
 +-- is VBZ cop
 +-- to IN prep
 |   +-- -LRB- -LRB- punct
 |   +-- P1 CD dep
 |   |   +-- si FW dep
 |   |       +-- i=1 CD num
 |   +-- -RRB- -RRB- punct
 |   +-- d1 CD pobj
 +-- + SYM punct
 +-- i=1 CD dep
 |   +-- -LRB- -LRB- punct
 |   +-- P2 CD num
 |   +-- si NNP dep
 |   +-- -RRB- -RRB- punct
 |   +-- d2 CD dep
 |   +-- + SYM dep
 +-- . . punct

104
Input: .
Parse:
. . ROOT

105
Input: .
Parse:
. . ROOT

106
Input: + -LRB- Pk i=1 si -RRB- dk ? 0 for any set of arbitrary non negative dj -RRB- .
Parse:
+ SYM ROOT
 +-- dk NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- Pk UH discourse
 |   +-- si NNP dep
 |   |   +-- i=1 CD nn
 |   |   +-- -RRB- -RRB- punct
 |   +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- set NN pobj
 |       +-- any DT det
 |       +-- of IN prep
 |           +-- dj NN pobj
 |               +-- arbitrary JJ amod
 |               +-- non FW nn
 |               +-- negative JJ amod
 +-- -RRB- -RRB- punct
 +-- . . punct

107
Input: When Pj i=1 si ? 0 for j = 1 , 2 , .
Parse:
2 CD ROOT
 +-- si VBZ dep
 |   +-- When WRB advmod
 |   +-- i=1 CD nsubj
 |   |   +-- Pj FW nn
 |   +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- j NN pobj
 +-- = SYM dep
 |   +-- 1 CD num
 |   +-- , , punct
 +-- , , punct
 +-- . . punct

108
Input: .
Parse:
. . ROOT

109
Input: .
Parse:
. . ROOT

110
Input: , k , the above inequality is obviously true .
Parse:
true JJ ROOT
 +-- , , punct
 +-- k CD nsubj
 +-- inequality NN nsubj
 |   +-- the DT det
 |   +-- above JJ amod
 +-- is VBZ cop
 +-- obviously RB advmod
 +-- . . punct

111
Input: If for some j , Pj i=1 si < 0 , if we set dj > 0 and di = 0 for all i = j , then the above inequality becomes false .
Parse:
false JJ ROOT
 +-- for IN advcl
 |   +-- If IN mark
 |   +-- j NN pobj
 |       +-- some DT det
 +-- , , punct
 +-- Pj NFP punct
 +-- i=1 CD nsubj
 +-- = VBP dep
 |   +-- si FW dep
 |   +-- < -LRB- punct
 |   +-- 0 NFP punct
 |   +-- , , punct
 |   +-- set VBD advcl
 |   |   +-- if IN mark
 |   |   +-- we PRP nsubj
 |   |   +-- = NNP dobj
 |   |       +-- dj . dep
 |   |       +-- > -RRB- punct
 |   |       +-- 0 CD dep
 |   |           +-- and CC cc
 |   |           +-- di NNP conj
 |   +-- for IN prep
 |   |   +-- all DT pobj
 |   +-- i PRP nsubj
 +-- j UH discourse
 +-- then RB advmod
 +-- inequality NN nsubj
 |   +-- the DT det
 |   +-- above JJ amod
 +-- becomes VBZ cop
 +-- . . punct

112
Input: So Pj i=1 si ? 0 for j = 1 , 2 , .
Parse:
Pj GW ROOT
 +-- So RB advmod
 +-- si NNP nsubj
 |   +-- i=1 CD num
 +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- j NN pobj
 |   +-- = SYM dep
 |       +-- 1 CD num
 |       +-- , , punct
 |       +-- 2 CD num
 +-- , , punct
 +-- . . punct

113
Input: .
Parse:
. . ROOT

114
Input: .
Parse:
. . ROOT

115
Input: , k is both necessary and sufficient .
Parse:
necessary JJ ROOT
 +-- , , punct
 +-- k CD nsubj
 +-- is VBZ cop
 +-- both DT preconj
 +-- and CC cc
 +-- sufficient JJ conj
 +-- . . punct

116
Input: We are now ready to present the proof of Claim 2 .
Parse:
ready JJ ROOT
 +-- We PRP nsubj
 +-- are VBP cop
 +-- now RB advmod
 +-- present VB xcomp
 |   +-- to TO aux
 |   +-- proof NN dobj
 |       +-- the DT det
 |       +-- of IN prep
 |           +-- Claim NNP pobj
 |               +-- 2 CD num
 +-- . . punct

117
Input: Proof .
Parse:
Proof NNP ROOT
 +-- . . punct

118
Input: The individual rationality constraint can be written as zn = c0 + c1 ? v1 + c2 ? v2 + c3 ? v3 + .
Parse:
written VBN ROOT
 +-- constraint NN nsubjpass
 |   +-- The DT det
 |   +-- individual JJ amod
 |   +-- rationality NN amod
 +-- can MD aux
 +-- be VB auxpass
 +-- as IN prep
 |   +-- c3 CD pobj
 |       +-- zn , nn
 |       +-- = SYM dep
 |       +-- c0 CD number
 |       +-- + SYM dep
 |       +-- c1 CD dep
 |       |   +-- ? . punct
 |       |   +-- c2 CD dep
 |       |       +-- v1 CD num
 |       |       +-- + SYM dep
 |       +-- v2 CD num
 |       +-- ? . punct
 |       +-- v3 CD dep
 |           +-- + SYM prep
 +-- . . punct

119
Input: .
Parse:
. . ROOT

120
Input: .
Parse:
. . ROOT

121
Input: + cn ? 2 ? vn ? 2 + cn ? 1 ? vn ? 1 ? 0 for any bid vector ? v1 ? ? v2 ? .
Parse:
cn NN ROOT
 +-- + SYM nn
 +-- ? . punct
 +-- 2 CD num
 +-- vn SYM dep
 +-- ? , punct
 +-- cn NN dep
 |   +-- + SYM nn
 |       +-- 2 CD number
 +-- 1 CD dep
 +-- vn NN dep
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- vector NN pobj
 |       +-- any DT det
 |       +-- bid NN nn
 +-- v1 CD dep
 +-- v2 CD dep
 +-- . . punct

122
Input: .
Parse:
. . ROOT

123
Input: .
Parse:
. . ROOT

124
Input: ? ? vn ? 1 ? ? vn ? 0 .
Parse:
? . ROOT
 +-- ? . punct
 +-- vn UH dep
 +-- 1 CD dep
 +-- vn SYM dep
 +-- 0 NFP punct
 +-- . . punct

125
Input: We have already shown that ci = 0 for i ? m .
Parse:
shown VBN ROOT
 +-- We PRP nsubj
 +-- have VBP aux
 +-- already RB advmod
 +-- ci NN dobj
 |   +-- that IN det
 |   +-- = SYM advmod
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- i PRP pobj
 +-- ? . punct
 +-- m NN dobj
 +-- . . punct

126
Input: Thus , the above can be simplified to zn = cm+1 ? vm+1 + cm+2 ? vm+2+ .
Parse:
simplified VBN ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- above RB nsubjpass
 |   +-- the DT det
 +-- can MD aux
 +-- be VB auxpass
 +-- to IN prep
 |   +-- zn VB pobj
 |       +-- = , punct
 |       +-- cm+1 CD num
 |       +-- ? . punct
 |       +-- cm+2 CD num
 |       |   +-- vm+1 NNP nn
 |       |   +-- + SYM dep
 |       +-- vm+2+ CD num
 +-- . . punct

127
Input: .
Parse:
. . ROOT

128
Input: .+cn ? 2 ? vn ? 2+cn ? 1 ? vn ? 1 ? 0 for any bid vector .
Parse:
.+cn NNP ROOT
 +-- ? . punct
 +-- 2 CD num
 +-- vn NN dep
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- 2+cn CD dep
 |   +-- ? . punct
 |   +-- 1 CD num
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- vector NN pobj
 |       +-- any DT det
 |       +-- bid NN nn
 +-- . . punct

129
Input: By the above lemma , this is equivalent to Pj i=m+1 ci ? 0 for j = m + 1 , .
Parse:
equivalent JJ ROOT
 +-- By IN prep
 |   +-- lemma NN pobj
 |       +-- the DT det
 |       +-- above JJ amod
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- to IN prep
 |   +-- ci NN pobj
 |       +-- Pj GW amod
 |       +-- i=m+1 CD nn
 +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- j FW pobj
 +-- = : punct
 +-- m NN dobj
 |   +-- + SYM dep
 |   +-- 1 CD num
 +-- . . punct

130
Input: .
Parse:
. . ROOT

131
Input: .
Parse:
. . ROOT

132
Input: , n ? 1 .
Parse:
1 CD ROOT
 +-- , , punct
 +-- n CC advmod
 +-- ? . punct
 +-- . . punct

133
Input: Claim 3 .
Parse:
Claim NN ROOT
 +-- 3 CD num
 +-- . . punct

134
Input: The non deficit constraint and the worst case constraint can also be written as linear inequalities involving only the ci and k .
Parse:
written VBN ROOT
 +-- constraint NN nsubjpass
 |   +-- The DT det
 |   +-- deficit NN nn
 |   |   +-- non NNP nn
 |   +-- and CC cc
 |   +-- constraint NN conj
 |       +-- the DT det
 |       +-- case NN nn
 |           +-- worst JJS amod
 +-- can MD aux
 +-- also RB advmod
 +-- be VB auxpass
 +-- as IN prep
 |   +-- inequalities NNS pobj
 |       +-- linear JJ amod
 |       +-- involving VBG partmod
 |           +-- ci NN dobj
 |               +-- only RB advmod
 |               +-- the DT det
 |               +-- and CC cc
 |               +-- k CD conj
 +-- . . punct

135
Input: Proof .
Parse:
Proof NNP ROOT
 +-- . . punct

136
Input: The non deficit constraint requires that for any bid vector , z1 +z2 + .
Parse:
requires VBZ ROOT
 +-- constraint NN nsubj
 |   +-- The DT det
 |   +-- deficit NN nn
 |       +-- non JJ nn
 +-- +z2 CD ccomp
 |   +-- that IN mark
 |   +-- for IN prep
 |   |   +-- vector NN pobj
 |   |       +-- any DT det
 |   |       +-- bid NN nn
 |   +-- , , punct
 |   +-- z1 CD num
 |   +-- + SYM advmod
 +-- . . punct

137
Input: .
Parse:
. . ROOT

138
Input: .+zn ? m ? vm+1 , where zi = c0 +c1 ? v1 + 33 c2 ? v2 + .
Parse:
m NN ROOT
 +-- .+zn UH nn
 +-- ? . punct
 +-- vm+1 CD num
 +-- , , punct
 +-- v2 CD rcmod
 |   +-- where WRB advmod
 |   +-- +c1 CD nsubj
 |   |   +-- zi NN nn
 |   |   +-- = SYM dep
 |   |   +-- c0 CD number
 |   |   +-- ? . punct
 |   +-- v1 CD num
 |   +-- + SYM dep
 |   |   +-- c2 CD num
 |   |   |   +-- 33 CD number
 |   |   +-- ? . punct
 |   +-- + SYM advmod
 +-- . . punct

139
Input: .
Parse:
. . ROOT

140
Input: .+ci ? 1 ? vi ? 1 +ci ? vi+1 + .
Parse:
.+ci NNP ROOT
 +-- ? . punct
 +-- 1 CD num
 +-- vi NN dep
 +-- +ci NN dep
 |   +-- 1 CD num
 +-- vi+1 CD dep
 +-- + SYM dep
 +-- . . punct

141
Input: .
Parse:
. . ROOT

142
Input: .+cn ? 1 ? vn for i = 1 , 2 , .
Parse:
.+cn NNP ROOT
 +-- ? . punct
 +-- 1 CD num
 +-- vn , dep
 |   +-- for IN prep
 |       +-- 1 CD pobj
 |           +-- i PRP dep
 |           +-- = : punct
 |           +-- , , punct
 |           +-- 2 CD amod
 +-- . . punct

143
Input: .
Parse:
. . ROOT

144
Input: .
Parse:
. . ROOT

145
Input: , n .
Parse:
n CC ROOT
 +-- , , punct
 +-- . . punct

146
Input: Because ci = 0 for i ? m , we can simplify this inequality to qm+1 ? vm+1 + qm+2 ? vm+2 + .
Parse:
simplify VB ROOT
 +-- = SYM advcl
 |   +-- Because IN mark
 |   +-- ci NNP nsubj
 |   +-- 0 CD dep
 |   +-- for IN prep
 |       +-- m NN pobj
 |           +-- i PRP dep
 |           +-- ? . punct
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- inequality NN dobj
 |   +-- this DT det
 +-- to IN prep
 |   +-- qm+1 CD pobj
 +-- ? . punct
 +-- qm+2 CD dobj
 |   +-- vm+1 NNP nn
 |   +-- + SYM dep
 +-- vm+2 CD dobj
 |   +-- + SYM advmod
 +-- . . punct

147
Input: .
Parse:
. . ROOT

148
Input: .
Parse:
. . ROOT

149
Input: + qn ? vn ? 0 qm+1 = m ? -LRB- n ? m ? 1 -RRB- cm+1 qi = ? -LRB- i ? 1 -RRB- ci ? 1 ? -LRB- n ? i -RRB- ci , for i = m+2 , .
Parse:
qn UH ROOT
 +-- + SYM dep
 +-- ? . punct
 +-- vn UH dep
 +-- 0 NFP punct
 +-- qm+1 CD dep
 +-- = SYM dep
 +-- m NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB amod
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- -RRB- -RRB- punct
 +-- qi NN dep
 |   +-- cm+1 CD num
 +-- i PRP dep
 |   +-- -LRB- -LRB- punct
 |   +-- ? . punct
 |   +-- 1 CD dep
 |   +-- -RRB- -RRB- punct
 |   +-- ci NN dep
 |   |   +-- ? . punct
 |   |   +-- 1 CD num
 |   +-- n RB dep
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- ? . punct
 |   |   +-- i NNP dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- ci UH dep
 |   +-- , , punct
 |   +-- for IN prep
 |   |   +-- i PRP pobj
 |   +-- = : punct
 |   +-- m+2 CD dep
 +-- . . punct

150
Input: .
Parse:
. . ROOT

151
Input: .
Parse:
. . ROOT

152
Input: , n ? 1 -LRB- when m + 2 > n ? 1 , this set of equalities is empty -RRB- qn = ? -LRB- n ? 1 -RRB- cn ? 1 By the above lemma , this is equivalent to Pj i=m+1 qi ? 0 for j = m + 1 , .
Parse:
equivalent JJ ROOT
 +-- = SYM dep
 |   +-- 1 CD dep
 |   |   +-- + SYM dep
 |   |   |   +-- n CC dep
 |   |   |   |   +-- , , punct
 |   |   |   |   +-- ? . punct
 |   |   |   +-- 1 CD dep
 |   |   |   +-- -LRB- -LRB- punct
 |   |   |   +-- when WRB advmod
 |   |   |   +-- m NN dep
 |   |   |   +-- 2 CD dep
 |   |   |   +-- > -RRB- punct
 |   |   +-- n RB dep
 |   |   +-- ? . punct
 |   |   +-- , , punct
 |   |   +-- empty JJ dep
 |   |   |   +-- set NN nsubj
 |   |   |   |   +-- this DT det
 |   |   |   |   +-- of IN prep
 |   |   |   |       +-- equalities NNS pobj
 |   |   |   +-- is VBZ cop
 |   |   +-- -RRB- -RRB- punct
 |   +-- qn , punct
 |   +-- ? . punct
 |   +-- cn NN dep
 |       +-- n RB dep
 |           +-- -LRB- -LRB- punct
 |           +-- ? . punct
 |           +-- 1 CD dep
 |           +-- -RRB- -RRB- punct
 +-- 1 CD prep
 |   +-- By IN prep
 |       +-- lemma NN pobj
 |           +-- the DT det
 |           +-- above JJ amod
 +-- , , punct
 +-- this DT nsubj
 +-- is VBZ cop
 +-- to IN prep
 |   +-- qi NN pobj
 |       +-- Pj DT det
 |       +-- i=m+1 CD num
 +-- ? . punct
 +-- 0 NFP punct
 +-- for IN prep
 |   +-- j $ pobj
 +-- = : punct
 +-- m NN dep
 |   +-- + SYM dep
 |   +-- 1 CD num
 +-- . . punct

153
Input: .
Parse:
. . ROOT

154
Input: .
Parse:
. . ROOT

155
Input: , n .
Parse:
n CC ROOT
 +-- , , punct
 +-- . . punct

156
Input: So , we can simplify further as follows
Parse:
simplify VB ROOT
 +-- So RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- further RB advmod
 +-- follows VBZ advcl
     +-- as IN mark

157
Input: .
Parse:
. . ROOT

158
Input: .
Parse:
. . ROOT

159
Input: + qm+i ? 0 ? ? n Pj=m+i ? 1 j=m+1 cj + -LRB- n ? m ? i -RRB- cm+i ? m for i = 2 , .
Parse:
+ SYM ROOT
 +-- qm+i UH dep
 +-- ? . punct
 +-- 0 NFP punct
 +-- n CC cc
 +-- Pj=m+i NN conj
 +-- cj NN dep
 |   +-- j=m+1 CD num
 |   |   +-- 1 CD number
 |   +-- + SYM dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB advmod
 |   +-- ? . punct
 |   +-- m NN dep
 |   +-- cm+i NN dep
 |       +-- i PRP dep
 |       |   +-- -RRB- -RRB- punct
 |       +-- ? . punct
 |       +-- m VB dep
 |       +-- for IN prep
 |           +-- i PRP pobj
 |               +-- = : dep
 |                   +-- 2 CD num
 +-- , , punct
 +-- . . punct

160
Input: .
Parse:
. . ROOT

161
Input: .
Parse:
. . ROOT

162
Input: , n ? m ? 1 qm+1 + .
Parse:
m NN ROOT
 +-- , , punct
 +-- n RB advmod
 +-- ? . punct
 +-- qm+1 CD num
 |   +-- 1 CD number
 +-- + SYM dep
 +-- . . punct

163
Input: .
Parse:
. . ROOT

164
Input: .
Parse:
. . ROOT

165
Input: + qn ? 0 ? ? n Pj=n ? 1 j=m+1 cj ? m So , the non deficit constraint can be written as a set of linear inequalities involving only the ci .
Parse:
+ SYM ROOT
 +-- qn UH dep
 +-- ? . punct
 +-- 0 NFP punct
 +-- n CC cc
 +-- Pj=n NN conj
 +-- cj NN dep
 |   +-- j=m+1 CD num
 |   |   +-- 1 CD number
 |   +-- ? . punct
 |   +-- written VBN dep
 |       +-- m NNP discourse
 |       +-- So RB advmod
 |       +-- , , punct
 |       +-- constraint NN nsubjpass
 |       |   +-- the DT det
 |       |   +-- deficit NN nn
 |       |       +-- non JJ nn
 |       +-- can MD aux
 |       +-- be VB auxpass
 |       +-- as IN prep
 |           +-- set NN pobj
 |               +-- a DT det
 |               +-- of IN prep
 |                   +-- inequalities NNS pobj
 |                       +-- linear JJ amod
 |                       +-- involving VBG partmod
 |                           +-- ci NN dobj
 |                               +-- only RB advmod
 |                               +-- the DT det
 +-- . . punct

166
Input: The worst case constraint can be also written as a set of linear inequalities , by the following reasoning .
Parse:
written VBN ROOT
 +-- constraint NN nsubjpass
 |   +-- The DT det
 |   +-- worst JJS amod
 |   +-- case NN nn
 +-- can MD aux
 +-- be VB auxpass
 +-- also RB advmod
 +-- as IN prep
 |   +-- set NN pobj
 |       +-- a DT det
 |       +-- of IN prep
 |           +-- inequalities NNS pobj
 |               +-- linear JJ amod
 +-- , , punct
 +-- by IN prep
 |   +-- reasoning NN pobj
 |       +-- the DT det
 |       +-- following VBG amod
 +-- . . punct

167
Input: The worstcase constraint requires that for any bid input z1 +z2 + .
Parse:
requires VBZ ROOT
 +-- constraint NN nsubj
 |   +-- The DT det
 |   +-- worstcase NN nn
 +-- input NN ccomp
 |   +-- that IN mark
 |   +-- for IN prep
 |   |   +-- bid NN pobj
 |   |       +-- any DT det
 |   +-- +z2 CD dobj
 |       +-- z1 CD num
 |       +-- + SYM advmod
 +-- . . punct

168
Input: .
Parse:
. . ROOT

169
Input: .+ zn ? km ? vm+1 , where zi = c0 +c1 ? v1 +c2 ? v2 + .
Parse:
km NN ROOT
 +-- zn SYM dep
 |   +-- .+ NFP punct
 |   +-- ? . punct
 +-- ? . punct
 +-- vm+1 CD amod
 +-- , , punct
 +-- where WRB prep
 |   +-- +c2 CD pobj
 |       +-- +c1 CD dep
 |       |   +-- zi NN nn
 |       |   +-- = SYM dep
 |       |   +-- c0 CD number
 |       |   +-- ? . punct
 |       +-- v1 CD num
 |       +-- ? . punct
 |       +-- v2 CD dep
 +-- + SYM dep
 +-- . . punct

170
Input: .
Parse:
. . ROOT

171
Input: .+ci ? 1 ? vi ? 1 + ci ? vi+1 + .
Parse:
.+ci NNP ROOT
 +-- ? . punct
 +-- vi NN dep
 |   +-- 1 CD dep
 |       +-- ? . punct
 +-- ci NN dep
 |   +-- + SYM dep
 |       +-- 1 CD number
 +-- vi+1 NN dep
 +-- + SYM dep
 +-- . . punct

172
Input: .
Parse:
. . ROOT

173
Input: .
Parse:
. . ROOT

174
Input: + cn ? 1 ? vn for i = 1 , 2 , .
Parse:
cn NN ROOT
 +-- + SYM nn
 +-- ? . punct
 +-- 1 CD num
 +-- vn , dep
 +-- for IN prep
 |   +-- 2 CD pobj
 |       +-- i PRP dep
 |       +-- = : punct
 |       +-- 1 CD num
 |       +-- , , punct
 +-- , , punct
 +-- . . punct

175
Input: .
Parse:
. . ROOT

176
Input: .
Parse:
. . ROOT

177
Input: , n .
Parse:
n CC ROOT
 +-- , , punct
 +-- . . punct

178
Input: Because ci = 0 for i ? m , we can simplify this inequality to Qm+1 ? vm+1 + Qm+2 ? vm+2 + .
Parse:
simplify VB ROOT
 +-- = SYM advcl
 |   +-- Because IN mark
 |   +-- ci NNP nsubj
 |   +-- 0 CD dep
 |   +-- for IN prep
 |       +-- m NN pobj
 |           +-- i PRP dep
 |           +-- ? . punct
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- inequality NN dobj
 |   +-- this DT det
 +-- to IN prep
 |   +-- Qm+1 CD pobj
 +-- ? . punct
 +-- Qm+2 CD dobj
 |   +-- vm+1 NNP nn
 |   +-- + SYM dep
 +-- vm+2 CD dobj
 |   +-- + SYM advmod
 +-- . . punct

179
Input: .
Parse:
. . ROOT

180
Input: .
Parse:
. . ROOT

181
Input: + Qn ? vn ? 0 Qm+1 = -LRB- n ? m ? 1 -RRB- cm+1 ? km Qi = -LRB- i ? 1 -RRB- ci ? 1 + -LRB- n ? i -RRB- ci , for i = m + 2 , .
Parse:
Qn UH ROOT
 +-- + SYM dep
 +-- ? . punct
 +-- vn UH dep
 +-- 0 NFP punct
 +-- Qm+1 CD dep
 |   +-- = SYM prep
 +-- m NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB amod
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- -RRB- -RRB- punct
 +-- cm+1 CD dep
 +-- km NFP dep
 +-- Qi NNP dep
 +-- = NFP dep
 +-- i PRP dep
 |   +-- -LRB- -LRB- punct
 |   +-- ? . punct
 |   +-- 1 CD dep
 |   +-- -RRB- -RRB- punct
 +-- ci NN dep
 +-- 1 CD dep
 +-- -LRB- -LRB- punct
 +-- n RB dep
     +-- ? . prep
         +-- i NNP pobj
             +-- -RRB- -RRB- punct
             +-- ci UH dep
             +-- , , punct
             +-- for IN prep
             |   +-- i PRP pobj
             +-- = : punct
             +-- + SYM dep
             |   +-- m NN nn
             |   +-- 2 CD num
             +-- . . punct

182
Input: .
Parse:
. . ROOT

183
Input: .
Parse:
. . ROOT

184
Input: , n ? 1 Qn = -LRB- n ? 1 -RRB- cn ? 1 By the above lemma , this is equivalent to Pj i=m+1 Qi ? 0 for j = m + 1 , .
Parse:
n CC ROOT
 +-- , , punct
 +-- ? . punct
 +-- Qn FW dep
 |   +-- 1 CD num
 +-- = SYM dep
 +-- cn NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB advmod
 |   +-- ? . punct
 |   +-- 1 CD dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- equivalent JJ dep
 |   |   +-- ? . punct
 |   |   +-- 1 CD dep
 |   |   +-- By IN prep
 |   |   |   +-- lemma NN pobj
 |   |   |       +-- the DT det
 |   |   |       +-- above JJ amod
 |   |   +-- , , punct
 |   |   +-- this DT nsubj
 |   |   +-- is VBZ cop
 |   |   +-- to IN prep
 |   |       +-- Qi NNP pobj
 |   |           +-- Pj LS nn
 |   |           +-- i=m+1 CD nn
 |   +-- 0 NFP punct
 |   +-- for IN prep
 |   |   +-- j $ pobj
 |   +-- = : punct
 |   +-- + SYM dep
 |   |   +-- m NN nn
 |   |   +-- 1 CD num
 |   +-- , , punct
 +-- . . punct

185
Input: .
Parse:
. . ROOT

186
Input: .
Parse:
. . ROOT

187
Input: , n .
Parse:
n CC ROOT
 +-- , , punct
 +-- . . punct

188
Input: So , we can simplify further as follows
Parse:
simplify VB ROOT
 +-- So RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- further RB advmod
 +-- follows VBZ advcl
     +-- as IN mark

189
Input: .
Parse:
. . ROOT

190
Input: .
Parse:
. . ROOT

191
Input: + Qm+i ? 0 ? ? n Pj=m+i ? 1 j=m+1 cj + -LRB- n ? m ? i -RRB- cm+i ? km for i = 2 , .
Parse:
+ SYM ROOT
 +-- Qm+i UH dep
 +-- ? . punct
 +-- 0 NFP punct
 +-- n CC cc
 +-- Pj=m+i NN conj
 +-- cj NN dep
 |   +-- j=m+1 CD num
 |   |   +-- 1 CD number
 |   +-- + SYM dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB advmod
 |   +-- ? . punct
 |   +-- cm+i NN dep
 |   |   +-- m NN dep
 |   |   +-- ? . punct
 |   |   +-- i PRP dep
 |   |       +-- -RRB- -RRB- punct
 |   +-- km NN dep
 |       +-- for IN prep
 |       |   +-- i PRP pobj
 |       +-- = : punct
 |       +-- 2 CD dep
 +-- , , punct
 +-- . . punct

192
Input: .
Parse:
. . ROOT

193
Input: .
Parse:
. . ROOT

194
Input: , n ? m ? 1 Qm+1 + .
Parse:
m NN ROOT
 +-- , , punct
 +-- n RB advmod
 +-- ? . punct
 +-- Qm+1 CD num
 |   +-- 1 CD number
 +-- + SYM dep
 +-- . . punct

195
Input: .
Parse:
. . ROOT

196
Input: .
Parse:
. . ROOT

197
Input: + Qn ? 0 ? ? n Pj=n ? 1 j=m+1 cj ? km So , the worst case constraint can also be written as a set of linear inequalities involving only the ci and k .
Parse:
+ SYM ROOT
 +-- Qn UH dep
 +-- ? . punct
 +-- 0 NFP punct
 +-- n CC cc
 +-- Pj=n NN conj
 +-- cj NN dep
 |   +-- j=m+1 CD num
 |   |   +-- 1 CD number
 |   +-- ? . punct
 |   +-- km NN dep
 |   +-- written VBN dep
 |       +-- So RB advmod
 |       +-- , , punct
 |       +-- constraint NN nsubjpass
 |       |   +-- the DT det
 |       |   +-- case NN nn
 |       |       +-- worst JJS amod
 |       +-- can MD aux
 |       +-- also RB advmod
 |       +-- be VB auxpass
 |       +-- as IN prep
 |           +-- set NN pobj
 |               +-- a DT det
 |               +-- of IN prep
 |                   +-- inequalities NNS pobj
 |                       +-- linear JJ amod
 |                       +-- involving VBG partmod
 |                           +-- ci NN dobj
 |                               +-- only RB advmod
 |                               +-- the DT det
 |                               +-- and CC cc
 |                               +-- k CD conj
 +-- . . punct

198
Input: Combining all the claims , we see that the original optimization problem can be transformed into the following linear program .
Parse:
see VBP ROOT
 +-- Combining VBG partmod
 |   +-- claims NNS dobj
 |       +-- all PDT predet
 |       +-- the DT det
 +-- , , punct
 +-- we PRP nsubj
 +-- transformed VBN ccomp
 |   +-- that IN mark
 |   +-- problem NN nsubjpass
 |   |   +-- the DT det
 |   |   +-- original JJ amod
 |   |   +-- optimization NN nn
 |   +-- can MD aux
 |   +-- be VB auxpass
 |   +-- into IN prep
 |       +-- program NN pobj
 |           +-- the DT det
 |           +-- following VBG amod
 |           +-- linear JJ amod
 +-- . . punct

199
Input: Variables
Parse:
Variables NNS ROOT

200
Input: .
Parse:
. . ROOT

201
Input: .
Parse:
. . ROOT

202
Input: , cn ? 1 , k Maximize k -LRB- the percentage redistributed in the worst case -RRB- Subject to
Parse:
Subject NN ROOT
 +-- , , punct
 +-- cn NNP nsubj
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- , , punct
 |   +-- k CD conj
 |   |   +-- k CD num
 |   |   +-- Maximize NNP nn
 |   +-- redistributed VBN dep
 |       +-- -LRB- -LRB- punct
 |       +-- the DT det
 |       +-- percentage NN nn
 |       +-- in IN prep
 |       |   +-- case NN pobj
 |       |       +-- the DT det
 |       |       +-- worst JJS amod
 |       +-- -RRB- -RRB- punct
 +-- to IN punct

203
Input: .
Parse:
. . ROOT

204
Input: .
Parse:
. . ROOT

205
Input: , n ? 1 km ? -LRB- n ? m ? 1 -RRB- cm+1 ? m km ? n Pj=m+i ? 1 j=m+1 cj + -LRB- n ? m ? i -RRB- cm+i ? m for i = 2 , .
Parse:
km NN ROOT
 +-- n CC dep
 |   +-- , , punct
 |   +-- ? . punct
 +-- 1 CD num
 +-- ? . punct
 +-- m NN dep
 |   +-- -LRB- -LRB- punct
 |   +-- n RB amod
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- -RRB- -RRB- punct
 |   +-- cm+1 CD num
 +-- km NN dep
 |   +-- m NN nn
 +-- cm+i NN dep
 |   +-- n UH dep
 |   |   +-- Pj=m+i SYM dep
 |   |   +-- ? . punct
 |   |   +-- cj NN dep
 |   |   |   +-- j=m+1 CD num
 |   |   |       +-- 1 CD number
 |   |   +-- + SYM dep
 |   +-- n RB dep
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- ? . punct
 |   +-- m NN dep
 |   +-- ? . punct
 |   +-- i PRP dep
 |       +-- -RRB- -RRB- punct
 +-- m VB dep
 +-- for IN prep
 |   +-- i PRP pobj
 |       +-- = : dep
 |           +-- 2 CD num
 +-- , , punct
 +-- . . punct

206
Input: .
Parse:
. . ROOT

207
Input: .
Parse:
. . ROOT

208
Input: , n ? m ? 1 km ? n Pj=n ? 1 j=m+1 cj ? m .
Parse:
m NN ROOT
 +-- , , punct
 +-- n RB amod
 +-- ? . punct
 +-- km NN dep
 |   +-- 1 CD num
 +-- Pj=n NN dep
 |   +-- n UH dep
 |   +-- ? . punct
 |   +-- cj NN dep
 |       +-- j=m+1 CD num
 |           +-- 1 CD number
 +-- m NN dep
 +-- . . punct
