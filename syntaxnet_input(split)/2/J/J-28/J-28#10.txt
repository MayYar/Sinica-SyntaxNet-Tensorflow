Input: ? i ? j pj i xj i is minimized
Parse:
minimized JJ ROOT
 +-- ? . punct
 +-- i PRP nsubj
 +-- ? , punct
 +-- j NFP punct
 +-- pj , punct
 +-- i PRP discourse
 +-- xj , punct
 +-- is VBZ cop
Input: This generalized knapsack formulation is a clear generalization of the classic 0 1 knapsack
Parse:
generalization NN ROOT
 +-- formulation NN nsubj
 |   +-- This DT det
 |   +-- generalized VBD amod
 |   +-- knapsack NN nn
 +-- is VBZ cop
 +-- a DT det
 +-- clear JJ amod
 +-- of IN prep
     +-- knapsack NN pobj
         +-- the DT det
         +-- classic JJ amod
         +-- 1 CD num
             +-- 0 CD number
Input: In the latter , each list consists of a single point -LRB- si , vi -RRB- .8 The connection between the generalized knapsack and our auction problem is transparent
Parse:
consists VBZ ROOT
 +-- In IN prep
 |   +-- latter JJ pobj
 |       +-- the DT det
 +-- , , punct
 +-- list NN nsubj
 |   +-- each DT det
 +-- of IN prep
     +-- point NN pobj
         +-- a DT det
         +-- single JJ amod
         +-- -LRB- -LRB- punct
         +-- vi NN dep
         |   +-- si UH discourse
         |   +-- , , punct
         +-- -RRB- -RRB- punct
         +-- .8 CD num
         +-- transparent JJ rcmod
             +-- connection NN nsubj
             |   +-- The DT det
             |   +-- between IN prep
             |       +-- knapsack NN pobj
             |           +-- the DT det
             |           +-- generalized JJ amod
             |           +-- and CC cc
             |           +-- problem NN conj
             |               +-- our PRP$ poss
             |               +-- auction NN nn
             +-- is VBZ cop
Input: Each list encodes a bid , representing multiple mutually exclusive quantity intervals , and one can choose any quantity in an interval , but at most one interval can be selected
Parse:
encodes VBZ ROOT
 +-- list NN nsubj
 |   +-- Each DT det
 +-- bid NN dobj
 |   +-- a DT det
 |   +-- , , punct
 |   +-- representing VBG partmod
 |       +-- intervals NNS dobj
 |           +-- multiple JJ amod
 |           +-- exclusive JJ amod
 |           |   +-- mutually RB advmod
 |           +-- quantity NN nn
 +-- , , punct
 +-- and CC cc
 +-- choose VB conj
 |   +-- one PRP nsubj
 |   +-- can MD aux
 |   +-- quantity NN dobj
 |   |   +-- any DT det
 |   +-- in IN prep
 |       +-- interval NN pobj
 |           +-- an DT det
 +-- but CC cc
 +-- selected VBN conj
     +-- at IN prep
     |   +-- interval NN pobj
     |       +-- one CD num
     |           +-- most JJS quantmod
     +-- can MD aux
     +-- be VB auxpass
Input: Choosing interval -LRB- uj i , uj+1 i -RRB- has cost pj i per unit
Parse:
cost VBN ROOT
 +-- Choosing VBG csubj
 |   +-- interval NN dobj
 |       +-- i PRP appos
 |           +-- -LRB- -LRB- punct
 |           +-- uj FW nn
 |           +-- , , punct
 |           +-- i PRP appos
 |           |   +-- uj+1 CD num
 |           +-- -RRB- -RRB- punct
 +-- has VBZ aux
 +-- pj , iobj
 +-- i PRP dobj
     +-- per IN prep
         +-- unit NN pobj
Input: The goal is to procure at least M units of the good at minimum possible cost
Parse:
is VBZ ROOT
 +-- goal NN nsubj
 |   +-- The DT det
 +-- procure VB xcomp
     +-- to TO aux
     +-- units NNS dobj
     |   +-- M NNP num
     |   |   +-- least JJS dep
     |   |       +-- at IN advmod
     |   +-- of IN prep
     |       +-- good JJ pobj
     |           +-- the DT det
     +-- at IN prep
         +-- cost NN pobj
             +-- minimum JJ amod
             +-- possible JJ amod
Input: The problem has some flavor of the continuous knapsack problem
Parse:
has VBZ ROOT
 +-- problem NN nsubj
 |   +-- The DT det
 +-- flavor NN dobj
     +-- some DT det
     +-- of IN prep
         +-- problem NN pobj
             +-- the DT det
             +-- continuous JJ amod
             +-- knapsack NN nn
Input: However , there are two major differences that make our problem significantly more difficult
Parse:
are VBP ROOT
 +-- However RB advmod
 +-- , , punct
 +-- there EX expl
 +-- differences NNS nsubj
     +-- two CD num
     +-- major JJ amod
     +-- make VBP rcmod
         +-- that WDT nsubj
         +-- difficult JJ xcomp
             +-- problem NN nsubj
             |   +-- our PRP$ poss
             +-- more RBR advmod
                 +-- significantly RB advmod
Input: 3.2 A 2 Approximation Scheme We begin with a definition
Parse:
Scheme NNP ROOT
 +-- 2 CD num
 |   +-- 3.2 CD number
 |   +-- A DT quantmod
 +-- Approximation NN nn
 +-- begin VBP rcmod
     +-- We PRP nsubj
     +-- with IN prep
         +-- definition NN pobj
             +-- a DT det
Input: Given an instance of the generalized knapsack , we call each tuple tj i = -LRB- uj i , pj i -RRB- an anchor
Parse:
call VBP ROOT
 +-- Given VBN prep
 |   +-- instance NN dep
 |       +-- an DT det
 |       +-- of IN prep
 |           +-- knapsack NN pobj
 |               +-- the DT det
 |               +-- generalized VBN amod
 +-- , , punct
 +-- we PRP nsubj
 +-- tuple NNS dobj
 |   +-- each DT det
 +-- tj , xcomp
     +-- i PRP prep
         +-- = , dep
         |   +-- pj NFP parataxis
         |       +-- -LRB- -LRB- punct
         |       +-- uj UH discourse
         |       +-- i PRP dep
         |       +-- , , punct
         |       +-- i PRP dobj
         |       +-- -RRB- -RRB- punct
         +-- anchor NN dep
             +-- an DT det
Input: Recall that these tuples represent the breakpoints in the piecewise constant curve bids
Parse:
Recall VB ROOT
 +-- represent VBP ccomp
     +-- that IN mark
     +-- tuples NNS nsubj
     |   +-- these DT det
     +-- breakpoints NNS dobj
         +-- the DT det
         +-- in IN prep
             +-- bids NNS pobj
                 +-- the DT det
                 +-- piecewise JJ amod
                 +-- constant JJ amod
                 +-- curve NN nn
Input: We say that the size of an anchor tj i is uj i , 8 In fact , because of the one per list constraint , the generalized problem is closer in spirit to the multiple choice knapsack problem -LRB- 9 -RRB- , where the underling set of items is partitioned into disjoint subsets U1 , U2 ,
Parse:
say VBP ROOT
 +-- We PRP nsubj
 +-- uj NNP ccomp
 |   +-- that IN mark
 |   +-- size NN nsubj
 |   |   +-- the DT det
 |   |   +-- of IN prep
 |   |       +-- tj , pobj
 |   |           +-- an DT det
 |   |           +-- anchor NN amod
 |   +-- i PRP nsubj
 |   +-- is VBZ cop
 |   +-- i PRP dobj
 |   +-- , , punct
 |   +-- 8 CD appos
 |   |   +-- In IN prep
 |   |       +-- fact NN pobj
 |   +-- of IN prep
 |   |   +-- because IN mwe
 |   |   +-- one CD pobj
 |   |       +-- the DT det
 |   |       +-- per IN prep
 |   |           +-- constraint NN pobj
 |   |               +-- list NN nn
 |   +-- closer JJR ccomp
 |       +-- problem NN nsubj
 |       |   +-- the DT det
 |       |   +-- generalized JJ amod
 |       +-- is VBZ cop
 |       +-- in IN prep
 |       |   +-- spirit NN pobj
 |       +-- to IN prep
 |           +-- problem NN pobj
 |               +-- the DT det
 |               +-- multiple JJ amod
 |               +-- choice NN nn
 |               +-- knapsack NN nn
 |               +-- -LRB- -LRB- punct
 |               +-- 9 CD dep
 |               +-- -RRB- -RRB- punct
 |               +-- , , punct
 |               +-- partitioned VBN rcmod
 |                   +-- where WRB advmod
 |                   +-- set NN nsubj
 |                   |   +-- the DT det
 |                   |   +-- underling VBG amod
 |                   |   +-- of IN prep
 |                   |       +-- items NNS pobj
 |                   +-- is VBZ cop
 |                   +-- into IN prep
 |                       +-- subsets NNS pobj
 |                           +-- disjoint NN nn
 |                           +-- U1 CD num
 |                           +-- , , punct
 |                           +-- U2 CD appos
 +-- , , punct
Input: , Uk , and one can choose at most one item from each subset
Parse:
choose VB ROOT
 +-- , , punct
 +-- Uk NNP nsubj
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- one PRP conj
 +-- can MD aux
 +-- at IN prep
 |   +-- item NN pobj
 |       +-- most JJS amod
 |       +-- one CD num
 +-- from IN prep
     +-- subset NN pobj
         +-- each DT det
Input: PTAS do exist for this problem -LRB- 10 -RRB- , and indeed , one can convert our problem into a huge instance of the multiple choice knapsack problem , by creating one group for each list ; put a -LRB- quantity , price -RRB- point tuple -LRB- x , p -RRB- for each possible quantity for a bidder into his group -LRB- subset -RRB-
Parse:
exist VB ROOT
 +-- PTAS NNS nsubj
 +-- do VBP aux
 +-- for IN prep
 |   +-- problem NN pobj
 |       +-- this DT det
 |       +-- -LRB- -LRB- punct
 |       +-- 10 CD dep
 |       +-- -RRB- -RRB- punct
 +-- , , punct
 +-- and CC cc
 +-- convert VB conj
 |   +-- indeed RB advmod
 |   +-- , , punct
 |   +-- one PRP nsubj
 |   +-- can MD aux
 |   +-- problem NN dobj
 |   |   +-- our PRP$ poss
 |   +-- into IN prep
 |   |   +-- instance NN pobj
 |   |       +-- a DT det
 |   |       +-- huge JJ amod
 |   |       +-- of IN prep
 |   |           +-- problem NN pobj
 |   |               +-- the DT det
 |   |               +-- multiple JJ amod
 |   |               +-- choice NN nn
 |   |               +-- knapsack NN nn
 |   +-- by IN prep
 |       +-- creating VBG pcomp
 |           +-- group NN dobj
 |           |   +-- one CD num
 |           +-- for IN prep
 |               +-- list NN pobj
 |                   +-- each DT det
 +-- ; : punct
 +-- put VB conj
     +-- p NN dobj
     |   +-- a DT det
     |   +-- -LRB- -LRB- punct
     |   +-- quantity NN nn
     |   +-- , , punct
     |   +-- price NN nn
     |   +-- -RRB- -RRB- punct
     |   +-- tuple NN dep
     |   |   +-- point NN nn
     |   +-- x NFP punct
     +-- for IN prep
         +-- quantity NN pobj
             +-- each DT det
             +-- possible JJ amod
             +-- for IN prep
                 +-- bidder NN pobj
                     +-- a DT det
                     +-- into IN prep
                     |   +-- group NN pobj
                     |       +-- his PRP$ poss
                     +-- -LRB- -LRB- punct
                     +-- subset NN dep
                     +-- -RRB- -RRB- punct
Input: However , this conversion explodes the problem size , making it infeasible for all but the most trivial instances
Parse:
explodes VBZ ROOT
 +-- However RB advmod
 +-- , , punct
 +-- conversion NN nsubj
 |   +-- this DT det
 +-- size NN dobj
 |   +-- the DT det
 |   +-- problem NN nn
 +-- making VBG partmod
     +-- infeasible JJ xcomp
         +-- it PRP nsubj
         +-- for IN prep
             +-- all DT pobj
                 +-- but CC cc
                 +-- instances NNS conj
                     +-- the DT det
                     +-- trivial JJ amod
                         +-- most RBS advmod
Input: the minimum number of units available at this anchor '' s price pj i
Parse:
price NN ROOT
 +-- number NN poss
 |   +-- the DT det
 |   +-- minimum JJ nn
 |   +-- of IN prep
 |   |   +-- units NNS pobj
 |   +-- available JJ amod
 |   |   +-- at IN prep
 |   |       +-- anchor NN pobj
 |   |           +-- this DT det
 |   +-- '' '' punct
 |   +-- s POS possessive
 +-- pj . dep
 +-- i PRP dep
Input: The cost of the anchor tj i is defined to be the minimum total price associated with this tuple , namely , cost -LRB- tj i -RRB- = pj i uj i if j < mi , and cost -LRB- tmi i -RRB- = pmi ? 1 i umi i
Parse:
defined VBN ROOT
 +-- cost NN nsubjpass
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- anchor NN pobj
 |           +-- the DT det
 |           +-- tj SYM dep
 +-- i PRP nsubjpass
 +-- is VBZ auxpass
 +-- price NN xcomp
 |   +-- to TO aux
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- minimum JJ amod
 |   +-- total JJ amod
 |   +-- associated VBN partmod
 |   |   +-- with IN prep
 |   |       +-- tuple NN pobj
 |   |           +-- this DT det
 |   +-- , , punct
 |   +-- cost NN appos
 |       +-- namely RB advmod
 |       +-- , , punct
 |       +-- -LRB- -LRB- punct
 |       +-- i PRP dep
 |       |   +-- tj FW nn
 |       +-- -RRB- -RRB- punct
 +-- pj UH advmod
     +-- = NFP dep
     +-- uj VBP rcmod
         +-- i PRP nsubj
         +-- i PRP dep
             +-- mi UH dep
                 +-- if IN mark
                 +-- j FW dep
                 +-- < -LRB- punct
                 +-- , , punct
                 +-- and CC cc
                 +-- cost NN conj
                     +-- tmi NNP dep
                     |   +-- -LRB- -LRB- punct
                     |   +-- i UH discourse
                     |   +-- -RRB- -RRB- punct
                     +-- = , punct
                     +-- pmi UH dep
                         +-- ? . punct
                         +-- i PRP dep
                             +-- 1 CD num
                             +-- umi UH dep
                             +-- i PRP dep
Input: In a feasible solution -LRB- x1 , x2 ,
Parse:
In IN ROOT
 +-- solution NN pobj
 |   +-- a DT det
 |   +-- feasible JJ amod
 |   +-- -LRB- -LRB- punct
 |   +-- x2 CD dep
 |       +-- x1 CD num
 |       +-- , , punct
 +-- , , punct
Input: , xn -RRB- of the generalized knapsack , we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i
Parse:
say VBP ROOT
 +-- xn NFP dep
 |   +-- , , punct
 |   +-- -RRB- -RRB- punct
 +-- of IN prep
 |   +-- knapsack NN pobj
 |       +-- the DT det
 |       +-- generalized JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- anchor NN ccomp
     +-- that IN mark
     +-- xi NN nsubj
     |   +-- an DT det
     |   +-- element NN amod
     |   +-- = SYM dep
     |   +-- 0 NFP punct
     +-- is VBZ cop
     +-- an DT det
     +-- i PRP rcmod
         +-- = : advcl
         |   +-- if IN mark
         |   +-- xi NNP nsubj
         |   +-- uj FW dobj
         +-- i PRP nsubj
         +-- , , punct
         +-- for IN prep
             +-- uj NN pobj
                 +-- some DT det
                 +-- anchor NN nn
Input: Otherwise , we say that xi is midrange
Parse:
say VBP ROOT
 +-- Otherwise RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- midrange NN ccomp
     +-- that IN mark
     +-- xi NN nsubj
     +-- is VBZ cop
Input: We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange
Parse:
observe VBP ROOT
 +-- We PRP nsubj
 +-- constructed VBN ccomp
     +-- that IN mark
     +-- solution NN nsubjpass
     |   +-- an DT det
     |   +-- optimal JJ amod
     |   +-- knapsack NN nn
     +-- can MD aux
     +-- always RB advmod
     +-- be VB auxpass
     +-- midrange JJ advcl
         +-- so IN mark
         +-- that IN mark
         +-- at IN prep
         |   +-- element NN pobj
         |       +-- one CD num
         |       |   +-- most RBS quantmod
         |       +-- solution NN nn
         +-- is VBZ cop
Input: If there are two midrange elements x and x , for bids from two different agents , with x ? x , then we can increment x and decrement x , until one of them becomes an anchor
Parse:
increment VB ROOT
 +-- are VBP advcl
 |   +-- If IN mark
 |   +-- there EX expl
 |   +-- elements NNS nsubj
 |   |   +-- two CD num
 |   |   +-- midrange JJ amod
 |   |   +-- x , punct
 |   |   +-- and CC cc
 |   |   +-- x SYM conj
 |   |   +-- , , punct
 |   |   +-- for IN prep
 |   |   |   +-- bids NNS pobj
 |   |   |       +-- from IN prep
 |   |   |           +-- agents NNS pobj
 |   |   |               +-- two CD num
 |   |   |               +-- different JJ amod
 |   |   +-- with IN prep
 |   |       +-- x LS pobj
 |   +-- ? , punct
 |   +-- x SYM dep
 +-- , , punct
 +-- then RB advmod
 +-- we PRP nsubj
 +-- can MD aux
 +-- x , punct
 +-- and CC cc
 +-- decrement NN conj
 +-- anchor NN advcl
     +-- until IN mark
     +-- one CD nsubj
     |   +-- of IN prep
     |       +-- them PRP pobj
     +-- becomes VBZ cop
     +-- an DT det
Input: See Figure 2 for an example
Parse:
See VB ROOT
 +-- Figure NN dobj
 |   +-- 2 CD num
 +-- for IN prep
     +-- example NN pobj
         +-- an DT det
Input: LEMMA 1
Parse:
LEMMA NNP ROOT
 +-- 1 CD num
Input: -LRB- Anchor Property -RRB- There exists an optimal solution of the generalized knapsack problem with at most one midrange element
Parse:
exists VBZ ROOT
 +-- -LRB- -LRB- punct
 +-- Property NNP nsubj
 |   +-- Anchor NNP nn
 +-- -RRB- -RRB- punct
 +-- There EX expl
 +-- solution NN dobj
     +-- an DT det
     +-- optimal JJ amod
     +-- of IN prep
         +-- problem NN pobj
             +-- the DT det
             +-- generalized JJ amod
             +-- knapsack NN nn
             +-- with IN prep
                 +-- at IN pcomp
                     +-- element NN pobj
                         +-- one CD num
                         |   +-- most RBS quantmod
                         +-- midrange NN amod
Input: All other elements are anchors
Parse:
anchors NNS ROOT
 +-- elements NNS nsubj
 |   +-- All DT det
 |   +-- other JJ amod
 +-- are VBP cop
Input: 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity -LRB- i -RRB- Optimal solution with 2 midrange bids -LRB- ii -RRB- Optimal soltution with Figure 2
Parse:
solution NN ROOT
 +-- Quantity NN dep
 |   +-- 1 CD num
 |   |   +-- 2 CD number
 |   |       +-- bid NN dep
 |   |       |   +-- 1 CD num
 |   |       |   +-- midrange NN amod
 |   |       +-- 5 CD number
 |   |       +-- 2 CD number
 |   |       |   +-- 20 CD number
 |   |       |   +-- 15 CD number
 |   |       |   +-- 10 CD number
 |   |       |   +-- 25 CD number
 |   |       |   +-- 5 CD number
 |   |       |   +-- 30201510 CD dep
 |   |       |   +-- 35 CD number
 |   |       |   +-- 3 CD number
 |   |       +-- 1 CD number
 |   |       +-- Quantity NN dep
 |   |       |   +-- Price NN nn
 |   |       +-- 20 CD number
 |   |       +-- 15 CD number
 |   |       +-- 10 CD number
 |   |       +-- 25 CD number
 |   |       +-- 30201510 CD dep
 |   |       +-- 35 CD number
 |   |       +-- 3 CD number
 |   +-- Price NN nn
 +-- i PRP dep
 |   +-- -LRB- -LRB- punct
 |   +-- -RRB- -RRB- punct
 +-- Optimal JJ amod
 +-- with IN prep
     +-- bids NNS pobj
         +-- 2 CD num
         +-- midrange NN amod
         +-- soltution NN dep
             +-- ii LS dep
             |   +-- -LRB- -LRB- punct
             |   +-- -RRB- -RRB- punct
             +-- Optimal NNP nn
             +-- with IN prep
                 +-- Figure NN pobj
                     +-- 2 CD num
Input: We use the anchor property to first obtain a polynomial time 2 approximation scheme
Parse:
use VBP ROOT
 +-- We PRP nsubj
 +-- property NN dobj
 |   +-- the DT det
 |   +-- anchor NN nn
 +-- obtain VB xcomp
     +-- to TO aux
     +-- first RB advmod
     +-- scheme NN dobj
         +-- a DT det
         +-- time NN nn
         |   +-- polynomial JJ amod
         +-- approximation NN nn
             +-- 2 CD num
Input: We do this by solving several instances of a restricted generalized knapsack problem , which we call iKnapsack , where one element is forced to be midrange for a particular interval
Parse:
do VBP ROOT
 +-- We PRP nsubj
 +-- this DT dobj
 +-- by IN prep
     +-- solving VBG pcomp
         +-- instances NNS dobj
             +-- several JJ amod
             +-- of IN prep
             |   +-- problem NN pobj
             |       +-- a DT det
             |       +-- restricted JJ amod
             |       +-- generalized VBN amod
             |       +-- knapsack NN nn
             +-- , , punct
             +-- call VBP rcmod
             |   +-- which WDT dobj
             |   +-- we PRP nsubj
             |   +-- iKnapsack NNP dep
             +-- forced VBN rcmod
                 +-- where WRB advmod
                 +-- element NN nsubjpass
                 |   +-- one CD num
                 +-- is VBZ auxpass
                 +-- midrange JJ xcomp
                     +-- to TO aux
                     +-- be VB cop
                     +-- for IN prep
                         +-- interval NN pobj
                             +-- a DT det
                             +-- particular JJ amod
Input: Specifically , suppose element x for agent l is forced to lie in its jth range , -LRB- uj , uj+1 -RRB- , while all other elements , x1 ,
Parse:
suppose VB ROOT
 +-- Specifically RB advmod
 +-- , , punct
 +-- forced VBN ccomp
     +-- element NN nsubjpass
     |   +-- x SYM punct
     |   +-- for IN prep
     |       +-- l NNP pobj
     |           +-- agent NN nn
     +-- is VBZ auxpass
     +-- lie VB xcomp
     |   +-- to TO aux
     |   +-- in IN prep
     |       +-- range NN pobj
     |           +-- its PRP$ poss
     |           +-- jth NNP nn
     |           +-- , , punct
     |           +-- -LRB- -LRB- punct
     |           +-- uj UH dep
     |           |   +-- , , punct
     |           |   +-- uj+1 CD dep
     |           +-- -RRB- -RRB- punct
     +-- , , punct
     +-- while IN prep
         +-- elements NNS pobj
             +-- all DT det
             +-- other JJ amod
             +-- , , punct
             +-- x1 CD appos
Input: , xl ? 1 , xl+1 , xn , are required to be anchors , or zero
Parse:
required VBN ROOT
 +-- , , punct
 +-- xl UH nsubjpass
 |   +-- ? . punct
 |   +-- 1 CD num
 |   +-- , , punct
 |   +-- xl+1 CD appos
 |   +-- xn UH appos
 +-- are VBP auxpass
 +-- anchors NNS xcomp
     +-- to TO aux
     +-- be VB cop
     +-- , , punct
     +-- or CC cc
     +-- zero CD conj
Input: This corresponds to the restricted problem iKnapsack -LRB- , j -RRB- , in which the goal is to obtain at least M ? uj units with minimum cost
Parse:
corresponds VBZ ROOT
 +-- This DT nsubj
 +-- to IN prep
     +-- problem NN pobj
         +-- the DT det
         +-- restricted VBN amod
         +-- iKnapsack NNP dep
         |   +-- -LRB- -LRB- punct
         |   +-- , , punct
         |   +-- j NNP appos
         +-- -RRB- -RRB- punct
         +-- , , punct
         +-- is VBZ rcmod
             +-- in IN prep
             |   +-- which WDT pobj
             +-- goal NN nsubj
             |   +-- the DT det
             +-- obtain VB xcomp
                 +-- to TO aux
                 +-- units NNS dobj
                 |   +-- M NNP nn
                 |   |   +-- least RBS dep
                 |   |   |   +-- at RB advmod
                 |   |   +-- ? . punct
                 |   +-- uj NNP nn
                 +-- with IN prep
                     +-- cost NN pobj
                         +-- minimum JJ amod
Input: Element x is assumed to have already contributed uj units
Parse:
assumed VBN ROOT
 +-- Element NNP nsubjpass
 |   +-- x , punct
 +-- is VBZ auxpass
 +-- contributed VBN xcomp
     +-- to TO aux
     +-- have VB aux
     +-- already RB advmod
     +-- units NNS dobj
         +-- uj NN nn
Input: The value of a solution to iKnapsack -LRB- , j -RRB- represents the minimal additional cost to purchase the rest of the units
Parse:
represents VBZ ROOT
 +-- value NN nsubj
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- solution NN pobj
 |           +-- a DT det
 |           +-- to IN prep
 |           |   +-- iKnapsack VB pobj
 |           +-- -LRB- -LRB- punct
 |           +-- j NNP dep
 |           |   +-- , , punct
 |           +-- -RRB- -RRB- punct
 +-- cost NN dobj
     +-- the DT det
     +-- minimal JJ amod
     +-- additional JJ amod
     +-- purchase VB infmod
         +-- to TO aux
         +-- rest NN dobj
             +-- the DT det
             +-- of IN prep
                 +-- units NNS pobj
                     +-- the DT det
Input: We create n ? 1 groups of potential anchors , where ith group contains all the anchors of the list i in the generalized knapsack
Parse:
create VBP ROOT
 +-- We PRP nsubj
 +-- n CC advmod
 +-- ? . punct
 +-- groups NNS dobj
     +-- 1 CD num
     +-- of IN prep
         +-- anchors NNS pobj
             +-- potential JJ amod
             +-- , , punct
             +-- contains VBZ rcmod
                 +-- where WRB advmod
                 +-- group NN nsubj
                 |   +-- ith DT det
                 +-- anchors NNS dobj
                 |   +-- all PDT predet
                 |   +-- the DT det
                 |   +-- of IN prep
                 |       +-- list NN pobj
                 |           +-- the DT det
                 +-- i PRP prep
                     +-- in IN prep
                         +-- knapsack NN pobj
                             +-- the DT det
                             +-- generalized JJ amod
Input: The group for agent l contains a single element that represents the interval -LRB- 0 , uj+1 ? uj -RRB- , and the associated unit price pj
Parse:
contains VBZ ROOT
 +-- group NN nsubj
 |   +-- The DT det
 |   +-- for IN prep
 |       +-- l NNP pobj
 |           +-- agent NN nn
 +-- element NN dobj
 |   +-- a DT det
 |   +-- single JJ amod
 |   +-- represents VBZ rcmod
 |       +-- that WDT nsubj
 |       +-- interval NN dobj
 |           +-- the DT det
 |           +-- -LRB- -LRB- punct
 |           +-- 0 CD dep
 |           |   +-- , , punct
 |           |   +-- uj+1 CD num
 |           |   +-- ? . punct
 |           |   +-- uj NNP dep
 |           +-- -RRB- -RRB- punct
 |           +-- , , punct
 |           +-- and CC cc
 |           +-- price NN conj
 |               +-- the DT det
 |               +-- associated VBN amod
 |               +-- unit NN nn
 +-- pj . punct
Input: This interval represents the excess number of units that can be taken from agent l in iKnapsack -LRB- , j -RRB- , in addition to uj , which has already been committed
Parse:
represents VBZ ROOT
 +-- interval NN nsubj
 |   +-- This DT det
 +-- number NN dobj
 |   +-- the DT det
 |   +-- excess JJ amod
 |   +-- of IN prep
 |   |   +-- units NNS pobj
 |   +-- taken VBN rcmod
 |   |   +-- that WDT nsubjpass
 |   |   +-- can MD aux
 |   |   +-- be VB auxpass
 |   |   +-- from IN prep
 |   |       +-- l NNP pobj
 |   |           +-- agent NN nn
 |   |           +-- in IN prep
 |   |               +-- iKnapsack NNP pobj
 |   |                   +-- -LRB- -LRB- punct
 |   |                   +-- , , punct
 |   |                   +-- j NNP appos
 |   +-- -RRB- -RRB- punct
 +-- , , punct
 +-- in IN prep
     +-- addition NN pobj
         +-- to IN prep
             +-- uj NN pobj
                 +-- , , punct
                 +-- committed VBN rcmod
                     +-- which WDT nsubjpass
                     +-- has VBZ aux
                     +-- already RB advmod
                     +-- been VBN auxpass
Input: In any other group , we can choose at most one anchor
Parse:
choose VB ROOT
 +-- In IN prep
 |   +-- group NN pobj
 |       +-- any DT det
 |       +-- other JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- can MD aux
 +-- at IN prep
     +-- anchor NN pobj
         +-- most RBS advmod
         +-- one CD num
Input: The following pseudo code describes our algorithm for this restriction of the generalized knapsack problem
Parse:
describes VBZ ROOT
 +-- code NN nsubj
 |   +-- The DT det
 |   +-- following VBG amod
 |   +-- pseudo NN nn
 +-- algorithm NN dobj
     +-- our PRP$ poss
     +-- for IN prep
         +-- restriction NN pobj
             +-- this DT det
             +-- of IN prep
                 +-- problem NN pobj
                     +-- the DT det
                     +-- generalized VBN amod
                     +-- knapsack NN nn
Input: U is the union of all the tuples in n groups , including a tuple t for agent l
Parse:
union NN ROOT
 +-- U NNP nsubj
 +-- is VBZ cop
 +-- the DT det
 +-- of IN prep
 |   +-- tuples NNS pobj
 |       +-- all PDT predet
 |       +-- the DT det
 |       +-- in IN prep
 |       |   +-- groups NNS pobj
 |       |       +-- n CC nn
 |       +-- , , punct
 |       +-- including VBG prep
 |           +-- t NN pobj
 |               +-- a DT det
 |               +-- tuple NN nn
 |               +-- for IN prep
 |                   +-- agent NN pobj
 +-- l . punct
Input: The size of this special tuple is defined as uj+1 ? uj , and the cost is defined as pj l -LRB- uj+1 ? uj be acquired
Parse:
defined VBN ROOT
 +-- size NN nsubjpass
 |   +-- The DT det
 |   +-- of IN prep
 |       +-- tuple NN pobj
 |           +-- this DT det
 |           +-- special JJ amod
 +-- is VBZ auxpass
 +-- as IN prep
 |   +-- uj+1 CD pobj
 |       +-- ? . punct
 |       +-- uj UH dep
 +-- , , punct
 +-- and CC cc
 +-- defined VBN conj
     +-- cost NN nsubjpass
     |   +-- the DT det
     +-- is VBZ auxpass
     +-- as IN prep
         +-- l NNP pobj
             +-- pj FW nn
             +-- uj+1 CD dep
                 +-- -LRB- -LRB- punct
                 +-- ? . punct
                 +-- acquired VBN partmod
                     +-- uj UH advmod
                     +-- be VB auxpass
Input: S is the set of tuples accepted in the current tentative 170 solution
Parse:
set NN ROOT
 +-- S NNP nsubj
 +-- is VBZ cop
 +-- the DT det
 +-- of IN prep
     +-- tuples NNS pobj
         +-- accepted VBN partmod
             +-- in IN prep
                 +-- solution NN pobj
                     +-- the DT det
                     +-- current JJ amod
                     +-- tentative JJ amod
                     +-- 170 CD num
Input: Best is the best solution found so far
Parse:
solution NN ROOT
 +-- Best JJS nsubj
 +-- is VBZ cop
 +-- the DT det
 +-- best JJS amod
 +-- found VBN partmod
     +-- far RB advmod
         +-- so RB advmod
Input: Variable Skip is only used in the proof of correctness
Parse:
used VBN ROOT
 +-- Skip NNP nsubjpass
 |   +-- Variable NNP nn
 +-- is VBZ auxpass
 +-- only RB advmod
 +-- in IN prep
     +-- proof NN pobj
         +-- the DT det
         +-- of IN prep
             +-- correctness NN pobj
Input: Algorithm Greedy -LRB- , j -RRB- case of ties , sort in ascending order of unit quantities
Parse:
case NN ROOT
 +-- Greedy NNP nn
 |   +-- Algorithm NNP nn
 |   +-- -LRB- -LRB- punct
 |   +-- , , punct
 |   +-- j NNP appos
 |   +-- -RRB- -RRB- punct
 +-- of IN prep
 |   +-- ties NNS pobj
 +-- , , punct
 +-- in RB prep
     +-- sort RB advmod
     +-- order NN pobj
         +-- ascending VBG nn
         +-- of IN prep
             +-- quantities NNS pobj
                 +-- unit NN nn
Input: Initialize R = M ? uj , S = Best = Skip = ?
Parse:
R NNP ROOT
 +-- Initialize VB nn
 +-- = SYM dep
 +-- M NNP dep
 +-- ? . punct
 +-- uj UH dep
 +-- , , punct
 +-- Best JJS dep
     +-- S NNP dep
     +-- = SYM dep
     +-- = SYM prep
     |   +-- Skip NN dep
     +-- = '' punct
Input: tuple is tk i , i.e
Parse:
tk UH ROOT
 +-- tuple NNP nsubj
 +-- is VBZ cop
 +-- i PRP dep
 +-- , , punct
 +-- i.e NNP dep
Input: the kth anchor from agent i
Parse:
anchor NN ROOT
 +-- the DT det
 +-- kth NN nn
 +-- from IN prep
     +-- i PRP pobj
         +-- agent NN nn
Input: If mark -LRB- i -RRB- = 1 , ignore this tuple ; otherwise do the following steps
Parse:
ignore VB ROOT
 +-- = VBP advcl
 |   +-- If IN mark
 |   +-- mark NN nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- i PRP dep
 |   |   +-- -RRB- -RRB- punct
 |   +-- 1 CD dobj
 +-- , , punct
 +-- tuple NN dobj
 |   +-- this DT det
 +-- ; : punct
 +-- do VBP parataxis
     +-- otherwise RB advmod
     +-- steps NNS dobj
         +-- the DT det
         +-- following VBG amod
Input: The approximation algorithm is very similar to the approximation algorithm for knapsack
Parse:
similar JJ ROOT
 +-- approximation NN nsubj
 |   +-- The DT det
 |   +-- algorithm RB advmod
 +-- is VBZ cop
 +-- very RB advmod
 +-- to IN prep
     +-- algorithm NN pobj
         +-- the DT det
         +-- approximation NN nn
         +-- for IN prep
             +-- knapsack NN pobj
Input: Since we wish to minimize the total cost , we consider the tuples in order of increasing per unit cost
Parse:
consider VBP ROOT
 +-- wish VBP advcl
 |   +-- Since IN mark
 |   +-- we PRP nsubj
 |   +-- minimize VB xcomp
 |       +-- to TO aux
 |       +-- cost NN dobj
 |           +-- the DT det
 |           +-- total JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- tuples NNS dobj
 |   +-- the DT det
 +-- in IN prep
     +-- order NN pobj
         +-- of IN prep
             +-- increasing VBG pcomp
                 +-- per IN prep
                     +-- cost NN pobj
                         +-- unit NN nn
Input: If the size of tuple tk i is smaller than R , then we add it to S , update R , and delete from U all the tuples that belong to the same group as tk i
Parse:
add VBP ROOT
 +-- smaller JJR advcl
 |   +-- If IN mark
 |   +-- size NN nsubj
 |   |   +-- the DT det
 |   |   +-- of IN prep
 |   |       +-- tk NN pobj
 |   |           +-- tuple NN nn
 |   +-- i PRP nsubj
 |   +-- is VBZ cop
 |   +-- than IN prep
 |       +-- R NNP pobj
 +-- , , punct
 +-- then RB advmod
 +-- we PRP nsubj
 +-- it PRP dobj
 +-- to IN prep
 |   +-- S NNP pobj
 +-- update VB conj
 |   +-- R NNP dobj
 +-- and CC cc
 +-- delete NN conj
 |   +-- from IN prep
 |   |   +-- U NNP pobj
 |   +-- tuples NNS dobj
 |       +-- all PDT predet
 |       +-- the DT det
 |       +-- belong VBP rcmod
 |           +-- that WDT nsubj
 |           +-- to IN prep
 |               +-- group NN pobj
 |                   +-- the DT det
 |                   +-- same JJ amod
 |                   +-- as IN prep
 |                       +-- tk . pobj
 +-- i PRP punct
Input: If size -LRB- tk i -RRB- is greater than R , then S along with tk i forms a feasible solution
Parse:
S VBZ ROOT
 +-- greater JJR advcl
 |   +-- If IN mark
 |   +-- size NN nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- i NNP dep
 |   |   |   +-- tk NNP nn
 |   |   +-- -RRB- -RRB- punct
 |   +-- is VBZ cop
 |   +-- than IN prep
 |       +-- R NNP pobj
 +-- , , punct
 +-- then RB advmod
 +-- along IN prep
 |   +-- with IN pcomp
 |       +-- tk NNP pobj
 +-- forms VBZ parataxis
     +-- i PRP nsubj
     +-- solution NN dobj
         +-- a DT det
         +-- feasible JJ amod
Input: However , this solution can be far from optimal if the size of tk i is much larger than R
Parse:
be VB ROOT
 +-- However RB advmod
 +-- , , punct
 +-- solution NN nsubj
 |   +-- this DT det
 +-- can MD aux
 +-- far RB advmod
 |   +-- from IN prep
 |       +-- optimal JJ pobj
 +-- larger JJR advcl
     +-- if IN mark
     +-- size NN nsubj
     |   +-- the DT det
     |   +-- of IN prep
     |       +-- tk NN pobj
     +-- i PRP nsubj
     +-- is VBZ cop
     +-- much RB advmod
     +-- than IN prep
         +-- R NNP pobj
Input: If total cost of S and tk i is smaller than the current best solution , we update Best
Parse:
update VBP ROOT
 +-- smaller JJR advcl
 |   +-- If IN mark
 |   +-- cost NN nsubj
 |   |   +-- total JJ amod
 |   |   +-- of IN prep
 |   |       +-- S NNP pobj
 |   |           +-- and CC cc
 |   |           +-- tk NNP conj
 |   +-- i PRP nsubj
 |   +-- is VBZ cop
 |   +-- than IN prep
 |       +-- solution NN pobj
 |           +-- the DT det
 |           +-- current JJ amod
 |           +-- best JJS amod
 +-- , , punct
 +-- we PRP nsubj
 +-- Best JJS advmod
Input: One exception to this rule is the tuple t
Parse:
tuple NN ROOT
 +-- exception NN nsubj
 |   +-- One CD num
 |   +-- to IN prep
 |       +-- rule NN pobj
 |           +-- this DT det
 +-- is VBZ cop
 +-- the DT det
 +-- t . punct
Input: Since this tuple can be taken fractionally , we update Best if the sum of S '' s cost and fractional cost of t is an improvement
Parse:
update VBP ROOT
 +-- taken VBN advcl
 |   +-- Since IN mark
 |   +-- tuple NN nsubjpass
 |   |   +-- this DT det
 |   +-- can MD aux
 |   +-- be VB auxpass
 |   +-- fractionally RB advmod
 +-- , , punct
 +-- we PRP nsubj
 +-- Best JJS advmod
 +-- improvement NN advcl
     +-- if IN mark
     +-- sum NN nsubj
     |   +-- the DT det
     |   +-- of IN prep
     |       +-- cost NN pobj
     |           +-- S NNP poss
     |           |   +-- '' '' punct
     |           |   +-- s POS possessive
     |           +-- and CC cc
     |           +-- cost NN conj
     |               +-- fractional JJ amod
     |               +-- of IN prep
     |                   +-- t NN pobj
     +-- is VBZ cop
     +-- an DT det
Input: The algorithm terminates in either of the first two cases , or when all tuples are scanned
Parse:
terminates NNS ROOT
 +-- The DT det
 +-- algorithm NN nn
 +-- in IN prep
     +-- either DT pobj
     |   +-- of IN prep
     |       +-- cases NNS pobj
     |           +-- the DT det
     |           +-- first JJ amod
     |           +-- two CD num
     +-- , , punct
     +-- or CC cc
     +-- scanned VBN conj
         +-- when WRB advmod
         +-- tuples NNS nsubjpass
         |   +-- all DT det
         +-- are VBP auxpass
Input: In particular , it terminates whenever we find a tk i such that size -LRB- tk i -RRB- is greater than R but cost -LRB- tk i -RRB- is less than cost -LRB- S -RRB- , or when we reach the tuple representing agent l and it gives a feasible solution
Parse:
terminates VBZ ROOT
 +-- In IN prep
 |   +-- particular JJ pobj
 +-- , , punct
 +-- it PRP nsubj
 +-- find VBP advcl
 |   +-- whenever WRB advmod
 |   +-- we PRP nsubj
 |   +-- tk NN dobj
 |       +-- a DT det
 |       +-- greater JJR rcmod
 |           +-- i PRP nsubj
 |           |   +-- size NN dobj
 |           |       +-- such PDT predet
 |           |       +-- that DT det
 |           |       +-- i NNP appos
 |           |           +-- -LRB- -LRB- punct
 |           |           +-- tk NNP nn
 |           |           +-- -RRB- -RRB- punct
 |           +-- is VBZ cop
 |           +-- than IN prep
 |               +-- R NNP pobj
 |                   +-- but CC cc
 |                   +-- less JJR conj
 |                       +-- cost NN nsubj
 |                       +-- i UH parataxis
 |                       |   +-- -LRB- -LRB- punct
 |                       |   +-- tk NNP nn
 |                       |   +-- -RRB- -RRB- punct
 |                       +-- is VBZ cop
 |                       +-- than IN prep
 |                           +-- cost NN pobj
 |                               +-- S NNP dep
 |                               |   +-- -LRB- -LRB- punct
 |                               |   +-- -RRB- -RRB- punct
 |                               +-- , , punct
 |                               +-- or CC cc
 |                               +-- reach VBP conj
 |                                   +-- when WRB advmod
 |                                   +-- we PRP nsubj
 |                                   +-- tuple NN dobj
 |                                       +-- the DT det
 |                                       +-- representing VBG partmod
 |                                           +-- l NNP dobj
 |                                               +-- agent NN nn
 +-- and CC cc
 +-- gives VBZ conj
     +-- it PRP nsubj
     +-- solution NN dobj
         +-- a DT det
         +-- feasible JJ amod
Input: LEMMA 2
Parse:
LEMMA NNP ROOT
 +-- 2 CD num
Input: Suppose A ? is an optimal solution of the generalized knapsack , and suppose that element -LRB- l , j -RRB- is midrange in the optimal solution
Parse:
Suppose VB ROOT
 +-- A DT dobj
 +-- ? , punct
 +-- solution NN conj
 |   +-- is VBZ cop
 |   +-- an DT det
 |   +-- optimal JJ amod
 |   +-- of IN prep
 |       +-- knapsack NN pobj
 |           +-- the DT det
 |           +-- generalized JJ amod
 +-- , , punct
 +-- and CC cc
 +-- suppose VB conj
     +-- midrange JJ ccomp
         +-- element NN nsubj
         |   +-- that IN det
         |   +-- -LRB- -LRB- punct
         |   +-- l NNP dep
         |   |   +-- , , punct
         |   |   +-- j NFP appos
         |   +-- -RRB- -RRB- punct
         +-- is VBZ cop
         +-- in IN prep
             +-- solution NN pobj
                 +-- the DT det
                 +-- optimal JJ amod
Input: Then , the cost V -LRB- l , j -RRB- , returned by Greedy -LRB- , j -RRB- , satisfies
Parse:
satisfies NNS ROOT
 +-- Then RB advmod
 +-- , , punct
 +-- V NNP nsubj
     +-- the DT det
     +-- cost NN nn
     +-- -LRB- -LRB- punct
     +-- l NNP dep
     |   +-- , , punct
     |   +-- j NNP appos
     +-- -RRB- -RRB- punct
     +-- , , punct
     +-- returned VBN partmod
         +-- by IN prep
             +-- Greedy NNP pobj
                 +-- -LRB- -LRB- punct
                 +-- , , punct
                 +-- j NFP appos
Input: Let V -LRB- , j -RRB- be the value returned by Greedy -LRB- , j -RRB- and let V ? -LRB- , j -RRB- be an optimal solution for iKnapsack -LRB- , j -RRB-
Parse:
Let VB ROOT
 +-- value NN ccomp
 |   +-- V DT nsubj
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- , , punct
 |   |   +-- j NFP appos
 |   |   +-- -RRB- -RRB- punct
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- returned VBN partmod
 |   |   +-- by IN prep
 |   |       +-- Greedy NNP pobj
 |   +-- -LRB- -LRB- punct
 |   +-- , , punct
 |   +-- j NFP conj
 |   +-- -RRB- -RRB- punct
 +-- and CC cc
 +-- let VB conj
 |   +-- V NN dobj
 +-- ? . punct
 +-- solution NN parataxis
     +-- -LRB- -LRB- punct
     +-- , , punct
     +-- j NFP punct
     +-- -RRB- -RRB- punct
     +-- be VB cop
     +-- an DT det
     +-- optimal JJ amod
     +-- for IN prep
         +-- iKnapsack NN pobj
             +-- -LRB- -LRB- punct
             +-- , , punct
             +-- j NFP appos
Input: Consider the set Skip at the termination of Greedy -LRB- , j -RRB-
Parse:
Consider VB ROOT
 +-- Skip NN dobj
 |   +-- the DT det
 |   +-- set VBN amod
 +-- at IN prep
 |   +-- termination NN pobj
 |       +-- the DT det
 |       +-- of IN prep
 |           +-- Greedy NNP pobj
 |               +-- -LRB- -LRB- punct
 |               +-- , , punct
 |               +-- j NFP appos
 +-- -RRB- -RRB- punct
Input: There are two cases to consider
Parse:
are VBP ROOT
 +-- There EX expl
 +-- cases NNS nsubj
     +-- two CD num
     +-- consider VB infmod
         +-- to TO aux
Input: In the first case , let St be the tentative solution S at the time t was added to Skip
Parse:
let VB ROOT
 +-- In IN prep
 |   +-- case NN pobj
 |       +-- the DT det
 |       +-- first JJ amod
 +-- , , punct
 +-- solution NN ccomp
 |   +-- St NNP nsubj
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- tentative JJ amod
 |   +-- S NNP advmod
 |   +-- at IN prep
 |       +-- time NN pobj
 |           +-- the DT det
 |           +-- added VBN rcmod
 |               +-- t NN nsubjpass
 |               +-- was VBD auxpass
 |               +-- to IN prep
 +-- Skip VB punct
Input: Because t ? Skip then size -LRB- t -RRB- > R , and St together with t forms a feasible solution , and we have
Parse:
have VBP ROOT
 +-- Because IN mark
 +-- t NN dep
 |   +-- ? . punct
 +-- Skip NN nsubj
     +-- then RB prep
     |   +-- R NN pobj
     |       +-- size NN dep
     |       +-- -LRB- -LRB- punct
     |       +-- t NN nn
     |       +-- -RRB- -RRB- punct
     |       +-- > -RRB- punct
     |       +-- , , punct
     |       +-- and CC cc
     |       +-- St NNP conj
     |           +-- together RB advmod
     |           +-- with IN prep
     |           |   +-- forms NNS pobj
     |           |       +-- t DT det
     |           +-- solution NN dep
     |               +-- a DT det
     |               +-- feasible JJ amod
     +-- , , punct
     +-- and CC cc
     +-- we PRP conj
Input: Again , because t ? Skip then cost -LRB- t -RRB- > cost -LRB- St -RRB- , and we have V -LRB- , j -RRB- < 2cost -LRB- t -RRB-
Parse:
Again RB ROOT
 +-- , , punct
     +-- because IN prep
         +-- t NN dep
             +-- ? . prep
                 +-- Skip NN pcomp
                     +-- then RB prep
                         +-- cost NN dep
                             +-- -LRB- -LRB- punct
                             +-- t NN dep
                             +-- -RRB- -RRB- punct
                             +-- > -RRB- punct
                             +-- cost NN conj
                             |   +-- St NNP appos
                             |       +-- -LRB- -LRB- punct
                             |       +-- -RRB- -RRB- punct
                             +-- , , punct
                             +-- and CC cc
                             +-- have VBP conj
                                 +-- we PRP nsubj
                                 +-- V NNP dobj
                                     +-- -LRB- -LRB- punct
                                     +-- , , punct
                                     +-- j SYM conj
                                     +-- -RRB- -RRB- punct
                                     +-- 2cost CD appos
                                         +-- < -LRB- punct
                                         +-- t NN appos
                                             +-- -LRB- -LRB- punct
                                             +-- -RRB- -RRB- punct
Input: On the other hand , since t is included in V ? -LRB- , j -RRB- , we have V ? -LRB- , j -RRB- ? cost -LRB- t -RRB-
Parse:
have VBP ROOT
 +-- On IN prep
 |   +-- hand NN pobj
 |       +-- the DT det
 |       +-- other JJ amod
 +-- , , punct
 +-- included VBN advcl
 |   +-- since IN mark
 |   +-- t NN nsubjpass
 |   +-- is VBZ auxpass
 |   +-- in IN prep
 |   |   +-- V NNP pobj
 |   |       +-- ? . punct
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- , , punct
 |   |       +-- j UH appos
 |   +-- -RRB- -RRB- punct
 +-- we PRP nsubj
 +-- V NNP dobj
     +-- ? . punct
     +-- -LRB- -LRB- punct
     +-- , , punct
     +-- j NNP appos
     +-- -RRB- -RRB- punct
     +-- ? , punct
     +-- t NN appos
         +-- cost NN nn
         +-- -LRB- -LRB- punct
         +-- -RRB- -RRB- punct
Input: These two inequalities imply the desired bound
Parse:
imply VBP ROOT
 +-- inequalities NNS nsubj
 |   +-- These DT det
 |   +-- two CD num
 +-- desired VBN dobj
     +-- the DT det
     +-- bound VBN partmod
Input: In the second case , imagine a modified instance of iKnapsack -LRB- , j -RRB- , which excludes all the tuples of the set Skip
Parse:
imagine VB ROOT
 +-- In IN prep
 |   +-- case NN pobj
 |       +-- the DT det
 |       +-- second JJ amod
 +-- , , punct
 +-- instance NN dobj
     +-- a DT det
     +-- modified JJ amod
     +-- of IN prep
     |   +-- iKnapsack NN pobj
     +-- -LRB- -LRB- punct
     +-- j NNP dep
     |   +-- , , punct
     +-- -RRB- -RRB- punct
     +-- , , punct
     +-- excludes VBZ rcmod
         +-- which WDT nsubj
         +-- tuples NNS dobj
             +-- all PDT predet
             +-- the DT det
             +-- of IN prep
                 +-- Skip NN pobj
                     +-- the DT det
                     +-- set VBN amod
Input: Since none of these tuples were included in V ? -LRB- , j -RRB- , the optimal solution for the modified problem should be the same as the one for the original
Parse:
same JJ ROOT
 +-- included VBN advcl
 |   +-- Since IN mark
 |   +-- none NN nsubjpass
 |   |   +-- of IN prep
 |   |       +-- tuples NNS pobj
 |   |           +-- these DT det
 |   +-- were VBD auxpass
 |   +-- in IN prep
 |   |   +-- V NNP pobj
 |   |       +-- ? . punct
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- , , punct
 |   |       +-- j NNP appos
 |   +-- -RRB- -RRB- punct
 +-- , , punct
 +-- solution NN nsubj
 |   +-- the DT det
 |   +-- optimal JJ amod
 |   +-- for IN prep
 |       +-- problem NN pobj
 |           +-- the DT det
 |           +-- modified JJ amod
 +-- should MD aux
 +-- be VB cop
 +-- the DT det
 +-- as IN prep
     +-- one NN pobj
         +-- the DT det
         +-- for IN prep
             +-- original JJ pobj
                 +-- the DT det
Input: Suppose our approximation algorithm returns the value V -LRB- , j -RRB- for this modified instance
Parse:
Suppose VB ROOT
 +-- returns VBZ ccomp
     +-- algorithm NNP nsubj
     |   +-- our PRP$ poss
     |   +-- approximation NN nn
     +-- V NN dobj
     |   +-- the DT det
     |   +-- value NN nn
     |   +-- -LRB- -LRB- punct
     |   +-- , , punct
     |   +-- j NNP appos
     |   +-- -RRB- -RRB- punct
     +-- for IN prep
         +-- instance NN pobj
             +-- this DT det
             +-- modified JJ amod
Input: Let t be the last tuple considered by the approximation algorithm before termination on the modified instance , and let St be the corresponding tentative solution set in that step
Parse:
Let VB ROOT
 +-- tuple NN ccomp
 |   +-- t PRP nsubj
 |   +-- be VB cop
 |   +-- the DT det
 |   +-- last JJ amod
 |   +-- considered VBN partmod
 |       +-- by IN prep
 |       |   +-- algorithm NN pobj
 |       |       +-- the DT det
 |       |       +-- approximation NN nn
 |       +-- before IN prep
 |           +-- termination NN pobj
 |               +-- on IN prep
 |                   +-- instance NN pobj
 |                       +-- the DT det
 |                       +-- modified JJ amod
 +-- , , punct
 +-- and CC cc
 +-- let VB conj
     +-- solution NN ccomp
         +-- St NNP nsubj
         +-- be VB cop
         +-- the DT det
         +-- corresponding VBG amod
         +-- tentative JJ amod
         +-- set VBN partmod
             +-- in IN prep
                 +-- step NN pobj
                     +-- that DT det
Input: Since we consider tuples in order of increasing per unit price , and none of the tuples are going to be placed in the set Skip , we must have cost -LRB- St -RRB- < V ? -LRB- , j -RRB- because St is the optimal way to obtain size -LRB- St -RRB-
Parse:
have VB ROOT
 +-- consider VBP advcl
 |   +-- Since IN mark
 |   +-- we PRP nsubj
 |   +-- tuples NNS dobj
 |   +-- in IN prep
 |   |   +-- order NN pobj
 |   |       +-- of IN prep
 |   |           +-- increasing VBG pcomp
 |   |               +-- per IN prep
 |   |                   +-- price NN pobj
 |   |                       +-- unit NN nn
 |   +-- , , punct
 |   +-- and CC cc
 |   +-- going VBG conj
 |       +-- none NN nsubj
 |       |   +-- of IN prep
 |       |       +-- tuples NNS pobj
 |       |           +-- the DT det
 |       +-- are VBP aux
 |       +-- placed VBN xcomp
 |           +-- to TO aux
 |           +-- be VB auxpass
 |           +-- in IN prep
 |               +-- Skip NNP pobj
 |                   +-- the DT det
 |                   +-- set VBN amod
 +-- , , punct
 +-- we PRP nsubj
 +-- must MD aux
 +-- cost NN dobj
 |   +-- -LRB- -LRB- punct
 |   +-- St NNP dep
 |   +-- -RRB- -RRB- punct
 |   +-- < -LRB- punct
 |   +-- V NN dep
 |   +-- ? . punct
 |   +-- , , punct
 |   +-- j NFP punct
 +-- way NN advcl
 |   +-- because IN mark
 |   +-- St NNP nsubj
 |   +-- is VBZ cop
 |   +-- the DT det
 |   +-- optimal JJ amod
 |   +-- obtain VB infmod
 |       +-- to TO aux
 |       +-- size NN dobj
 +-- St NNP parataxis
     +-- -LRB- -LRB- punct
     +-- -RRB- -RRB- punct
Input: We also have cost -LRB- t -RRB- ? cost -LRB- St -RRB- , and the following inequalities
Parse:
have VBP ROOT
 +-- We PRP nsubj
 +-- also RB advmod
 +-- cost NN dobj
     +-- -LRB- -LRB- punct
     +-- t NN dep
     +-- -RRB- -RRB- punct
     +-- ? , punct
     +-- cost NN conj
     |   +-- -LRB- -LRB- punct
     |   +-- St NNP dep
     |   +-- -RRB- -RRB- punct
     +-- , , punct
     +-- and CC cc
     +-- inequalities NNS conj
         +-- the DT det
         +-- following VBG amod
Input: Therefore , dropping the tuples in the set Skip can only make the solution worse
Parse:
make VB ROOT
 +-- Therefore RB advmod
 +-- , , punct
 +-- dropping VBG csubj
 |   +-- tuples NNS dobj
 |   |   +-- the DT det
 |   +-- in IN prep
 |       +-- Skip NNP pobj
 |           +-- the DT det
 |           +-- set NN amod
 +-- can MD aux
 +-- only RB advmod
 +-- worse JJR xcomp
     +-- solution NN nsubj
         +-- the DT det
Input: The above argument has shown that the value returned by Greedy -LRB- , j -RRB- is within a factor 2 of the optimal solution for iKnapsack -LRB- , j -RRB-
Parse:
shown VBN ROOT
 +-- argument NN nsubj
 |   +-- The DT det
 |   +-- above JJ amod
 +-- has VBZ aux
 +-- is VBZ ccomp
 |   +-- that IN mark
 |   +-- value NN nsubj
 |   |   +-- the DT det
 |   |   +-- returned VBN partmod
 |   |   |   +-- by IN prep
 |   |   |       +-- Greedy NNP pobj
 |   |   |           +-- -LRB- -LRB- punct
 |   |   |           +-- , , punct
 |   |   |           +-- j NFP appos
 |   |   +-- -RRB- -RRB- punct
 |   +-- within IN prep
 |       +-- factor NN pobj
 |           +-- a DT det
 |           +-- 2 CD num
 |           +-- of IN prep
 |               +-- solution NN pobj
 |                   +-- the DT det
 |                   +-- optimal JJ amod
 |                   +-- for IN prep
 |                   |   +-- iKnapsack NN pobj
 |                   +-- -LRB- -LRB- punct
 |                   +-- , , punct
 |                   +-- j NFP appos
 +-- -RRB- -RRB- punct
Input: We now show that the value V -LRB- , j -RRB- plus cost -LRB- tj -RRB- is a 2 approximation of the original generalized knapsack problem
Parse:
show VBP ROOT
 +-- We PRP nsubj
 +-- now RB advmod
 +-- approximation NN ccomp
     +-- that IN mark
     +-- value NN nsubj
     |   +-- the DT det
     |   +-- V NNP dep
     |       +-- -LRB- -LRB- punct
     |       +-- , , punct
     |       +-- j NFP conj
     |       +-- -RRB- -RRB- punct
     |       +-- plus CC cc
     |       +-- tj NNP conj
     |           +-- cost NN nn
     |           +-- -LRB- -LRB- punct
     |           +-- -RRB- -RRB- punct
     +-- is VBZ cop
     +-- a DT det
     +-- 2 CD num
     +-- of IN prep
         +-- problem NN pobj
             +-- the DT det
             +-- original JJ amod
             +-- generalized VBN amod
             +-- knapsack NN nn
Input: Let A ? be an optimal solution of the generalized knapsack , and suppose that element xj is midrange
Parse:
Let VB ROOT
 +-- A DT dobj
 +-- ? , punct
 +-- solution NN conj
 |   +-- be VB cop
 |   +-- an DT det
 |   +-- optimal JJ amod
 |   +-- of IN prep
 |       +-- knapsack NN pobj
 |           +-- the DT det
 |           +-- generalized JJ amod
 +-- , , punct
 +-- and CC cc
 +-- suppose VB conj
     +-- midrange JJ ccomp
         +-- that IN mark
         +-- xj , nsubj
         |   +-- element NN nn
         +-- is VBZ cop
Input: Let x ? to be set of the remaining elements , either zero or anchors , in this solution
Parse:
Let VB ROOT
 +-- x PRP dobj
 +-- ? . punct
 +-- set VBN xcomp
     +-- to TO aux
     +-- be VB auxpass
     +-- of IN prep
     |   +-- elements NNS pobj
     |       +-- the DT det
     |       +-- remaining VBG amod
     +-- , , punct
     +-- zero CD dobj
     |   +-- either CC preconj
     |   +-- or CC cc
     |   +-- anchors NNS conj
     +-- in IN prep
         +-- solution NN pobj
             +-- this DT det
Input: Furthermore , define x = xj ? uj
Parse:
define VB ROOT
 +-- Furthermore RB advmod
 +-- , , punct
 +-- x SYM prep
 |   +-- xj NN dep
 |       +-- = SYM dep
 +-- ? . punct
 +-- uj . punct
Input: Thus , cost -LRB- A ? -RRB- = cost -LRB- xl -RRB- + cost -LRB- tj l -RRB- + cost -LRB- x ? l -RRB- It is easy to see that -LRB- x ? , x -RRB- is an optimal solution for iKnapsack -LRB- , j -RRB-
Parse:
easy JJ ROOT
 +-- Thus RB advmod
 +-- , , punct
 +-- cost NN nsubj
 |   +-- A NN nn
 |   |   +-- cost NN nn
 |   |   +-- -LRB- -LRB- punct
 |   |   +-- ? . punct
 |   |   +-- -RRB- -RRB- punct
 |   +-- = `` nn
 |   +-- -LRB- -LRB- punct
 |   +-- xl NNP dep
 |   +-- -RRB- -RRB- punct
 |   +-- + SYM cc
 |   +-- cost NN conj
 |       +-- l NNP dep
 |       |   +-- -LRB- -LRB- punct
 |       |   +-- tj NNP nn
 |       |   +-- -RRB- -RRB- punct
 |       +-- + SYM dep
 |       +-- cost NN dep
 +-- x SYM parataxis
 |   +-- -LRB- -LRB- punct
 |   +-- ? . punct
 |   +-- l NNP dep
 |   +-- -RRB- -RRB- punct
 +-- It PRP nsubj
 +-- is VBZ cop
 +-- see VB xcomp
 |   +-- to TO aux
 |   +-- solution NN ccomp
 |       +-- that IN mark
 |       +-- x SYM nsubj
 |       |   +-- -LRB- -LRB- punct
 |       |   +-- ? . punct
 |       |   +-- , , punct
 |       |   +-- x SYM punct
 |       |   +-- -RRB- -RRB- punct
 |       +-- is VBZ cop
 |       +-- an DT det
 |       +-- optimal JJ amod
 |       +-- for IN prep
 |           +-- iKnapsack NN pobj
 +-- -LRB- -LRB- punct
 +-- j NFP dep
 +-- -RRB- -RRB- punct
Input: Since V -LRB- , j -RRB- is a 2 approximation for this optimal solution , we have the following inequalities
Parse:
have VBP ROOT
 +-- approximation NN advcl
 |   +-- Since IN mark
 |   +-- V NNP nsubj
 |   |   +-- j NNP appos
 |   |       +-- -LRB- -LRB- punct
 |   |       +-- , , punct
 |   |       +-- -RRB- -RRB- punct
 |   +-- is VBZ cop
 |   +-- a DT det
 |   +-- 2 CD num
 |   +-- for IN prep
 |       +-- solution NN pobj
 |           +-- this DT det
 |           +-- optimal JJ amod
 +-- , , punct
 +-- we PRP nsubj
 +-- inequalities NNS dobj
     +-- the DT det
     +-- following VBG amod
Input: It is easy to see that , after an initial sorting of the tuples in U , the algorithm Greedy -LRB- , j -RRB- takes O -LRB- n -RRB- time
Parse:
easy JJ ROOT
 +-- It PRP nsubj
 +-- is VBZ cop
 +-- see VB xcomp
     +-- to TO aux
     +-- takes VBZ ccomp
         +-- that IN mark
         +-- , , punct
         +-- after IN prep
         |   +-- sorting NN pobj
         |       +-- an DT det
         |       +-- initial JJ amod
         |       +-- of IN prep
         |           +-- tuples NNS pobj
         |               +-- the DT det
         |               +-- in IN prep
         |                   +-- U NNP pobj
         +-- Greedy NNP nsubj
         |   +-- the DT det
         |   +-- algorithm NNP nn
         |   +-- -LRB- -LRB- punct
         |   +-- , , punct
         |   +-- j NFP conj
         |   +-- -RRB- -RRB- punct
         +-- time NN dobj
             +-- O NN amod
                 +-- -LRB- -LRB- punct
                 +-- n LS dep
                 +-- -RRB- -RRB- punct
Input: We have our first polynomial approximation algorithm
Parse:
have VBP ROOT
 +-- We PRP nsubj
 +-- approximation NN dobj
     +-- our PRP$ poss
     +-- first JJ amod
     +-- polynomial JJ amod
     +-- algorithm ADD dep
Input: THEOREM 2
Parse:
THEOREM UH ROOT
 +-- 2 CD num
Input: A 2 approximation of the generalized knapsack problem can be found in time O -LRB- n2 -RRB- , where n is number of item lists -LRB- each of constant length -RRB-
Parse:
found VBN ROOT
 +-- approximation NN nsubjpass
 |   +-- A DT det
 |   +-- 2 CD num
 |   +-- of IN prep
 |       +-- problem NN pobj
 |           +-- the DT det
 |           +-- generalized JJ amod
 |           +-- knapsack NN nn
 +-- can MD aux
 +-- be VB auxpass
 +-- in IN prep
 |   +-- time NN pobj
 +-- O NNP prep
     +-- -LRB- -LRB- punct
     +-- n2 CD dep
     +-- -RRB- -RRB- punct
     +-- , , punct
     +-- number NN rcmod
     |   +-- where WRB advmod
     |   +-- n NNP nsubj
     |   +-- is VBZ cop
     |   +-- of IN prep
     |       +-- lists NNS pobj
     |           +-- item NN nn
     +-- each DT dep
         +-- -LRB- -LRB- punct
         +-- of IN prep
         |   +-- length NN pobj
         |       +-- constant JJ amod
         +-- -RRB- -RRB- punct
Input: PROOF
Parse:
PROOF NNP ROOT
Input: We run the algorithm Greedy -LRB- , j -RRB- once for each tuple -LRB- l , j -RRB- as a candidate for midrange
Parse:
run VBP ROOT
 +-- We PRP nsubj
 +-- Greedy NNP dobj
 |   +-- the DT det
 |   +-- algorithm NNP nn
 |   +-- j NNP appos
 |       +-- -LRB- -LRB- punct
 |       +-- , , punct
 |       +-- -RRB- -RRB- punct
 +-- once RB advmod
 +-- for IN prep
 |   +-- tuple NN pobj
 |       +-- each DT det
 |       +-- -LRB- -LRB- punct
 |       +-- l NNP dep
 |       |   +-- , , punct
 |       |   +-- j NNP appos
 |       +-- -RRB- -RRB- punct
 +-- as IN prep
     +-- candidate NN pobj
         +-- a DT det
         +-- for IN prep
             +-- midrange NN pobj
Input: There are O -LRB- n -RRB- tuples , and it suffices to sort them once , the total cost of the algorithm is O -LRB- n2 one midrange element , so our algorithm will find a 2 approximation , as claimed
Parse:
are VBP ROOT
 +-- There EX expl
 +-- tuples NNS nsubj
 |   +-- n LS nn
 |       +-- O NNP nn
 |       +-- -LRB- -LRB- punct
 |       +-- -RRB- -RRB- punct
 +-- , , punct
 +-- and CC cc
 +-- suffices VBZ conj
 |   +-- it PRP nsubj
 |   +-- sort VB xcomp
 |       +-- to TO aux
 |       +-- them PRP dobj
 |       +-- once RB advmod
 +-- element NN ccomp
 |   +-- cost NN nsubj
 |   |   +-- the DT det
 |   |   +-- total JJ amod
 |   |   +-- of IN prep
 |   |       +-- algorithm NN pobj
 |   |           +-- the DT det
 |   +-- is VBZ cop
 |   +-- O FW nn
 |   +-- -LRB- -LRB- punct
 |   +-- n2 CD dep
 |   +-- one CD num
 |   +-- midrange NN amod
 +-- so IN cc
 +-- find VB conj
     +-- algorithm NN nsubj
     |   +-- our PRP$ poss
     +-- will MD aux
     +-- approximation NN dobj
     |   +-- a DT det
     |   +-- 2 CD num
     +-- , , punct
     +-- claimed VBD advcl
         +-- as IN mark
Input: The dependence on the number of pieces is also polynomial
Parse:
polynomial JJ ROOT
 +-- dependence NN nsubj
 |   +-- The DT det
 |   +-- on IN prep
 |       +-- number NN pobj
 |           +-- the DT det
 |           +-- of IN prep
 |               +-- pieces NNS pobj
 +-- is VBZ cop
 +-- also RB advmod
Input: 171 3.3 An Approximation Scheme We now use the 2 approximation algorithm presented in the preceding section to develop a fully polynomial approximation -LRB- FPTAS -RRB- for the generalized knapsack problem
Parse:
use VBP ROOT
 +-- Scheme IN nsubj
 |   +-- 3.3 CD num
 |   |   +-- 171 CD number
 |   +-- An DT det
 |   +-- Approximation NNP nn
 +-- We PRP nsubj
 +-- now RB advmod
 +-- algorithm NN dobj
 |   +-- the DT det
 |   +-- 2 CD num
 |   +-- approximation NN nn
 |   +-- presented VBN partmod
 |       +-- in IN prep
 |           +-- section NN pobj
 |               +-- the DT det
 |               +-- preceding VBG amod
 +-- develop VB xcomp
     +-- to TO aux
     +-- approximation NN dobj
         +-- a DT det
         +-- polynomial JJ amod
         |   +-- fully RB advmod
         +-- -LRB- -LRB- punct
         +-- FPTAS NNP dep
         +-- -RRB- -RRB- punct
         +-- for IN prep
             +-- problem NN pobj
                 +-- the DT det
                 +-- generalized JJ amod
                 +-- knapsack NN nn
Input: The high level idea is fairly standard , but the details require technical care
Parse:
standard JJ ROOT
 +-- idea NN nsubj
 |   +-- The DT det
 |   +-- level NN nn
 |       +-- high JJ amod
 +-- is VBZ cop
 +-- fairly RB advmod
 +-- , , punct
 +-- but CC cc
 +-- require VBP conj
     +-- details NNS nsubj
     |   +-- the DT det
     +-- care NN dobj
         +-- technical JJ amod
Input: We use a dynamic programming algorithm to solve iKnapsack -LRB- , j -RRB- for each possible midrange element , with the 2 approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming -LRB- DP -RRB- table
Parse:
use VBP ROOT
 +-- We PRP nsubj
 +-- algorithm NN dobj
 |   +-- a DT det
 |   +-- dynamic JJ amod
 |   +-- programming NN nn
 +-- solve VB xcomp
     +-- to TO aux
     +-- iKnapsack NNP dobj
     |   +-- -LRB- -LRB- punct
     |   +-- , , punct
     |   +-- j NFP conj
     |   +-- -RRB- -RRB- punct
     +-- for IN prep
     |   +-- element NN pobj
     |       +-- each DT det
     |       +-- possible JJ amod
     |       +-- midrange NN amod
     +-- , , punct
     +-- with IN prep
         +-- providing VBG pcomp
             +-- algorithm NN nsubj
             |   +-- the DT det
             |   +-- approximation NN nn
             |       +-- 2 CD num
             +-- upper JJ dobj
             |   +-- an DT det
             |   +-- bound VBN partmod
             |       +-- on IN prep
             |           +-- value NN pobj
             |               +-- the DT det
             |               +-- of IN prep
             |                   +-- solution NN pobj
             |                       +-- the DT det
             +-- and CC cc
             +-- enabling VBG conj
                 +-- use NN dobj
                     +-- the DT det
                     +-- of IN prep
                         +-- scaling VBG pcomp
                             +-- on IN prep
                                 +-- dimension NN pobj
                                     +-- the DT det
                                     +-- cost NN nn
                                     +-- of IN prep
                                         +-- table NN pobj
                                             +-- programming NN nn
                                                 +-- the DT det
                                                 +-- dynamic JJ amod
                                                 +-- -LRB- -LRB- punct
                                                 +-- DP NNP dep
                                                 +-- -RRB- -RRB- punct
Input: Consider , for example , the case that the midrange element is x , which falls in the range -LRB- uj , uj+1 We now consider the related problem of computing the VCG payments for all the agents
Parse:
Consider VB ROOT
 +-- , , punct
 +-- for IN prep
 |   +-- example NN pobj
 +-- case NN dobj
     +-- the DT det
     +-- is VBZ ccomp
         +-- that IN mark
         +-- element NN nsubj
         |   +-- the DT det
         |   +-- midrange NN amod
         +-- x , punct
         +-- , , punct
         +-- falls VBZ ccomp
             +-- which WDT nsubj
             +-- in IN prep
                 +-- range NN pobj
                     +-- the DT det
                     +-- -LRB- -LRB- punct
                     +-- uj UH discourse
                     +-- , , punct
                     +-- uj+1 CD appos
                         +-- consider VBP rcmod
                             +-- We PRP nsubj
                             +-- now RB advmod
                             +-- problem NN dobj
                                 +-- the DT det
                                 +-- related JJ amod
                                 +-- of IN prep
                                     +-- computing VBG pcomp
                                         +-- payments NNS dobj
                                             +-- the DT det
                                             +-- VCG NNP nn
                                             +-- for IN prep
                                                 +-- agents NNS pobj
                                                     +-- all PDT predet
                                                     +-- the DT det
Input: A naive approach requires solving the allocation problem n times , removing each agent in turn
Parse:
requires VBZ ROOT
 +-- approach NN nsubj
 |   +-- A DT det
 |   +-- naive JJ amod
 +-- solving VBG xcomp
     +-- problem NN iobj
     |   +-- the DT det
     |   +-- allocation NN nn
     +-- times NNS dobj
     |   +-- n CC punct
     +-- , , punct
     +-- removing VBG partmod
         +-- agent NN dobj
         |   +-- each DT det
         +-- in IN prep
             +-- turn NN pobj
